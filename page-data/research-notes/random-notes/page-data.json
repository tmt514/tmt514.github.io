{"componentChunkName":"component---src-components-blog-post-js","path":"/research-notes/random-notes","result":{"data":{"markdownRemark":{"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Single Sourcewise Multiplicative Spanners"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Khuller, Raghavachari and Young. "},{"type":"element","tagName":"a","properties":{"href":"https://link.springer.com/article/10.1007/BF01294129"},"children":[{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"Balancing Minimum Spanning Trees and Shortest-Path Trees"}]}]},{"type":"text","value":", Algorithmica 1995."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"theorem","properties":{"title":"Theorem"},"children":[{"type":"text","value":"\nGiven minimum spanning tree $T_M$ and shortest path tree $T_S$ with the same root $r$ and any constant $K>0$.\nThere is an algorithm in $O(n)$ time producing a tree $T$ that has (1) total weight $\\le (1+2/K)|T_M|$ and\n(2) for all vertex $v$, the distance from $r$ to $v$ is at most $(1+K)\\mathrm{dist}(r, v)$ in $T_S$.\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h4","properties":{},"children":[{"type":"text","value":"Proof Sketch."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The algorithm maintains a subgraph $H$, and runs DFS along minimum spanning tree $T_M$.\nInitially the subgraph $H$ is set to $T_M$.\nWhenever the algorithm arrives a vertex $v$,\nand if the current distance $d[v] > (1+K)\\mathrm{dist}(r, v)$,\nthe algorithm adds the entire shortest path $P(r, v)$ to $H$."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Let paths $P(r, v_1), P(r, v_2), \\ldots, P(r, v_k)$ be the shortest path added to $H$\nduring the execution of the algorithm.\nThe total increase of the cost is $\\sum_{i=1}^k \\mathrm{dist}(r, v_i)$.\nHowever, by the time $P(r, v_i)$ is added to $H$ we have that $(1+K)\\mathrm{dist}(r, v_i) < d[v_i] \\le \\mathrm{dist}(r, v_{i-1}) + d_M(v_{i-1}, v_i)$.\nBy summing both sides from $i=1$ to $k$, we get total increase cost is no more than $\\frac{2}{K}|T_M|$."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h4","properties":{},"children":[{"type":"text","value":"重點"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"只有在 DFS 往上或往下爬的時候才 relax edge，這樣就足夠好了，不用每次重算 $H$ 上面的最短路徑。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"利用上次加 path 的位置作 telescoping sum，加起來剛好繞 MST（或任何樹）一圈。"}]},{"type":"text","value":"\n"}]}],"data":{"quirksMode":false}},"frontmatter":{"date":"April 20, 2019","path":"/research-notes/random-notes","title":"Random Paper Notes","description":null,"roadmap_label_h3":null,"backlink":"/research-notes","css_title_theme":"is-info research","css_content_theme":"research","math_font":"Gyre-Pagella"}}},"pageContext":{}},"staticQueryHashes":["1470849938","511501522"]}