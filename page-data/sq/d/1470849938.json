{"data":{"pages":{"edges":[{"node":{"frontmatter":{"title":"關於競程日記 2019","category":"roadmap","path":"/icpcblog-weekly-2019","date":"2018-12-26","description":null,"link":null,"code":null,"difficulty":null,"oj":null,"tags":null},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"每一週我們會決定一個題組，然後從當中盡量每天挑選一題撰寫題解，並且同步發布於"},{"type":"element","tagName":"a","properties":{"href":"https://www.facebook.com/TaiwanCompetitiveProgrammingBlog/"},"children":[{"type":"text","value":"競程日記FB專頁"}]},{"type":"text","value":"上面。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"(Jan.01 - Jan.07) ICPC 2018 Asia Jakarta Regional"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://codeforces.com/blog/entry/63220"},"children":[{"type":"text","value":"Codeforces 文章連結"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://codeforces.com/gym/102001"},"children":[{"type":"text","value":"Codefroces Gym 題目連結"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://competition.binus.ac.id/icpc2018/final.html"},"children":[{"type":"text","value":"Final Standings"}]},{"type":"text","value":" (點選上面題號可以看到題目 PDF)"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://github.com/jonathanirvings/icpc-jakarta-2018/"},"children":[{"type":"text","value":"測試資料與解答 GitHub @jonathanirvings"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"提供競程日記的參考題解："},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"problem-list-as-tags","properties":{"n":"12","path-prefix":"/problem/icpc/asia_jakarta_2018"},"children":[]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"(Jan.08 - Jan.14) ICPC 2018 Asia Hanoi Regional"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://open.kattis.com/problem-sources/The%202018%20ICPC%20Asia%20Hanoi%20Regional%20Contest"},"children":[{"type":"text","value":"ProblemSet On Open Kattis"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://hanoi18.kattis.com/standings"},"children":[{"type":"text","value":"Final Standings"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"提供競程日記的參考題解："},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"problem-list-as-tags","properties":{"n":"12","path-prefix":"/problem/icpc/asia_hanoi_2018"},"children":[]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"(Jan.15 - Jan.21) ICPC 2018 Asia Singapore Regional"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://open.kattis.com/problem-sources/2018%20ICPC%20Asia%20Singapore%20Regional"},"children":[{"type":"text","value":"ProblemSet On Open Kattis"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://asiasg18.kattis.com/standings"},"children":[{"type":"text","value":"Final Standings"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"提供競程日記的參考題解："},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"problem-list-as-tags","properties":{"n":"12","path-prefix":"/problem/icpc/asia_singapore_2018"},"children":[]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"(Jan.22 - Jan.28) ICPC 2018 Asia Seoul Regional"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://codeforces.com/gym/101987"},"children":[{"type":"text","value":"Codefroces Gym 題目連結"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"http://icpckorea.org/archives/1774"},"children":[{"type":"text","value":"Local Contest Page"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"http://icpckorea.org/2018/regional/problemset-2018.pdf"},"children":[{"type":"text","value":"Problem Set (PDF)"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"http://icpckorea.org/2018/regional/2018_seoul_testdata.zip"},"children":[{"type":"text","value":"TestData.zip"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"http://icpckorea.org/2018/regional/scoreboard"},"children":[{"type":"text","value":"Final Standing"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"提供競程日記的參考題解："},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"problem-list-as-tags","properties":{"n":"12","path-prefix":"/problem/icpc/asia_seoul_2018"},"children":[]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"(TBD) ICPC 2018 Asia Nakhon Pathom Regional"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://www.ict.mahidol.ac.th/acmicpc/2018/"},"children":[{"type":"text","value":"Local Contest Page"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://codeforces.com/gym/102091/"},"children":[{"type":"text","value":"Codeforces Gym 題目連結"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"提供競程日記的參考題解："},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"problem-list-as-tags","properties":{"n":"12","path-prefix":"/problem/icpc/asia_nakhon_pathom_2018"},"children":[]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"(TBD) ICPC 2018 Yangon Regional"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"http://www.ucsy.edu.mm/ucsy/pages/aryangon2018.jsp"},"children":[{"type":"text","value":"Local Contest Page"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"http://www.ucsy.edu.mm/ucsy/pages/q-aryangon2018.pdf"},"children":[{"type":"text","value":"Problem Set (PDF)"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"(TBD) ICPC 2018 Yokohama Regional"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":""},"children":[{"type":"text","value":"Local Contest Page"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"http://storage.googleapis.com/icpcsec/2018-regional/problems_all.pdf"},"children":[{"type":"text","value":"Problem Set (PDF)"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"http://icpc.iisf.or.jp/past-icpc/regional2018/commentaries-2018.pdf"},"children":[{"type":"text","value":"Solution from Judge (投影片)"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"http://icpc.iisf.or.jp/past-icpc/regional2018/icpcdata2018.tar.gz"},"children":[{"type":"text","value":"Testdata"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"(TBD) ICPC 2018 Taipei Regional"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"http://icpc2018.ntu.edu.tw/"},"children":[{"type":"text","value":"Local Contest Page"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"http://icpc2018.ntu.edu.tw/problems.pdf"},"children":[{"type":"text","value":"Problem Set (PDF)"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://icpc2018score.ntu.edu.tw/"},"children":[{"type":"text","value":"Standings"}]}]},{"type":"text","value":"\n"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"測試文章","category":"algo","path":"/hello-world","date":"2018-11-09","description":null,"link":null,"code":null,"difficulty":null,"oj":null,"tags":null},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"This is a test"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"$f(x) = x^2$"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"額外的測試嗎XD"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這樣就可以一邊寫文章一邊寫數學式子了！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"$ax+by=\\frac{z^2}{y} what$"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"程式碼"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"test"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"test123 \n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"#include <cstdio>\nusing namespace std;\n\nint main(void) {\n    // 中文也可以\n    printf(\"Hello! World!\\n\");\n    return 0;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"My Algorithm Displayer"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"1. Static Data Display."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"display","properties":{"array":"","data":"[1, 2, \"test123\\n456\"]"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-html"]},"children":[{"type":"text","value":"<display array\n    data='[1, 2, \"test123\\n456\"]'></display>\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"2. A simple looping algorithm."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"algorithm","properties":{},"children":[{"type":"text","value":"\n    "},{"type":"element","tagName":"generator","properties":{},"children":[{"type":"element","tagName":"pre","properties":{},"children":[{"type":"text","value":"        function*(input, ui) {\n            var n = input.n;\n            var i;\n            var s = [];\n            for (i = 0; i < n; i++) {\n                s.push(i);\n                ui.setStyleOnce('arr', `${i}`, {fill: 'yellow'});\n                yield {arr: s};\n            }\n            return {arr: s};\n        }\n        "}]},{"type":"text","value":"\n    "}]},{"type":"text","value":"\n    "},{"type":"element","tagName":"inputdata","properties":{"data":"{\"n\": 10}"},"children":[]},{"type":"text","value":"\n    "},{"type":"element","tagName":"indirectdisplay","properties":{"array":"","n":"10","fixedwidth":"","highlightdiff":"","varname":"arr"},"children":[]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-html"]},"children":[{"type":"text","value":"<algorithm>\n    <generator><pre>\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-javascript"]},"children":[{"type":"text","value":"        function*(input, ui) {\n            var n = input.n;\n            var i;\n            var s = [];\n            for (i = 0; i < n; i++) {\n                s.push(i);\n                ui.setStyleOnce('arr', `${i}`, {fill: 'yellow'});\n                yield {arr: s};\n            }\n            return {arr: s};\n        }\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-html"]},"children":[{"type":"text","value":"        </pre>\n    </generator>\n    <inputdata\n        data='{\"n\": 10}'\n    ></inputdata>\n    <indirectdisplay\n        array\n        n='10'\n        fixedwidth\n        highlightdiff\n        varname='arr'\n    ></indirectdisplay>\n</algorithm>\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"3. A simple grid."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"display","properties":{"grid":"","data":"[\"...#.#\",\"..###.\",\"#...#.\"]"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-html"]},"children":[{"type":"text","value":"<display grid\n    data='[\"...#.#\",\"..###.\",\"#...#.\"]'\n    ></display>\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"display","properties":{"grid":"","notext":"","uistore":"{\n        styleRules: {\n            ruleZZ: {\n                apply_to: 'node',\n                pure_predicate_fn: (nodeProps) => { return nodeProps.content === '#'; },\n                options: { fill: 'black' },\n            }\n        }\n    }","data":"[\"...#.#\",\"..###.\",\"#...#.\"]"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-html"]},"children":[{"type":"text","value":"<display grid\n    notext\n    uistore=\"{\n        styleRules: {\n            ruleZZ: {\n                apply_to: 'node',\n                pure_predicate_fn: (nodeProps) => { return nodeProps.content === '#'; },\n                options: { fill: 'black' },\n            }\n        }\n    }\"\n    data='[\"...#.#\",\"..###.\",\"#...#.\"]'\n    ></display>\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"4. Random walk on a grid."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"algorithm","properties":{},"children":[{"type":"text","value":"\n    "},{"type":"element","tagName":"generator","properties":{},"children":[{"type":"element","tagName":"pre","properties":{},"children":[{"type":"text","value":"        function*(input, ui) {\n            var n = input.n;\n            var s = [];\n            var i, j;\n            var x = Math.floor(Math.random()*n);\n            var y = Math.floor(Math.random()*n);\n            for (i = 0; i < n; i++) {\n                var t = [];\n                for (j = 0; j < n; j++) {\n                    if (Math.floor(Math.random()*10) !== 0)\n                        t.push('.');\n                    else\n                        t.push('#');\n                }\n                s.push(t);\n            }\n            s[x][y] = '*';\n            ui.setStyle('arr', JSON.stringify([x, y]), {fill: '#FFEE33'});\n            ui.setStyleOnce('arr', JSON.stringify([x, y]), {fill: 'blue'});\n            yield { arr: s };\n            //\n            while (true) {\n                var d = Math.floor(Math.random()*4);\n                if (d === 0 && x+1 < n && s[x+1][y] === '.') {\n                    s[x][y] = '.'\n                    s[x+1][y] = '*'\n                    x += 1\n                } else if (d === 1 && x > 0 && s[x-1][y] === '.') {\n                    s[x][y] = '.'\n                    s[x-1][y] = '*'\n                    x -= 1\n                } else if (d === 2 && y+1 < n && s[x][y+1] === '.') {\n                    s[x][y] = '.'\n                    s[x][y+1] = '*'\n                    y += 1\n                } else if (d === 3 && y > 0 && s[x][y-1] === '.') {\n                    s[x][y] = '.'\n                    s[x][y-1] = '*'\n                    y -= 1\n                }\n                ui.setStyle('arr', JSON.stringify([x, y]), {fill: '#FFEE33'});\n                ui.setStyleOnce('arr', JSON.stringify([x, y]), {fill: 'blue'});\n                yield { arr: s };\n            }\n        }\n        "}]},{"type":"text","value":"\n    "}]},{"type":"text","value":"\n    "},{"type":"element","tagName":"inputdata","properties":{"data":"{\"n\": 10}"},"children":[]},{"type":"text","value":"\n    "},{"type":"element","tagName":"indirectdisplay","properties":{"grid":"","uistore":"{\n            styleRules: {\n                ruleZZ: {\n                    apply_to: 'node',\n                    pure_predicate_fn: (nodeProps) => { return nodeProps.content === '#'; },\n                    options: { fill: 'black', fontColor: 'white' },\n                }\n            }\n        }","varname":"arr"},"children":[]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-javascript"]},"children":[{"type":"text","value":"function*(input, ui) {\n            var n = input.n;\n            var s = [];\n            var i, j;\n            var x = Math.floor(Math.random()*n);\n            var y = Math.floor(Math.random()*n);\n            for (i = 0; i < n; i++) {\n                var t = [];\n                for (j = 0; j < n; j++) {\n                    if (Math.floor(Math.random()*10) !== 0)\n                        t.push('.');\n                    else\n                        t.push('#');\n                }\n                s.push(t);\n            }\n            s[x][y] = '*';\n            ui.setStyle('arr', JSON.stringify([x, y]), {fill: '#FFEE33'});\n            ui.setStyleOnce('arr', JSON.stringify([x, y]), {fill: 'blue'});\n            yield { arr: s };\n            //\n            while (true) {\n                var d = Math.floor(Math.random()*4);\n                if (d === 0 && x+1 < n && s[x+1][y] === '.') {\n                    s[x][y] = '.'\n                    s[x+1][y] = '*'\n                    x += 1\n                } else if (d === 1 && x > 0 && s[x-1][y] === '.') {\n                    s[x][y] = '.'\n                    s[x-1][y] = '*'\n                    x -= 1\n                } else if (d === 2 && y+1 < n && s[x][y+1] === '.') {\n                    s[x][y] = '.'\n                    s[x][y+1] = '*'\n                    y += 1\n                } else if (d === 3 && y > 0 && s[x][y-1] === '.') {\n                    s[x][y] = '.'\n                    s[x][y-1] = '*'\n                    y -= 1\n                }\n                ui.setStyle('arr', JSON.stringify([x, y]), {fill: '#FFEE33'});\n                ui.setStyleOnce('arr', JSON.stringify([x, y]), {fill: 'blue'});\n                yield { arr: s };\n            }\n        }\n"}]}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"Leetcode 刷題指南 v0.1","category":"roadmap","path":"/leetcode-guide","date":"2018-12-21","description":null,"link":null,"code":null,"difficulty":null,"oj":null,"tags":null},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這份指南把一些面試經典題型整理出來，給大家參考。\n每一個主題大約是 1 小時的閱讀份量與 3 小時的實作份量。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"一道題目如果給不出三種不盡相同的作法，代表你還沒有參透這個題目，或是這個題目太死板啦。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"卡恩 (2018.12)"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"鏈結串列 Linked Lists"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"/leetcode-guide/what-is-data-structure"},"children":[{"type":"text","value":"關於資料結構 Data Structures"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"/leetcode-guide/linked-lists"},"children":[{"type":"text","value":"鏈結串列的大致分類 Type of Linked Lists"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"tag-easy","properties":{},"children":[]},{"type":"element","tagName":"include-problem","properties":{"inline":"","path":"/problem/leetcode/206","link":"https://leetcode.com/problems/reverse-linked-list/"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"tag-medium","properties":{},"children":[]},{"type":"element","tagName":"include-problem","properties":{"inline":"","path":"/problem/leetcode/19"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"/leetcode-guide/find-linked-list-cycle"},"children":[{"type":"text","value":"找出鏈結串列的循環節"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"陣列 Arrays"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"排序方法 Sorting Algorithms"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"單調性與兩個指標 Two Pointers"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"樹 Trees"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"堆疊與深度優先搜索 Stack and Depth First Search"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"佇列與廣度優先搜索 Queue and Breadth First Search"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"雜湊表 Hash Tables"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"優先序佇列與堆積 Priority Queues and Heaps"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"圖 Graphs"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"動態規劃：序列 Dynamic Programming on Sequences"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"動態規劃：字串 Dynamic Programming on Strings"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"機率與隨機數 Probabilities"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"搜尋樹 Search Trees"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"字母樹 Tries"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"計算幾何 Computational Geometry"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"數論 Number Theory"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"物件導向程式設計 OOP"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"熟悉你的程式語言：C++"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"熟悉你的程式語言：Python"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"熟悉你的程式語言：Javascript"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"枚舉法 1：試誤原則 Trial and Error","category":"algo","path":"/algo/enumeration-1","date":"2018-12-05","description":null,"link":null,"code":null,"difficulty":null,"oj":null,"tags":null},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"今天來聊聊四種解題方法之一：枚舉法。每一道題目都有一個解，當我們沒辦法立刻說出答案的時候，最原始的方法就是利用試誤(trial-error)的原則，考慮所有可能的答案，並一個一個判斷是否它滿足我們的需求。有時候這方法挺好用的。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"資訊與數學最大的不同是，我們可以利用有限的時間，讓電腦幫我們逐一檢驗可能的答案，進而省略一些繁雜的數學證明或更細緻的檢驗步驟。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"換句話說，如果我們能用"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"簡單的數學證明"}]},{"type":"text","value":"保證答案會出現在我們提出的許多數值之中，那麼就能夠證明演算法的正確性了。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"include-problem","properties":{"title-prefix":"例題 1：","path":"/problem/isprime"},"children":[{"type":"text","value":"\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"顯然，要「否定」$n$ 是否為質數這個敘述，只需要找出一個「反例」。而顯然這個反例 $x$ 會介於 $[2, n-1]$ 之間。逐一檢查 $2, 3, \\ldots, n-1$ 就可以知道答案是 Yes 還是 No 了。這個方法需要 $O(n)$ 次模運算。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"透過簡單觀察，我們發現：若 $n$ 是合數，可以表示成 $n=a\\times b$。那麼此時有 $\\min(a, b)\\le \\sqrt{n}$。也就是說，若存在反例，最小的反例一定會出現在 $[2, \\sqrt{n}]$ 之間。於是，我們就得到一個 $O(\\sqrt{n})$ 時間的演算法了。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"bool isprime(int n) {\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0)\n            return false;\n    }\n    return true;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"結論"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"theorem","properties":{"c":"is-success"},"children":[{"type":"text","value":"\n本題透過枚舉「至少一個」 $n$ 可能的真因數，進而達到解題的目的。\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"include-problem","properties":{"title-prefix":"例題 2：","path":"/problem/leetcode/326"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"注意到 3 的次方其實數量不多，所以我們可以直接嘗試所有可能的次方數值，並且與 $x$ 進行比對。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"bool isPowerOfThree(int n) {\n    for (long long i = 1; i <= n; i *= 3)\n        if (n == i)\n            return true;\n    return false;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"結論"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"theorem","properties":{"c":"is-success"},"children":[{"type":"text","value":"\n本題透過枚舉所有 3 的次方值，達到解題目的。\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"延伸思考"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這題其實不使用諸如 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"log()"}]},{"type":"text","value":" 函式的浮點數計算也可以做得到 $O(1)$ 時間唷，你能想得到嗎？"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"include-problem","properties":{"title-prefix":"例題 3：","path":"/problem/cf/233/B"},"children":[{"type":"text","value":"\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"對於一個一元二次方程我們可以利用已知的公式 $x=\\frac{-b\\pm\\sqrt{b^2-4ac}}{2a}$ 來求出方程的根，但是 $s(x)$ 是一個與 $x$ 有關的函數，所以無法直接從公式下手。枚舉 $x$ 的範圍可以粗估是 $1\\le x\\le \\sqrt{n} \\approx 10^9$，但一個一個檢查會花太多時間。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"注意到 $s(x)$ 是 $x$ 的各位數字和，這個值的範圍相較於 $n$ 小了不少。可以估計的是當 $x\\le 10^{9}$ 時，有 $1\\le s(x)\\le 81$。因此若我們先"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"逐一枚舉 $s(x)$ 的值"}]},{"type":"text","value":"，就可以把題目當成一般的一元二次方程來解了！找到解以後，再驗證其各位數字和是否就是我們枚舉的值，就可以了。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"#include <iostream>\n#include <cmath>\nusing namespace std;\n\n// 計算各位數字和。\nint s(long long x) {\n    int t=0;\n    while(x>0) { t+=x%10; x/=10; }\n    return t;\n}\n\n// 對於枚舉的 s(x) 值 t，找出合法的解，由於解會是一正一負，我們只回傳正的那個。\nlong long getsol(int t, long long n) {\n    long long r = t*t+n*4, v = 0;\n    v = sqrt(r);\n    while(v*v<r) v++; while(v*v>r) v--;\n    if(v*v!=r) return -1;\n    v-=t; if(v%2 || v<0) return -1;\n    v/=2;\n    return v;\n}\n\nint main(void) {\n    long long n, x, t, ans=-1;\n    cin >> n;\n    for (t = 1; t <= 81; t++) {\n        x = getsol(t, n);\n        if(x<0) continue;\n        if(s(x)==t && ( ans==-1 || ans > x)) ans = x;\n    }\n    cout << ans << endl;\n    return 0;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"結論"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"theorem","properties":{"c":"is-success"},"children":[{"type":"text","value":"\n本題透過觀察並枚舉 $s(x)$ 的值，來縮小可能的答案範圍。\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"練習題"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"include-problem","properties":{"path":"/problem/ural/1854","inline":""},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"include-problem","properties":{"path":"/problem/cf/911/C","inline":""},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"include-problem","properties":{"path":"/problem/cf/241/C","inline":""},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"include-problem","properties":{"path":"/problem/icpc/ecna2018/B","inline":""},"children":[]}]},{"type":"text","value":"\n"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"枚舉法 2：利用相依性 Dependency [草稿]","category":"algo","path":"/algo/enumeration-2","date":"2018-12-16","description":null,"link":null,"code":null,"difficulty":null,"oj":null,"tags":null},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"在考慮枚舉所有可行解的同時，若變數與變數之間有高度的相關性，那麼枚舉的順序就會變得相當重要。若我們用了錯誤的順序進行枚舉，很可能會浪費許多時間考慮根本不符合題目規定的解。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"include-problem","properties":{"title-prefix":"例題 1：","path":"/problem/cf/161/E"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"因為 $p_i\\le 99999$ 因此密碼鎖的大小至多只有 $5\\times 5$。再加上對稱的關係，因此彼此不相關的格子只有對角線右上方的這 15 格："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"/f6172dc8bf334e699603ab7606576a42/CF161E.png"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"但是，因為第一排已經固定了 $p_i$，所以剩下下面的 10 格。注意到，如果我們枚舉了標記數字 1 到 6 的地方，則每一排恰好空下一個對角線上的格子，而且彼此不相關。我們只要解決：有多少質數滿足 $\\overline{aXbcd}$ 的形式，其中 $a,b,c,d$ 已知。而這一步可以預處理後 $O(1)$ 查詢。因此利用枚舉法的計算量約在 $10^6$，相當合理。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"// by tmt514\n#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// cnt[第k個位數被丟掉了][其他數字是多少] = 有幾個質數。\nint cnt[5][100000];\n\nvoid pre_compute() {\n  // 先用篩法求質數。\n  vector<int> sieved(99999, 0);\n  for (int i = 2; i*i <= 99999; i++)\n    for (int j = i*i; j <= 99999; j += i)\n      sieved[j] = 1;\n  // 對於找到的每一個質數，我們考慮中間每一個位數被挖空以後，剩下的數字，把他加進去。\n  for (int p = 2; p <= 99999; p++)\n    if (sieved[p] == 0)\n      for (int ten = 1, k = 0; ten <= 10000; ten *= 10, k++)\n        cnt[k][ p/(ten*10)*ten + p%ten ]++;\n}\n\nint ans, n;\nint a[6][6];\nint get_count(int x) {\n  int prefix = 0;\n  for (int i = 0; i < n; i++)\n    if (i != x)\n      prefix = prefix*10 + a[x][i];\n  return cnt[n-1-x][prefix];\n}\nvoid dfs(int x, int y, int total) {\n  if (x == n) {\n    ans += total;\n    return;\n  }\n  if (y == n) {\n    dfs(x+1, 0, total * get_count(x));\n    return;\n  }\n\n  if (x >= y) {\n    a[x][y] = a[y][x];\n    dfs(x, y+1, total);\n  } else {\n    for (int i = 0; i <= 9; i++) {\n      a[x][y] = i;\n      dfs(x, y+1, total);\n    }\n  }\n}\n\nvoid solve() {\n  string s;\n  cin >> s;\n  n = s.size();\n  for (int i = 0; i < n; i++) a[0][i] = (s[i]-'0');\n  ans = 0;\n  dfs(1, 0, 1);\n  cout << ans << endl;\n}\n\nint main() {\n  int T;\n  pre_compute();\n  cin >> T;\n  while (T--) solve();\n  return 0;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"結論"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"先枚舉一部分的數值，並試圖留下一些完全不互相影響的待枚舉部分。如此一來，每一個獨立的部分可以各自用預處理的技巧快速找出答案。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"include-problem","properties":{"title-prefix":"例題 2：","path":"/problem/cf/217/B"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"在第一個例題中，我們試圖降低未枚舉的格子之間的依賴關係。而在第二個例題中，我們試圖找出下一個要枚舉的操作與目前已枚舉部分的關聯，是為增加依賴關係。兩種方法的目的都是為了保證枚舉所花的時間大致與枚舉出的結果總數成正比，減少浪費的時間。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"練習題"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"枚舉法 3：利用單調性 Monotonicity","category":"algo","path":"/algo/enumeration-3","date":"2019-02-05","description":null,"link":null,"code":null,"difficulty":null,"oj":null,"tags":null},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"在一些搜索問題中，我們常常可以利用「判斷這個解是否可行」得到額外的線索，用來排除「其他可能的答案是解」的可能性。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"練習題"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"圖論演算法列舉","category":"notes","path":"/algo/graph-algorithms","date":"2018-02-08","description":null,"link":null,"code":null,"difficulty":null,"oj":null,"tags":null},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"平面圖 Planar Graphs"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"[定義]"}]},{"type":"text","value":" Graph Minor: 刪除點或邊、收縮邊。"},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"a","properties":{"href":"https://en.wikipedia.org/wiki/Graph_minor"},"children":[{"type":"text","value":"https://en.wikipedia.org/wiki/Graph_minor"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"[Kuratowski, Wagner 定理]"}]},{"type":"text","value":" 平面圖若且唯若不含 $K_{3,3}$ 或 $K_5$ 為 homeomorphic subgraph/minor。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"[Boyer-Myrvold 演算法]"}]},{"type":"text","value":" $O(n)$ 平面圖判定。"},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"a","properties":{"href":"http://jgaa.info/accepted/2004/BoyerMyrvold2004.8.3.pdf"},"children":[{"type":"text","value":"John M. Boyer, Wendy J. Myrvold. "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"On the Cutting Edge: Simplified $O(n)$ Planarity by Edge Addition"}]},{"type":"text","value":", 2004."}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"[de Fraysseix, de Mendez and Rosenstiehl 演算法]"}]},{"type":"text","value":" LR-partition $O(n)$ 平面圖判定。"},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"a","properties":{"href":"http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.217.9208&rep=rep1&type=pdf"},"children":[{"type":"text","value":"Ulrik Brandes, "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"The Left-Right Planarity Test"}]},{"type":"text","value":", 2009."}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"完美圖 Perfect Grpahs"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"[資源]"}]},{"type":"text","value":" Algorithmic Graph Theory Part III. Perfect Graph."},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"a","properties":{"href":"http://profs.sci.univr.it/~liptak/MilanicCourse/AGT_Part_3_Perfect_Graphs.pdf"},"children":[{"type":"text","value":"Slides"}]},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"a","properties":{"href":"http://profs.sci.univr.it/~liptak/MilanicCourse/"},"children":[{"type":"text","value":"Martin Milanic \"Algorithmic Graph Theory\" Course"}]}]},{"type":"text","value":"\n"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"Martingales 筆記","category":"algo","path":"/algo/martingales","date":"2019-04-30","description":null,"link":null,"code":null,"difficulty":null,"oj":null,"tags":null},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"note","properties":{},"children":[{"type":"text","value":"\n學習歷程:\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"理解 Martingale (鞅) 的定義"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"理解 Stopping Time 的定義"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"理解 Optional Stopping Theorem"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"應用：Gambling Problem"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"1 定義 (Martingale)"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"A random process $\\{X_n: 0\\le n\\le \\infty\\}$ is a martingale with respect to the information filteration, $\\mathcal{F}_n$, and probability distribution, $P$, if"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"$\\mathbf{E}^P[|X_n|] < \\infty$ for all $n\\ge 0$."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"$\\mathbf{E}^P[X_{n+m} | \\mathcal{F}_n] = X_n$ for all $n, m\\ge 0$."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"其中第一點只是技術性的條件，避免 $X_n$ 期望值不存在的情形。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例 1: Random Walk"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Let $S_n := \\sum_{i=1}^n X_i$ be a random walk where $X_i$'s are IID with mean $\\mu$."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Let $M_n := S_n - n\\mu$. Then $M_n$ is a martingale."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例 2: Martingale Betting Strategy"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"每一回合你可以選擇下注 $X$ 元，每一回合都有 1/2 機率贏或輸。若贏，則可以額外獲得你下注的金額 $X$ 元。若輸，則你會失去 $X$ 元。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"一個 Doubling Strategy 表示：第 $i$ 回合下注 $2^{i-1}$ 元，直到你獲勝為止。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Let $W_n$ denote the total winnings after $n$ coin tosses assuming $W_0=0$. Then $W_n$ is a martingale."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"It suffices to show that $\\mathbf{E}[W_{n+1}|W_n] = W_n$."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"If $W_n=1$, then we stop playing the game. So $\\mathbf{E}[W_{n+1}|W_n=1] = 1$."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"If $W_n=-2^n+1$: then we will bet $2^n$ on the $(n+1)^\\mathrm{th}$ round so\n$\\begin{align*}\n\\mathbf{E}[W_{n+1}|W_n=-2^n+1] &= \\frac{1}{2}\\times 1 + \\frac{1}{2}\\times (-2^{n+1}+1) \\\\\n&= -2^n+1\n\\end{align*}$"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例 3: Random Walk"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"If $Z_n=\\sum_{i=1}^n X_i$ where $\\mathbf{E}[X_i | X_{i-1}, \\ldots, X_1] = 0$ for each $i\\ge 1$, then $\\{Z_n: n\\ge 1\\}$ is a martingale."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例 4: More Random Walk"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Let $X_i = U_iY_i$ where $\\{U_i: i\\ge 1\\}$ are IID, equiprobable $\\pm 1$. The $Y_i$ are independent of the $U_i$. Then $\\{Z_n: n\\ge 1\\}$, where $Z_n = X_1 + \\cdots + X_n$ is a martingale.\n"},{"type":"element","tagName":"a","properties":{"href":"https://youtu.be/TOvSJkC1nRI?t=536"},"children":[{"type":"text","value":"MIT Opencourse Video"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"$Y_i$ 真的沒限制，只要 $U_iY_i$ 期望值是 0 就行了。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例 5: Product Form Martingale"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Let $\\{X_i: i\\ge 1\\}$ be a sequence of IID unit-mean rv's. Then $\\{Z_n: n\\ge 1\\}$, where $Z_n = X_1X_2\\cdots X_n$, is a martingale."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"2 定義 (Stopping Time)"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Let $(\\mathcal{F}_i)$ be a filter. A random variable $\\tau\\in \\{0,1,2,\\ldots, \\}\\cup\\{\\infty\\}$ is a stopping time for the filter $(\\mathcal{F}_i)$ if the event $\\{\\tau=i\\}$ is $\\mathcal{F}_i$-measurable."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這句話的意思大概是說 $\\tau$ 是一個 random variable, 而且決定 $\\tau=i$ 這件事情只由時間 $i$ 以前看到的事實決定。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"theorem","properties":{"title":"Optimal Stopping Time Theorem"},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Let $(X_i)$ be a martingale and $\\tau$ be a stopping time with respect to a filter $(\\mathcal{F}_i)$. Then $\\mathbf{E}[X_\\tau] = \\mathbf{E}[X_0]$\nholds whenever "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"all"}]},{"type":"text","value":" following conditions hold:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"$\\Pr[\\tau < \\infty] = 1$."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"$\\mathbf{E}[|X_\\tau|] < \\infty$."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"$\\mathbf{E}[X_i\\mathbb{I}{\\set{\\tau >i}}] \\to 0$ as $i\\to \\infty$, where $\\mathbb{I}{\\set{\\tau > i}}$ is the indicator of the event $\\set{\\tau >i}$."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Alternatively (and more pratically), the theorem holds if "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"at least"}]},{"type":"text","value":" one of the following holds:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"$T$ is bounded, that is, $\\Pr[\\tau\\le k] = 1$ for some $k\\in\\mathbb{N}$."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"$|X_k|$ is bounded for all $k\\in\\mathbb{N}$."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"$\\mathbf{E}[\\tau] < \\infty$ and $\\mathbf{E}[|X_i-X_{i-1}|\\ |\\ \\mathcal{F}_i] \\le c$ for all $i$ and some constant $c$."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"引理：Stopped Martingale"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Let $\\{X_n: n\\ge 0\\}$ be a Martingale, and $\\tau$ is a stopping time w.r.t. $\\{X_n\\}$. Then the "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"stopped process"}]},{"type":"text","value":" $\\set{\\overline{X}_n: n\\ge 0}$ is a Martingale too, where "}]},{"type":"text","value":"\n$$\n\\begin{align*}\n\\overline{X}_n &= \\begin{cases}\nX_n & \\text{if } \\tau > n,\\\\\nX_{\\tau} & \\text{if } \\tau \\le n.\n\\end{cases} \\\\\n&= X_{n\\land \\tau}\n\\end{align*}\n$$\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"$n\\land \\tau$ is defined to be $\\min(n, \\tau)$."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果我們有 $\\Pr[\\tau < \\infty] = 1$，那麼就會保證 with probability 1,\n$\\lim_{n\\to\\infty} \\overline{X}_n = X_\\tau.$"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"應用"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"醉漢走路問題：公正硬幣"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"theorem","properties":{"c":"is-success"},"children":[{"type":"text","value":"\n每一次丟一枚公正硬幣，移動位置 $+1$ 或 $-1$。\n給定兩個結束位置 $a < 0 < b$，踩到 $a$ (停損) 或 $b$ (獲利) 就停止。\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h4","properties":{},"children":[{"type":"text","value":"目標 1: 計算獲勝機率"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h4","properties":{},"children":[{"type":"text","value":"目標 2: 計算停止期望步數"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Let $Y_i = S_i^2 - i$, then $\\{Y_i\\}$ is martingale."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"不公正的硬幣"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"theorem","properties":{"c":"is-success"},"children":[{"type":"text","value":"\n移動位置 $\\Pr(\\xi_i=+1) = p$, $\\Pr(\\xi_i = -1) = 1-p = q$。\n給定兩個結束位置 $a < 0 < b$，踩到 $a$ (停損) 或 $b$ (獲利) 就停止。\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"定義 $S_n = \\xi_1+\\cdots+\\xi_n$、以及 $\\phi(x) = \\left(\\frac{1-p}{p}\\right)^x$。則 $\\phi(S_n)$ 是一個 martingale。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Doob's 萬用 martingale 構造法"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Let $F$ be any finite random variable, and $\\{X_i\\}$ is a random process. Then $Z_i = \\mathbf{E}[F\\ |\\ X_0, X_1, \\ldots, X_i]$ is a martingale."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"參考資料"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Coursera "},{"type":"element","tagName":"a","properties":{"href":"https://www.coursera.org/lecture/financial-engineering-2/introduction-to-martingales-k18A8"},"children":[{"type":"text","value":"https://www.coursera.org/lecture/financial-engineering-2/introduction-to-martingales-k18A8"}]},{"type":"text","value":" "}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"MIT 6.262 Lecture 24 "},{"type":"element","tagName":"a","properties":{"href":"https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-262-discrete-stochastic-processes-spring-2011/video-lectures/lecture-24-martingales-stopping-and-converging/"},"children":[{"type":"text","value":"https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-262-discrete-stochastic-processes-spring-2011/video-lectures/lecture-24-martingales-stopping-and-converging/"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Berkeley CS271 Lecture 23 "},{"type":"element","tagName":"a","properties":{"href":"https://people.eecs.berkeley.edu/~sinclair/cs271/n23.pdf"},"children":[{"type":"text","value":"https://people.eecs.berkeley.edu/~sinclair/cs271/n23.pdf"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"The Martingale Stopping Theorem "},{"type":"element","tagName":"a","properties":{"href":"https://www.math.dartmouth.edu/~pw/math100w13/lalonde.pdf"},"children":[{"type":"text","value":"https://www.math.dartmouth.edu/~pw/math100w13/lalonde.pdf"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"ASU APM504: Lecture 28 "},{"type":"element","tagName":"a","properties":{"href":"https://math.la.asu.edu/~jtaylor/teaching/Spring2011/APM504/lectures/lecture28/lecture28.pdf"},"children":[{"type":"text","value":"https://math.la.asu.edu/~jtaylor/teaching/Spring2011/APM504/lectures/lecture28/lecture28.pdf"}]},{"type":"text","value":" "}]},{"type":"text","value":"\n"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"演算法中的四種解題思維","category":"algo","path":"/algo/algorithmic-thinking","date":"2018-11-27","description":null,"link":null,"code":null,"difficulty":null,"oj":null,"tags":null},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%80%9D%E7%BB%B4"},"children":[{"type":"text","value":"運算思維"}]},{"type":"text","value":"（Computational Thinking）在近年來逐漸被關注資訊教育的人們提出來討論。而運算思維包含了"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"問題解構"}]},{"type":"text","value":"（Decomposition）、"},{"type":"element","tagName":"a","properties":{"href":"http://terms.naer.edu.tw/detail/1603992/"},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"型樣辨識"}]}]},{"type":"text","value":"（Pattern Recognition）、"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"模型抽象化"}]},{"type":"text","value":"（Abstraction）以及"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"演算法設計"}]},{"type":"text","value":"（Algorithm Design）。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"對我來說，演算法設計的世界裡面，解題的過程也可以大致分類成以下四種思考方式。而這些思考方式構建了大家在演算法教科書中提及的各種解題方法（又稱為 "},{"type":"element","tagName":"a","properties":{"href":"https://en.wikipedia.org/wiki/Algorithmic_paradigm"},"children":[{"type":"text","value":"Algorithmic Paradigm"}]},{"type":"text","value":"），比方說動態規劃或是分而治之等。大致可以表示成以下的圖片："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{"className":["has-text-centered"]},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"img","properties":{"src":"/3a46181cc32653fb172ffd3d39e23591/algthinking.png","style":"max-width:700px"},"children":[]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"枚舉 Enumeration"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"程式解題與數學解題其中一個不同之處，在於我們擁有運算資源，可以把複雜的、難以公式化的數學結論，用跑程式的方式輕鬆驗證。枚舉（Enumeration）就是其中一種很「資訊科學」的解題方式：如果我能夠證明我的答案在某個特定的範圍中，那麼我只要逐一考慮過所有可能的答案即可。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"簡而言之，若一道題目滿足以下兩個性質："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"若給定一個解 X，我們可以有效率地檢驗 X 是否正確。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"把可能的解所在的範圍，縮小到足以負擔的數量級。\n那麼通常我們可以寫出好寫又有效率的程式。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"迭代 Iteration"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"迭代法，通常是用於我們可以逐漸找出答案的演算法。最常見的應用是漸進演算法、數值方法、人工智慧等。在競賽之中，我們也可以利用迭代的概念，有效率地得出我們想要的解。最直白的應用就是 for 迴圈。對，還有 while 迴圈。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"遞推 Induction"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"在驗證程式邏輯的正確性的時候，我們很常會使用數學歸納法：「如果小測資是對的，那麼根據我們解題的思路，也可以推得大測資是對的。」P老師也曾經說過：「歸納」、「遞迴」跟「分而治之」其實是一體三面，對於有效率地寫程式解決問題是相當重要的。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"轉化 Reduction"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"轉化跟歸納其實是兩個不同的方向：如果說歸納是以建構的方式，由小範圍的測資組合出大範圍測資的答案，那麼轉化有點像是平行地把一個問題轉變成另一個已知解法問題。轉化在解題思維中無所不在，畢竟大家在面對一道新的題目時，總是會習慣搜尋自己曾經解決過的類似題目、並且利用以前的經驗，把思路稍作修改從而獲得真正的解法。"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"最小費用流 Min-Cost Max-Flow","category":"algo","path":"/algo/min-cost-max-flow","date":"2018-11-16","description":null,"link":null,"code":null,"difficulty":null,"oj":null,"tags":null},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這篇文章是線性規劃章節的延伸，但目前還沒有寫線性規劃相關文章。還請大家先行理解"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"線性規劃"}]},{"type":"text","value":"與"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"對偶性質"}]},{"type":"text","value":"XD"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"最小費用流 Min-Cost Max-Flow"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{"className":["message","is-info"]},"children":[{"type":"element","tagName":"div","properties":{"className":["message-body"]},"children":[{"type":"text","value":"\n給定一個圖 $G=(V, E, cap: E\\to \\mathbb{R}_{\\ge 0}, cost: E\\to \\mathbb{R})$，每一條邊都有一個流量上限 $cap$ 和單位流量花費 $cost$。試問，從 $s$ 到 $t$ 的所有最大流之中，最小的花費為何？\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這個問題由於有 $s$ 和 $t$ 兩個特殊點，實際處理起來可能稍微麻煩些，所以我們先把它轉化成最小費用循環問題（Min-Cost Circulation）。轉化方法很簡單，其實只是加一條額外的邊 $t\\to s$，容量為無窮大、單位流費用為一個負很大的數字 $-\\mathit{big}$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"最小費用循環 Min-Cost Circulation"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{"className":["message","is-info"]},"children":[{"type":"element","tagName":"div","properties":{"className":["message-body"]},"children":[{"type":"text","value":"\n給定一個圖 $G=(V, E, cap: E\\to \\mathbb{R}_{\\ge 0}, cost: E\\to \\mathbb{R})$，每一條邊都有一個流量上限 $cap$ 和單位流量花費 $cost$。找一個 Circulation（沒有起點和終點的網路流） 使得總花費最小。\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果所有的花費都是正的，顯然一個空的流（總花費是 0）是最佳解。如果我們把這個問題的條件寫成線性規劃的形式，令 $f(u, v)$ 表示該條邊上面的流量，那麼它會長得像這樣："}]},{"type":"text","value":"\n$$\n\\begin{align*}\n\\text{minimize}\\ \\ & \\sum f(u, v) \\cdot cost(u, v)\\\\\n\\text{subject to}\\ \\ & {\\color{green}{\\forall (u, v),\\ \\ f(u, v) \\le cap(u, v)}} & {\\color{green}{\\text{ (容量限制)}}}\\\\\n& {\\color{brown}{\\forall v\\in V, \\ \\ \\sum_u f(u, v) - \\sum_u f(v, u) = 0}} & {\\color{brown}{\\text{ (流量守恆)}}}\\\\\n\\text{variables}\\ \\ & f(u, v) \\ge 0\n\\end{align*}\\\\\n$$\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果我們試圖找出他的對偶問題，那麼每一個條件會變成對偶問題的變數、而每一個變數也會對應到對偶問題的一個條件：對於每一個容量限制，我們用 $y(u, v)$ 作為容量限制條件的對應變數、令 $d(v)$ 作為流量守恆條件的對應變數。"}]},{"type":"text","value":"\n$$\n\\begin{align*}\n\\text{maximize}\\ \\ & \\sum {\\color{green}{y(u, v)}} \\cdot cap(u, v)\\\\\n\\text{subject to}\\ \\ & \\forall (u, v), \\ \\ {\\color{green}{y(u, v)}} - {\\color{brown}{d(u)}} + {\\color{brown}{d(v)}} \\le cost(u, v)\\\\\n\\text{variables}\\ \\ & {\\color{green}{y(u, v)}} \\le 0\n\\end{align*}\\\\\n$$\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"由於 ${\\color{green}{y(u, v)}}$ 值永遠非正的，而每一個值又只會出現在恰好一個對偶條件裡面，外加上 $cap(u, v) \\ge 0$。我們可以知道，當 ${\\color{brown}{d(v)}}$ 的所有值固定以後，永遠可以找到一組 ${\\color{green}{y(u, v)}}$ 滿足對偶條件：只要令"}]},{"type":"text","value":"\n$$\n{\\color{green}{y(u, v)}} = \\min\\{0, {\\color{brown}{d(u)}} + cost(u, v) - {\\color{brown}{d(v)}}\\}\n$$\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"就可以了。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"正確地寫下最小費用循環的線性規劃模型以後，我們就可以利用線性規劃的最佳解性質，幫助我們判斷找到的網路流是不是最佳解。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"最佳解的性質"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"線性規劃的對偶觀念中，最重要的三件事情「弱對偶性」、「強對偶性」以及「"},{"type":"element","tagName":"a","properties":{"href":"http://terms.naer.edu.tw/detail/559045/"},"children":[{"type":"text","value":"互補差餘"}]},{"type":"text","value":"」（這詞﹍）。假設我們今天已經找到了圖 $G$ 上面的網路流 $f$，我們要怎麼檢驗或確認這個 $f$ 是最佳解呢？"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{"className":["message","is-warning"]},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{"className":["message-header"]},"children":[{"type":"text","value":"\n弱對偶性（Weak Duality）\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{"className":["message-body"]},"children":[{"type":"text","value":"\n若 $f$ 是最小費用流線性規劃的一個可行解，且 $y, d$ 是滿足對偶條件的對偶問題可行解。那麼必定有\n$$\n\\sum f(u, v)\\cdot cost(u, v) \\ge \\sum y(u, v)\\cdot cap(u, v)。\n$$\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"弱對偶性（Weak Duality）告訴我們，如果存在一組對偶可行解 $y(u, v)$、$d(v)$ 滿足 $\\sum f(u, v)\\cdot cost(u, v) = \\sum y(u, v)\\cdot cap(u, v)$，那麼 $f, y, d$ 同時都是最佳解。如果我們的演算法可以正確地輸出 $f, y, d$，那麼從這個輸出就可以得知正確性。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"最小費用流的演算法"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"基於以上論述，綜觀歷來的最小費用流解法們，可以大致分成兩個門派："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"消圈演算法（Cycle-Cancellation Algorithms）"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"主要的概念是在每一次迭代的過程中，永遠保證 $f$ 是一個可行解（feasible solution，也就是一個合法的網路流），在對偶空間中試圖搜尋滿足條件的 $d$ 值。如果找不到滿足條件的 $d$ 值，代表剩餘網路 $G_f$ 上不存在距離函數（有負圈！），也因為有負圈，我們可以在這個負圈上推一個流，讓其中一條邊流滿。這個動作可以讓負圈消失、也因為找到這個負圈，推流後可以讓整體費用下降。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"最短路徑增廣法（Successive-Shortest-Path Algorithms）"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"主要的概念是在每一次迭代的過程中，永遠保證 $d$ 是一組滿足對偶條件的距離函數，並且我們維護一個假想流 $f$（pseudo flow：只滿足"},{"type":"element","tagName":"span","properties":{"style":"color:green"},"children":[{"type":"text","value":"容量限制"}]},{"type":"text","value":"但可能無法"},{"type":"element","tagName":"span","properties":{"style":"color:brown"},"children":[{"type":"text","value":"流量守恆"}]},{"type":"text","value":"）。然後試圖更新這個假想流，一旦更新後滿足了流量守恆，我們就得到解了（因為隨時保證 $d$ 以及從 $d$ 推導出的 $y$ 永遠是合法的對偶問題可行解）。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我們會在未來的文章介紹這兩種演算法的細節與簡單版的實作。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"習題"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"我們用加了一條邊（$cap=\\infty, cost=-big$）的方法把「Min-Cost Max-Flow」轉化成「Min-Cost Circulation」。如果我們今天不要求「最大流」，只要找一個流，讓總花費最小，應該要如何進行轉化呢？"}]},{"type":"text","value":"\n"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"List of Time Complexities","category":"notes","path":"/algo/list-of-time-complexities","date":"2021-01-25","description":null,"link":null,"code":null,"difficulty":null,"oj":null,"tags":null},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Here is a collection of interesting time complexity that I have encountered in my life."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"$O(\\frac{1}{4n\\sqrt{3}}\\exp(\\pi (2/3)^{1/2} \\sqrt{n}))$"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"The growth rate of a partition number."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"$T(n) = 2T(n/2) + n/\\log n$"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"$O(n\\log\\log n)$"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Mergesort integers with packing $\\log n\\log\\log n$ integers in each word."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"最小費用流的最短路徑增廣法 [草稿]","category":"algo","path":"/algo/min-cost-max-flow-successive-shortest-path","date":"2018-11-22","description":null,"link":null,"code":null,"difficulty":null,"oj":null,"tags":null},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"讓我們首先"},{"type":"element","tagName":"a","properties":{"href":"/algo/min-cost-max-flow"},"children":[{"type":"text","value":"回顧"}]},{"type":"text","value":"一下最小費用循環的線性規劃主模型（Primal Problem）、以及其對偶模型（Dual Problem）。令 $f(u, v)$ 為線性規劃模型的變數、$y(u, v)$ 以及 $d(v)$ 為其對偶模型的變數名。我們定義以下三種條件："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"P 條件：$f$ 滿足線性規劃模型的條件，即 $f$ 是一個合法的網路流。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"D 條件：$y, d$ 滿足對偶模型的條件，即 $y(u, v)-d(u)+d(v) \\le cost(u, v)$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"CS 條件：$f, y, d$ 滿足"},{"type":"element","tagName":"a","properties":{"href":"http://terms.naer.edu.tw/detail/559045/"},"children":[{"type":"text","value":"互補差餘"}]},{"type":"text","value":"條件，即"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n$$\n\\begin{cases}\nf(u, v) > 0 & \\implies y(u, v) = d(u) + cost(u, v) - d(v)\\\\\nf(u, v) < cap(u, v) & \\implies y(u, v) = 0\n\\end{cases}\n$$\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"由線性規劃的各種性質我們可以知道，只要 $f, y, d$ 這三組變數同時滿足 P條件、D條件以及 CS條件的話，保證 $f, y, d$ 分別是主模型和對偶模型的最佳解。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"theorem","properties":{"title":"最小費用流的最佳條件定理"},"children":[{"type":"text","value":"設 $f$ 是一個圖 $G$ 上面的網路流。若存在剩餘網路 $G_f$ 上面的距離函數 $d^*$ （即，滿足 $\\forall (u, v)\\in G_f, \\ d^*(u) + cost(u, v) \\ge d^*(v)$），那麼 $f$ 是主模型的最佳解。\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"證明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我們只需要證明「存在滿足條件的 $d^*$ 函數」等價於「存在滿足 D 條件和 CS 條件的 $y, d$」即可。"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"二分搜尋法的實作基礎","category":"algo","path":"/algo/binary-search","date":"2018-11-13","description":null,"link":null,"code":null,"difficulty":null,"oj":null,"tags":null},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"前幾天有位朋友跟我反應，二分搜尋法好難寫啊。有的時候寫下去，甚至無法確定這樣寫會不會對，只能祈禱線上提交的時候會順利拿到 "},{"type":"element","tagName":"span","properties":{"style":"color:green"},"children":[{"type":"element","tagName":"b","properties":{},"children":[{"type":"text","value":"Accepted"}]}]},{"type":"text","value":"。這樣的想法是很危險的！你不應該仰賴評測系統給你的反饋，才能知道自己是不是對的。至少在上傳之前，思考一下正確性，讓自己更安心。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"先說結論"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"在繼續介紹各種二分搜的方法與證明之前，我想要先下個結論：每個人都應該要有一套屬於自己的二分搜尋法。而且 "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"只用"}]},{"type":"text","value":" 這套屬於自己的二分搜尋法。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"二分搜的概念"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"假想你有一個只有 0 和 1 兩種數字的陣列，然後所有的 0 都排在 1 的前面。 "}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"display","properties":{"array":"","fixedwidth":"","data":"[0, 0, 0, 0, 1, 1, 1, 1, 1, 1]"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"要如何找出第一個 1 的位置呢？想法很單純，我們戳一個中間的格子，如果這個格子是 0，代表「所有這個格子之前（包含這個格子）都不是答案」。如果這個格子是 1，則代表「所有這個格子之後（"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"不"}]},{"type":"text","value":"包含這個格子）也不是答案」。於是我們得到一個演算法："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"1. 戳一個中間的格子 X\n2. 如果 X = 1，那麼把這個格子右邊的所有格子丟掉\n3. 如果 X = 0，那麼把這個格子本身與其左邊所有格子丟掉\n4. 重複以上操作\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這個演算法什麼時候會停？它不會停，因為從上面的演算法描述，我們並沒有叫他停下來。那什麼時候應該要停下來？顯然每一次操作的過程中，左邊丟掉的格子們都是 0、右邊丟掉的格子們都是 1。我們可以把這個觀察寫成重要的"},{"type":"element","tagName":"a","properties":{"href":"https://en.wikipedia.org/wiki/Loop_invariant"},"children":[{"type":"text","value":"迴圈不變量"}]},{"type":"text","value":"。在迴圈結束後，如果只剩下一個格子，而這個格子是 1，那麼根據演算法來說我們永遠不會把這個格子丟掉。而根據迴圈不變量，我們就保證了這格就是我們要的第一個 1。反之，如果這個格子裡面的數字是 0，那麼根據演算法，下一步這格就會被丟掉，而我們也可以推斷出「這陣列不存在 1」。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"二分搜的實作"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"但是實際寫成程式碼就很怪了啊。到底我們要怎麼表示目前的邊界（或是紀錄被丟掉的格子）呢？因為剩餘的格子們是連續的一段，我們可以利用兩個變數 $\\ell$ 和 $r$ 來表示這個區間 $[\\ell, r]$。有些人喜歡半開半閉區間 $[\\ell, r)$，也就是說當我們存入兩個變數 $\\ell$ 和 $r$ 的時候，實際有效的陣列範圍是 $[\\ell, r-1]$。那樣寫沒什麼壞處，而且也巧妙地利用了當 $l+r$ 是奇數時 $(l+r)/2$ 向下取整的特性，讓中間值 $m$ 可以留在 $[\\ell, r-1]$ 這個區間裡面。不過我自己的習慣是使用閉區間。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"我自己的習慣"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我的寫法是閉區間的寫法，而且總是維護當前找到的"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"答案候選"}]},{"type":"text","value":"。引入一個變數 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"ans"}]},{"type":"text","value":"，一開始把它標記為「不存在」，如果我找到一個滿足條件的格子（比方說，這個格子必須是 1）那麼在找到的當下，我會更新 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"ans"}]},{"type":"text","value":" 的值。讓變數 $\\ell, r$ 永遠只用來表達邊界，不要賦予他們過多的意義。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"int lower_bound(int array[], auto predicate_fn) {\n    int l, r, ans = -1;\n    while(l <= r) {\n        int m = (l + r) / 2;\n        if (predicate_fn(array[m]) == true) {\n            // 如果滿足條件，就把右邊丟掉，並且把當前資料加入可能的答案裡。\n            ans = m;\n            r = m - 1;\n        } else {\n            // 如果不滿足條件，就把左邊丟掉。\n            l = m + 1;\n        }\n    }\n    return ans;\n}\n"}]}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"強指數時間假說 Strong Exponential Time Hypothesis","category":"algo complexity","path":"/algo/strong-exponential-time-hypothesis","date":"2018-12-04","description":null,"link":null,"code":null,"difficulty":null,"oj":null,"tags":null},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"關於 P vs NP 這個計算機學界最重要的問題之一，至今仍是懸而未解。1990年代，大量 NP-Complete 的證明興起，也讓研究計算理論領域的人們對於 NP-完備的概念有著比較深刻的理解。對於一個問題，究竟是多項式時間可解、或是它比任何一個 NP-Complete 的問題還要難，往往也有跡可循。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"許多演算法的分支：近似演算法（Approximation Algorithms）、指數時間演算法（Exponential Time Algorithms）等，利用搜索與剪枝、貪婪法、模擬退火等各種技巧，無所不用其極，都是因應傳統演算法所需要耗費的時間或空間嚴重不足而產生的。而 NP-Complete 是一個很好的 \"hint\"：在這個大多數的人們相信著 P $\\neq$ NP 的世界裡，要找出又快又最好的解往往是不可能的事情。一旦我們能夠證明一個問題是 NP-Hard 的，那麼在現實生活中，如果要有效率的解決這個問題，恐怕只能仰賴搜索或近似解了。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"$k$-CNF-SAT"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"先跟大家介紹一個 NP-Complete 當中的指標性問題："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"theorem","properties":{"title":"$k$-CNF-SAT 問題","c":"is-info"},"children":[{"type":"text","value":"\n**輸入**：給定 $n$ 個變數 $x_1, x_2, \\ldots, x_n$ 以及一個 k-CNF $\\Phi$。其中 $\\Phi = C_1\\land C_2\\land \\cdots \\land C_m$，$m=O(n)$。每一個 clause 可以被許多 literals 描述 $C_i = (\\ell_{i1}\\lor \\ell_{i2}\\lor \\cdots \\lor \\ell_{ik})$，其中每一個 literal 就是任何一個變數 $x$ 或其 negation $\\lnot x$。\n  \n**問題**：是否存在一個合法的賦值方式，使得 $\\Phi$ 為真？\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"目前世界上最快的精確演算法（Exact Algorithm），在最壞情形下得跑 $2^{(1-o(1/k))n}$ 時間。也就是說，當 $k$ 真的超大的時候，這些演算法在最壞情形下都得花到扎扎實實 $2^n$ 的時間。於是乎，大家逐漸提出了以下的想法："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"theorem","properties":{"title":"強指數時間假說 Strong Exponential Time Hypothesis (SETH)"},"children":[{"type":"text","value":"\n對於任意的常數 $\\epsilon > 0$，任何精確演算法皆無法在 $2^{(1-\\epsilon)n}$ 時間內同時對任意 $k$ 解決 $k$-CNF-SAT 問題。\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這個想法看起來很直覺，但是目前也還沒有人能夠真的證明或否定它。有趣的事情是，這個假說提供了厲害的基礎，如果這個假說是對的，那麼有很多演算法就會變成了「理論上最優」的演算法了！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"證明 NP-完備性的一貫方法"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果要證明一個題目 $X$ 是 NP-完備（NP-Complete）的，那麼我們需要從一個 NP-完備問題 $Y$ 出發，然後試圖將它的輸入在多項式時間內轉化成 $X$。然後斷定結論說「如果我們能在多項式時間內解決 $X$，那麼我們就可以在多項式時間內解決 $Y$。但是因為 $Y$ 是 NP-完備的，可以在多項式時間內解決 $Y$ 就代表可以在多項式時間內解決所有 NP 裡面的問題，於是 NP $=$ P。」"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"P 的細分"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"很久很久以前大家就知道洋蔥定理 "},{"type":"element","tagName":"a","properties":{"href":"https://en.wikipedia.org/wiki/Time_hierarchy_theorem"},"children":[{"type":"text","value":"Time Hierarchy Theorem"}]},{"type":"text","value":" 了（我一直很喜歡隨機客老師稱呼這個定理的說法）。簡而言之，洋蔥定理描述的事情是：在所有 P 裡面的問題，不存在常數 $c$ 使得所有的問題都能在 $n^c$ 的時間被解掉。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"但這些定理所描述的一些 hardness problems 或反例與現實世界中的問題相距甚遠。2005 年由 Ryan Williams 提出了以下的「正交向量問題」，建立了指數時間演算法與多項式時間演算法之間的關聯。有趣的是，這個正交向量問題能夠轉化(reduce)成更多大家熟知的題目，包含最長共同部分子序列(LCS)等問題。也就是說，這一連串的轉化得到以下結論：如果存在更有效率的某某多項式演算法，就能夠推翻強指數時間假說。"}]},{"type":"text","value":"\n"},{"type":"comment","value":"\n2001 年的 Impagliazzo, Paturi & Zane 提出了重要的引理。然後在 \n"},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我們先來看看正交向量問題吧："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"theorem","properties":{"title":"正交向量問題 Orthogonal Vector Problem (OV)","c":"is-info"},"children":[{"type":"text","value":"\n**輸入**: 給定 $d$ 維布林空間中的兩個向量集合 $A, B\\subset \\{0, 1\\}^d$，而集合大小 $|A|=|B|=N$。我們不妨假設 $d=\\Theta(\\log N)$。\n  \n**問題**: 是否存在 $a\\in A, b\\in B$ 使得 $\\langle a, b\\rangle = 0$？\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"看起來樸實無華的問題，如果要跟時下最夯的 Document Similarity 扯上邊好像也是可以齁（我就不多言了。）重點是，我們可以把 CNF-SAT 問題轉化成 Orthogonal Vector 問題，進而得到以下定理："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"theorem","properties":{"title":"定理：$\\textsf{CNF-SAT}\\le_p \\textsf{OV}$"},"children":[{"type":"text","value":"\n若存在一個常數 $\\epsilon>0$ 以及一個演算法能在 $N^{2-\\epsilon}$ 時間內解決正交向量問題，那麼就存在一個常數 $\\epsilon' > 0$，以及一個演算法能在 $2^{(1-\\epsilon')n}$ 時間內解出 CNF-SAT 問題。\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"證明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"不妨假設在 CNF-SAT 問題裡面的 $n$ 是偶數。我們把變數分成兩群：\n$S_1=\\set{x_1, x_2, \\ldots, x_{n/2}}$ 以及 $S_2 = \\set{x_{n/2+1}, \\ldots, x_{n-1}, x_n}$。枚舉這兩群變數所有可能的賦值情形，分別有 $2^{n/2}$ 種。（這個概念有點像是拆兩半的枚舉。）"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"讓我們來考慮 $S_1$：對於第 $i$ 種賦值情形，我們可以拿它來對照所有的 $m$ 個 clause，然後用這個資訊構造出一個長度為 $m$ 的 0-1 字串 $a_1a_2\\cdots a_m\\in\\set{0,1}^m$：考慮第 $j$ 個子句 $C_j$，如果目前對於 $x_1, \\ldots, x_{n/2}$ 的賦值能保證 $C_j$ 為真，我們就令 $a_j=0$，否則令 $a_j=1$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"同理而言，我們也能夠針對後半段 $S_2$ 所有可能的變數賦值，構造出集合 $B$：若 $C_j$ 能被後半段的賦值給滿足，那麼就讓 $b_j=0$，否則令 $b_j=1$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"行文至此，我們可以想像一下，如果我們拿構造出來的 $a_1a_2\\cdots a_m$ 與 $b_1b_2\\cdots b_m$ 計算其內積，得到的值代表什麼意思？如果內積的值為 $0$，則代表對於所有 $j$，要嘛 $a_j=0$ 要嘛 $b_j=0$，這代表我們找出來的 $S_1$ 賦值與 $S_2$ 賦值剛好可以滿足所有的子句！也就是說存在一個 $\\Phi=\\mathsf{true}$ 的一個解，若且唯若存在一組 $a\\in A, b\\in B$ 使得 $\\langle a, b\\rangle = 0$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"現在讓我們來檢視集合大小，也就是 $n, m, N, d$ 之間的關係。集合 $A$ 與 $B$ 分別對應到 $S_1$ 與 $S_2$ 的賦值方式，所以 $N=|A|=|B|=2^{n/2}$。每一個構造出來的字串長度為 $m=O(n)$，因此 $d=m=n=\\Theta(\\log N)$ 滿足題目要求。所以囉，如果有一個 $N^{2-\\epsilon}$ 時間複雜度的方法可以解 OV，那麼就有一個 $\\left(2^{n/2}\\right)^{2-\\epsilon} = 2^{(1-\\epsilon/2)n}$ 時間複雜度的方法可以解 CNF-SAT 問題，與強指數時間假說(SETH)矛盾。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"參考資料"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://en.wikipedia.org/wiki/Exponential_time_hypothesis"},"children":[{"type":"text","value":"維基百科: Exponential Time Hypothesis"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://people.csail.mit.edu/rrw/2-csp-final.pdf"},"children":[{"type":"text","value":"Ryan Williams, A new algorithm for optimal constraint satisfaction and its implications, 2005."}]}]},{"type":"text","value":"\n"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"二分搜尋法的應用 1：答案仍在範圍裡","category":"algo","path":"/algo/binary-search-applications","date":"2018-11-14","description":null,"link":null,"code":null,"difficulty":null,"oj":null,"tags":null},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"前一篇文章 "},{"type":"element","tagName":"a","properties":{"href":"/algo/binary-search"},"children":[{"type":"text","value":"二分搜尋法的實作基礎"}]},{"type":"text","value":" 提及了關於二分搜的核心概念：每一次迭代都排除了一些不可能是答案的值。我們今天來看看二分搜尋法有哪些應用吧！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"勘根定理"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"對於一個連續函數 $f$，如果這個函數在 $[a, b]\\subseteq \\mathbb{R}$ 區間內有定義，而且 $f(a) < 0$、$f(b) > 0$，那麼"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"勘根定理"}]},{"type":"text","value":"告訴我們說，中間必定存在一個 $x\\in [a, b]$ 使得 $f(x)=0$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"上面這個定理只告訴我們存在"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"至少"}]},{"type":"text","value":"一個根，但其實它的證明就是利用二分搜尋法的概念！而且是反方向的概念："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"article","properties":{"className":["message","is-success"]},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{"className":["message-body"]},"children":[{"type":"text","value":"\n每一次迭代都保證了答案仍在剩下的值裡面。\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"考慮無窮序列 $\\{a_i\\}$ 以及 $\\{b_i\\}$。他們的定義如下：$a_0=a$ 且 $b_0=b$。接著我們依序定義，對所有正整數 $i$，令 $m_i = (a_{i-1}+b_{i-1})/2$，若 $f(m_i) = 0$，則我們找到了 $x=m_i$。否則的話，我們根據 $f(m_i)$ 之值定義新的一組 $(a_i, b_i)$："}]},{"type":"text","value":"\n$$\n(a_i, b_i) = \\begin{cases}\n(a_{i-1}, m_i) &\\text{ if } f(m_i) > 0,\\\\\n(m_i, b_{i-1}) &\\text{ if } f(m_i) < 0.\n\\end{cases}\n$$\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"二分在哪裡呢？我們可以發現每一次迭代，區間 $[a_i, b_i]$ 長度是前一次迭代的 $[a_{i-1}, b_{i-1}]$ 的一半！由於 $\\{a_i\\}$ 是遞增有上界、$\\{b_i\\}$ 遞減有下界、他們彼此之間距離又會趨近於 $0$，因此最終 $\\lim_{i\\to\\infty} a_i = x^* = \\lim_{i\\to\\infty} b_i$。由"},{"type":"element","tagName":"a","properties":{"href":"https://zh.wikipedia.org/wiki/%E5%A4%BE%E6%93%A0%E5%AE%9A%E7%90%86"},"children":[{"type":"text","value":"夾擠定理"}]},{"type":"text","value":"可得知 $f(x^*)=0$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"找出陣列中的極小點"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"給定一個陣列 $A[0..n-1]$，這個陣列的所有數字都不相同。假設這個陣列最左邊和最右邊的邊界都是無窮大，也就是 $A[-1]=A[n]=\\infty$。請找出任何一個"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"極小點"}]},{"type":"text","value":"的索引 $i$：滿足 $A[i-1] > A[i] < A[i+1]$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"找出任一個括弧組"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"給定一個僅包含小括弧 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"("}]},{"type":"text","value":" 或 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":")"}]},{"type":"text","value":" 的字串 $S$，已知字串左界是個左括弧 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"("}]},{"type":"text","value":"、右界是個右括弧 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":")"}]},{"type":"text","value":"。請設計一個演算法有效率地找出一個連續的一對括弧 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"()"}]},{"type":"text","value":" 子字串。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"參考資料"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"http://kc.kshs.kh.edu.tw/93kc/projectual/math9103/chp4-5/4-5-8.htm"},"children":[{"type":"text","value":"勘根定理 The location of roots theorem"}]}]},{"type":"text","value":"\n"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"最小費用流的消圈演算法","category":"algo","path":"/algo/min-cost-max-flow-cycle-cancellation","date":"2018-11-20","description":null,"link":null,"code":null,"difficulty":null,"oj":null,"tags":null},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"剩餘網路 Residual Networks"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"要討論網路流，就必須要討論剩餘網路（residual networks）。如果我們在圖 $G$ 上面有一個流 $f$，那我們可以定義一個剩餘網路 $G_f$，代表有哪些地方還有空間推進更多的網路流。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"最小費用流在剩餘網路上會長什麼樣子呢？很幸運地，Klein 在 1967 年為我們證明了以下定理："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"theorem","properties":{"title":"負圈定理"},"children":[{"type":"text","value":"\n$f$ 是最佳解若且唯若 $G_f$ 上面定義 cost 為權重時，不存在一個負圈。\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"證明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"\"$\\Rightarrow$\":"},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"\n如果 $G_f$ 上面存在一個負圈，那麼沿著這個負圈增廣，會得到總花費更小的解，與 $f$ 最佳解的假設矛盾。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"\"$\\Leftarrow$\":"},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"\n如果 $f$ 不是最佳解，那我們考慮真正的最佳解 $f^\\star$。考慮兩個解的差異 $f'=f^\\star - f$，不難推敲得知 $f'$ 的所有邊都會出現在 $G_f$ 上面。由於 $f'$ 是一個可行流，我們可以將 $f'$ 拆成許多圈的疊加。但是因為 $cost(f')$ 帶來的總花費是負的（因為 $cost(f') = cost(f^\\star) - cost(f) < 0$），所以至少有一個圈帶來的花費也是負的。得證。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"消圈演算法 Cycle Cancellation Algorithms"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這個演算法是由 Klein [1967] 從 Ford-Fulkerson 網路流演算法得來的想法，以迭代的方式不斷地更新當前找到的解，直到滿足最佳解條件為止。"},{"type":"element","tagName":"sup","properties":{"id":"fnref-2"},"children":[{"type":"element","tagName":"a","properties":{"href":"#fn-2","className":["footnote-ref"]},"children":[{"type":"text","value":"2"}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"f = 空的網路流\nwhile 剩餘網路 G_f 上面存在負圈:\n    令 C 為任何一個負圈\n    令 Δ 為這個負圈上能推的最大流量\n    更新 f = f + CΔ\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"時間複雜度"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如同 Ford-Fulkerson 演算法一般，在所有 cost 和 capacity 都是整數的時候，每一次消圈，只能夠保證總花費至少降低了 1 單位。顯然最小的總花費值比 $-mCU$ 來得大，所以我們可以得知迭代消圈的次數至多為 $O(mCU)$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"而找負圈的演算法則可以使用 Bellman-Ford 演算法，所需時間為 $O(nm)$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"因此整體的時間複雜度是 $O(nm^2CU)$，由於 $C$ 和 $U$ 僅是數值，相對於輸入規模而言是指數級別的，在數值較大時效率不甚理想。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"更快的消圈算法"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"從計算最大網路流的演算法當中，當我們每次找出剩餘網路圖上最寬的增廣路徑時，這條增廣路徑至少可以推進 ${\\mathbf{MaxFlow}}(G_f)/m$ 的流量。這麼一來，在所有容量限制都是整數的情況下，增廣的次數上界可以從原本 Ford-Fulkerson 演算法的 ${\\mathbf{MaxFlow}}(G)$ 降低至 $O(m\\log_2 {\\mathbf{MaxFlow}}(G))$。這個值以輸入的資料量而言，就是多項式了。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"最負圈 Most Negative Cycle"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"消圈算法是否也有同樣的特性呢？答案是有的，我們可以用一模一樣的方式證明，如果每一次我們找出那個「最負的負圈」，那麼總 cost 會向目標邁進至少 $O(1/m)$ 的比例。採用了這個方法的話，我們就可以讓消圈次數限制在 $O(m\\log_2|{\\mathbf{MinCost}}(G)|)$，是為多項式。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"但是，找出「最負的負圈」對於輸入是任意圖的情形下，是 NP-Hard 的。目前我們仍不知道有沒有有效率的多項式演算法來找出它。於是 Goldberg 跟 Tarjan 於 1989 年發現，每一次不見得要找「最負的負圈」，只要「足夠負」就可以有一樣的效果！他們利用了 Karp 在 1978 年提出的「最小均值圈」演算法，每一次找出「平均花費最負的圈」進行增廣，就可以達到一樣的效果啦。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"最小均值圈"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"theorem","properties":{"title":"最小均值圈 [Karp 1978]"},"children":[{"type":"text","value":"\n設 $G$ 為有向有權圖。定義 $\\hat{G}$ 為 $G$ 外加上一點 $s$ 並從 $s$ 到每一點分別加上一條權重為 0 的邊。令 $d_k(v)$ 為從 $s$ 出發經過恰好 $k$ 條邊抵達點 $v$ 的最小總權重和。則最小均值圈的平均值 $\\lambda^*$ 滿足\n$$\n\\lambda^* = \\min_v \\max_{1\\le k \\le n-1} \\frac{d_n(v) - d_k(v)}{n-k}\n$$\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Karp 的證明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"首先我們先證明，如果 $\\lambda^*=0$，那麼上面這個式子右半邊的值恰好會是 $0$："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果 $\\lambda^*=0$，那麼這個圖一定不存在負圈。既然不存在負圈，我們就可以定義最短路徑（可以參考 Edmonds-Karp）。定義 $\\mathrm{dist}(s, v)$ 為 $s$ 到 $v$ 的最短路徑長度。顯然對於所有點 $v$ 和正整數 $k$，$d_n(v) \\ge d_k(v)$。此外必定存在某個 $k$ 使得 $d_k(v) = \\mathrm{dist}(s, v)$。因此，對所有 $v$ 來說，$\\max_{1\\le k \\le n-1} \\frac{d_n(v) - d_k(v)}{n-k} \\ge 0$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"得知右半邊的式子永遠非負以後，剩下的任務就是要證明真的存在一組 $v, k$ 使得 $d_n(v) = d_k(v)$。令 $C$ 為總和是 $0$ 的圈，由於 $\\lambda^*=0$，在這個圈上任何兩點之間的最短路徑，必定等於這個圈上從一點走到另一點的距離（如果更短的話就有負圈啦）。考慮 $s$ 到這個 $C$ 上面任一點 $x$ 的最短路徑，這條路徑必定用掉不超過 $n-1$ 條邊。然後我們從 $x$ 開始沿著這個圈 $C$ 走，直到補足 $n$ 條邊為止。假設最後停在 $y$ 這個點。那麼，我們要說的是 $d_n(y) = \\mathrm{dist}(s, y)$，因為："}]},{"type":"text","value":"\n$$\n\\begin{align*}\n\\mathrm{dist}(s, y) & \\le d_n(y) \\\\\n& \\le \\mathrm{dist}(s, x) + \\mathrm{dist}(x, y) \\\\\n& \\le \\mathrm{dist}(s, y) + \\mathrm{dist}(y, x) + \\mathrm{dist}(x, y) \\\\\n& \\le \\mathrm{dist}(s, y) + 0\n\\end{align*}\n$$\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"所以，$y$ 這個點達到了最小值 $0$。於是當 $\\lambda^*=0$ 時等式成立。\n要怎利用這個證明推導出對所有的 $\\lambda^*$ 都正確呢？注意到我們可以同時對所有的邊「平移」（同時加上一個常數 $c$）而這件事情會使得所有圈的平均值都一起「平移」$c$，同時也讓式子右邊「平移」了 $c$。因此對於任意 $\\lambda^*$ 我們只要平移它到 $0$，再運用上述的證明，再平移回來，就行啦！證明完畢。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"關於演算法"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"最直接的方法就是直接用 $O(mn)$ 動態規劃計算出所有 $d_k(v)$ 的值，其他演算法我們可以改天聊。至於要找出實際的圈，我們可以先從上面的計算找出得到最佳值的 $v, k$，然後找出從 $s$ 到 $v$ 走恰好 $n$ 步的最小路徑，這個路徑上的任何一個 cycle 都是最小均值圈"},{"type":"element","tagName":"sup","properties":{"id":"fnref-4"},"children":[{"type":"element","tagName":"a","properties":{"href":"#fn-4","className":["footnote-ref"]},"children":[{"type":"text","value":"4"}]}]},{"type":"text","value":"。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"應用到消圈算法"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"theorem","properties":{"title":"最小均值消圈定理 [Goldberg-Tarjan 1989]"},"children":[{"type":"text","value":"\n如果每次從剩餘網路中增廣最小均值圈，那麼保證消圈的迭代次數不超過 $O(\\min\\{mn\\log(nC), m^2n\\log n\\})$ 次。\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"證明的步驟簡述如下。完整的證明可以在這份 Note "},{"type":"element","tagName":"sup","properties":{"id":"fnref-7"},"children":[{"type":"element","tagName":"a","properties":{"href":"#fn-7","className":["footnote-ref"]},"children":[{"type":"text","value":"7"}]}]},{"type":"text","value":" 找到。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"概念1"}]},{"type":"text","value":": 如果 $G_f$ 上面有負圈，那麼對於 $G_f$ 上面的最小均值圈，其平均也是負的。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"概念2"}]},{"type":"text","value":": 我們定義 $\\mu(f)$ 表示為將 $G_f$ 的最小均值圈變成非負的最小平移常數。（也就是說，最小均值圈的平均值為 $-\\mu(f)$）"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"概念3"}]},{"type":"text","value":": 對於任何勢能函數（或距離函數）$d$，我們定義等效邊權 $cost^d(u, v) = cost(u, v) + d(u) - d(v)$。不難發現，對於任何一個圖上的圈來說，其邊權的和總是等於等效邊權的和。也就是說，這樣的轉換並不會影響最小均值圈的數值。但可以藉此調整一些邊的權重。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"概念4"}]},{"type":"text","value":": 我們定義 $-\\epsilon(f)$ 表示對於任意函數 $d$ 定義出的等效邊權中，最小權重最大者。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"概念5"}]},{"type":"text","value":": 注意到，如果這個圖的最小均值圈是 $-\\mu(f)$ 的話，無論我們怎麼調整函數 $d$，調整後最小的那條邊一定小於平均。因此有 $-\\epsilon(f) \\le -\\mu(f)$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"概念6"}]},{"type":"text","value":": 相反地，若考慮平移後的圖 $G_f+\\mu(f)$，我們可以在上面定義一個距離函數 $d$，使得對所有 $(u, v)\\in G_f$ 我們都有 $d(u) + cost(u, v) \\ge d(v)$。也就是等效邊權 $cost^d(u, v)\\ge 0$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"概念7"}]},{"type":"text","value":": 把上面這個做出來的 $d$ 再減去 $\\mu(f)$，得到一個勢能函數（或距離函數），其等效邊權 $cost^{d-\\mu(f)}(u, v) \\ge -\\mu(f)$。於是我們有 $-\\epsilon(f) \\ge -\\mu(f)$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"概念8"}]},{"type":"text","value":": 綜合概念 5 與 7 我們可以得到 $\\mu(f)=\\epsilon(f)$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"概念9"}]},{"type":"text","value":": 現在固定一個 $f$，以及一個可以得出最佳等效距離的函數 $d$。假設在 $G_f$ 上面消完一個最小均值圈以後，得到的新的流是 $f'$。我們想要說兩件事情："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"$\\epsilon(f') \\le \\epsilon(f)$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"如果消的圈上存在一條正的等效邊，那麼 $\\epsilon(f') \\le \\left(1-\\frac{1}{n}\\right)\\epsilon(f)$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"假設我們增廣後仍暫時使用同樣的 $d$ 函數。那麼連續 $m$ 次增廣之內，一定會消到一個圈使得某條以 $d$ 為基準的等效邊是非負的，於是 2. 成立。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"概念10"}]},{"type":"text","value":": 因此，一開始 $\\epsilon(f_{始})\\le C$，經過 $mn\\ln {nC}$ 次增廣以後 $\\epsilon(f_{終}) < \\left(1-\\frac{1}{n}\\right)^{n\\ln {nC}} C \\le \\frac{1}{n}$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"概念11"}]},{"type":"text","value":": 如果所有容量和花費都是整數，那麼當最小均值圈 $> -\\frac{1}{n}$ 的時候，就代表它 $\\ge 0$。此時消圈算法就會停止。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"除了 "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"概念9"}]},{"type":"text","value":" 的 1. 和 2. 需要額外證明以外，上面的論述基本上就是全部的證明了。耶！搞定！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"結論"}]},{"type":"text","value":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"type":"element","tagName":"table","properties":{},"children":[{"type":"element","tagName":"thead","properties":{},"children":[{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"th","properties":{},"children":[{"type":"text","value":"演算法"}]},{"type":"element","tagName":"th","properties":{},"children":[{"type":"text","value":"消圈的次數"}]},{"type":"element","tagName":"th","properties":{},"children":[{"type":"text","value":"每一次消圈的時間"}]},{"type":"element","tagName":"th","properties":{},"children":[{"type":"text","value":"Weakly-Polynomial Worst-Case Complexity"}]},{"type":"element","tagName":"th","properties":{},"children":[{"type":"text","value":"Strongly-Polynomial Worst-Case Complexity"}]}]}]},{"type":"element","tagName":"tbody","properties":{},"children":[{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"element","tagName":"nobr","properties":{},"children":[{"type":"text","value":"Goldberg and Tarjan [1989]"}]},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"每次消最小均值圈"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(nm \\log (nC))$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(nm)$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(n^2m^2\\log (nC))$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(n^2m^3)$"}]}]},{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"element","tagName":"nobr","properties":{},"children":[{"type":"text","value":"Goldberg and Tarjan [1989]"}]},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"每次找所有簡化邊權重為負的圈"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(nm \\log (nC))$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(\\log n)$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(nm\\log n\\log (nC))$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(nm^2\\log^2n)$"}]}]},{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"element","tagName":"nobr","properties":{},"children":[{"type":"text","value":"Barahona and Tardos [1989]"}]},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"每次找一票點不重複的負圈然後增廣"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(m \\log (nCU))$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(nm+n^2\\log n)$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O((nm^2+mn^2\\log n)\\log(nCU)$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"N/A"}]}]},{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"element","tagName":"nobr","properties":{},"children":[{"type":"text","value":"Rock [1991]"}]},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"每次找剩餘流量足夠大的負圈"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(m \\log U)$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(nm)$ 或 $O(m+n\\log n)$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(nm^2\\log U)$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"N/A"}]}]},{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"element","tagName":"nobr","properties":{},"children":[{"type":"text","value":"Wallacher [1991]"}]},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"每次找最負比重負圈"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(m \\log (nCU))$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(n^3\\log^2 n)$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(n^3m\\log^2 n\\log(nCU))$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"N/A"}]}]},{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"element","tagName":"nobr","properties":{},"children":[{"type":"text","value":"Shigeno, Iwata and McCormick [1996]"}]},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"最負圈鬆弛演算法"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(nm \\log (nC))$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(nm+n^2\\log n)$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(n^2m^2\\log (nC)$ $+$ $n^3m\\log n\\log (nC))$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(n^2m^3\\log n$ $+$ $n^3m^2\\log n)$"}]}]},{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"element","tagName":"nobr","properties":{},"children":[{"type":"text","value":"Shigeno, Iwata and McCormick"},{"type":"element","tagName":"sup","properties":{"id":"fnref-3"},"children":[{"type":"element","tagName":"a","properties":{"href":"#fn-3","className":["footnote-ref"]},"children":[{"type":"text","value":"3"}]}]},{"type":"text","value":" [1996]"}]},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"最負圈縮放代價演算法"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(nm \\log C)$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(\\log n)$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(nm\\log C \\log n)$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"N/A"}]}]},{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"element","tagName":"nobr","properties":{},"children":[{"type":"text","value":"Sokkalingam, Ahuja and Orlin [1997]"}]},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"每次找剩餘流量足夠大的負圈"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(m \\log C)$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(m+n\\log n)$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(m^2\\log C$ $+$ $nm\\log C\\log n)$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(m^3\\log n$ $+$ $nm^2\\log^2 n)$"}]}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"small","properties":{},"children":[{"type":"text","value":"資料來源： Sokkalingam, Ahuja, Orlin, "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"New Polynomial-Time Cycle-Cancelling Algorithms for Minimum Cost Flows"}]},{"type":"text","value":", 1997. "},{"type":"element","tagName":"sup","properties":{"id":"fnref-1"},"children":[{"type":"element","tagName":"a","properties":{"href":"#fn-1","className":["footnote-ref"]},"children":[{"type":"text","value":"1"}]}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"參考資料"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{"className":["footnotes"]},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{"id":"fn-1"},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://pdfs.semanticscholar.org/f799/350ee4b93f02e672157d54ee06849edb7355.pdf"},"children":[{"type":"text","value":"Sokkalingam, Ahuja, Orlin, "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"New Polynomial-Time Cycle-Cancelling Algorithms for Minimum Cost Flows"}]},{"type":"text","value":", 1997."}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"a","properties":{"href":"#fnref-1","className":["footnote-backref"]},"children":[{"type":"text","value":"↩"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{"id":"fn-2"},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://www2.cs.duke.edu/courses/fall15/cps232/scribe_notes/lec05.pdf"},"children":[{"type":"text","value":"Duke University COMPSCI532 Fall 2015 Scribe Notes"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"a","properties":{"href":"#fnref-2","className":["footnote-backref"]},"children":[{"type":"text","value":"↩"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{"id":"fn-3"},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://www.jstor.org/stable/3690424?seq=1"},"children":[{"type":"text","value":"Shigeno, Iwata and McCormick, "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"Relaxed Most Negative Cycle and Most Positive Cut Canceling Algorithms for Minimum Cost Flow"}]},{"type":"text","value":", Mathematics of Operations Research 2000"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"a","properties":{"href":"#fnref-3","className":["footnote-backref"]},"children":[{"type":"text","value":"↩"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{"id":"fn-4"},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"http://www.cs.colostate.edu/~rmm/minCycleMean.pdf"},"children":[{"type":"text","value":"Colorado State University 最小均值圈講義"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"a","properties":{"href":"#fnref-4","className":["footnote-backref"]},"children":[{"type":"text","value":"↩"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{"id":"fn-5"},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"http://www.columbia.edu/~cs2035/courses/ieor6614.S16/mmc.pdf"},"children":[{"type":"text","value":"Columbia University 最小均值圈投影片"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"a","properties":{"href":"#fnref-5","className":["footnote-backref"]},"children":[{"type":"text","value":"↩"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{"id":"fn-6"},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://people.orie.cornell.edu/dpw/orie633/LectureNotes/lecture12.pdf"},"children":[{"type":"text","value":"Cornell University 的 Goldberg-Tarjan 演算法講義"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"a","properties":{"href":"#fnref-6","className":["footnote-backref"]},"children":[{"type":"text","value":"↩"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{"id":"fn-7"},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-854j-advanced-algorithms-fall-2008/lecture-notes/lec4.pdf"},"children":[{"type":"text","value":"MIT開放課程講義：Goldberg-Tarjan 演算法分析"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"a","properties":{"href":"#fnref-7","className":["footnote-backref"]},"children":[{"type":"text","value":"↩"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"判斷質數","category":"prob","path":"/problem/isprime","date":null,"description":"若一個正整數恰有兩個正因數，那我們稱它是一個質數。給定正整數 $n$，請判斷 $n$ 是否為質數。\n","link":null,"code":"ISPRIME","difficulty":null,"oj":null,"tags":null},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"Byzantine Agreement Problems","category":"research","path":"/research-notes/byzantine-agreement-problem","date":"2019-03-11","description":null,"link":null,"code":null,"difficulty":null,"oj":null,"tags":null},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"1 Byzantine Agreement"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"There are $N$ processores.\nEach processors $p$ has a private input bit $v_p\\in\\{0, 1\\}$.\nThroughout the protocol, every process can asynchronously pass messages to any other processors through a authenticated channel.\nThat is, it is assumed to be able to correctly identify the sender and the receiver by looking at the message itself.\nEventually every processor "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"decides"}]},{"type":"text","value":" an output bit and then halts.\nThe protocol is required to have the following properties:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Agreement"}]},{"type":"text","value":": all "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"good"}]},{"type":"text","value":" processors output the same bit."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Validity"}]},{"type":"text","value":": the output bit must occur as some "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"good"}]},{"type":"text","value":" processors's input bit."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Termination"}]},{"type":"text","value":": all "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"good"}]},{"type":"text","value":" processors halts after some a priori known round number $r$."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"1.1 Terminology"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Resilience"}]},{"type":"text","value":": we say that a protocol is $t$-resilient if consensus can be made if at most $t$ processors becomes bad."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Failure"}]},{"type":"text","value":": there are two types of failure: the "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Fail-Stop"}]},{"type":"text","value":" type failure or the "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Byzantine"}]},{"type":"text","value":" type failure. We consider Byzantine type failure."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"2 The FLP Impossibility Result"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"📑Fischer, Lynch and Paterson. "},{"type":"element","tagName":"a","properties":{"href":"https://groups.csail.mit.edu/tds/papers/Lynch/jacm85.pdf"},"children":[{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"Impossibility of Distributed Consensus with One Faulty Process"}]}]},{"type":"text","value":", 1985."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"3 Common Abstractions to the Asynchronous Model"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"3.1 Bracha's Reliable Broadcast"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"📑Gabriel Bracha. "},{"type":"element","tagName":"a","properties":{"href":"https://core.ac.uk/download/pdf/82523202.pdf"},"children":[{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"Asynchronous Byzantine Agreement Protocols"}]}]},{"type":"text","value":", 1987."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The first abstraction of this model is the "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"reliable broadcast"}]},{"type":"text","value":". Let $t$ be the number of bad processors. When $t < n/3$, they have the following properties:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"If a good processor sends a message $m$, then every good processor eventually "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"accepts"}]},{"type":"text","value":" $m$."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"If a bad processor sends a message, then every good processor "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"accepts"}]},{"type":"text","value":" the same message $m$ or they do not "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"accept"}]},{"type":"text","value":" any message at all."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"They terminated in $O(1)$ rounds."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Send $(initial, m)$ to all processors."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Upon receiving $(initial, m)$, send $(echo, m)$ to all processors."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"3.2 King and Saia's Blackboard Model"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"📑Valerie King, Jared Saia. "},{"type":"element","tagName":"a","properties":{"href":"https://dl.acm.org/citation.cfm?id=2837019"},"children":[{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"Byzantine Agreement in Expected Polynomial Time"}]}]},{"type":"text","value":", JACM 2016."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"📑Valerie King, Jared Saia. "},{"type":"element","tagName":"a","properties":{"href":"https://arxiv.org/abs/1812.10169"},"children":[{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"Correction to Byzantine Agreement in Expected Polynomial Time, JACM 2016"}]}]},{"type":"text","value":", ArXiv 2018."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"4 Upper Bounds"}]},{"type":"text","value":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"type":"element","tagName":"table","properties":{},"children":[{"type":"element","tagName":"thead","properties":{},"children":[{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"th","properties":{},"children":[{"type":"text","value":"Algorithm"}]},{"type":"element","tagName":"th","properties":{},"children":[{"type":"text","value":"Resilience"}]},{"type":"element","tagName":"th","properties":{},"children":[{"type":"text","value":"communication time"}]},{"type":"element","tagName":"th","properties":{},"children":[{"type":"text","value":"local running time"}]}]}]},{"type":"element","tagName":"tbody","properties":{},"children":[{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"Ben-Or 1983"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$t < n/5$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"Exponential"}]},{"type":"element","tagName":"td","properties":{},"children":[]}]},{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"Bracha 1987"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$t < n/3$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"Exponential"}]},{"type":"element","tagName":"td","properties":{},"children":[]}]},{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"King and Saia 2016"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$t < 1.15\\times 10^{-9}n$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(n^3)$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"Polynomial Time"}]}]},{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"King and Saia 2016"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$t < n/400$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(n^{2.5}\\sqrt{\\log n})$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"Exponential Time"}]}]},{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"Li and Duan 2018"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$t = \\Theta(n)$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(n)$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"Exponential Time"}]}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"4.1 Simplified Bracha"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Reliably broadcast $v_p$."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Wait until accept $n-t$ messages."},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"\n$v_p\\gets$ majority of these messages."},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"\nReliably broadcast $v_p$."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Wait until accept $n-t$ messages.  "}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"If $>n/2$ messages have value same $v$:"},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"\nReliably broadcast \"I see $v$\"."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"else"},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"\nReliably broadcast \"I don't see majority\"."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Wait until accept $n-t$ messages."},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"\nLet $x$ be the number of messages of the form \"I see $v$\""}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"5 Lower Bounds"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"📑James Aspnes. "},{"type":"element","tagName":"a","properties":{"href":"http://disi.unitn.it/~montreso/ds/syllabus/papers/randomized-consensus-survey.pdf"},"children":[{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"Randomized Protocols for Asynchronous Consensus"}]}]},{"type":"text","value":", Distributed Computing 2003."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"📑Hagit Attiya and Keren Censor. "},{"type":"element","tagName":"a","properties":{"href":"https://dspace.mit.edu/openaccess-disseminate/1721.1/64943"},"children":[{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"Lower bounds for randomized consensus under a weak adversary"}]}]},{"type":"text","value":", PODC 2008."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"[Attiya and Censor 2008] The probability that a randomized consensus algorithm does not terminate after $k(n-t)$ "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"steps"}]},{"type":"text","value":" is at least $1/c^k$ for some constant $c$, even for a weak adversary."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Other Models and Assumptions"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Fail-Stop Failure"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"📑Marcos K. Arguilera and Sam Toueg. "},{"type":"element","tagName":"a","properties":{"href":"https://link.springer.com/article/10.1007/s00446-012-0162-z"},"children":[{"type":"text","value":"The correctness proof of Ben-Or’s randomized consensus algorithm"}]},{"type":"text","value":", Distributed Computing 2012."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Gives the proof to Ben-Or's consensus protocol when $t < n/2$ assuming Fail-Stop type failure."}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"Random Paper Notes","category":"research","path":"/research-notes/random-notes","date":"2019-04-20","description":null,"link":null,"code":null,"difficulty":null,"oj":null,"tags":null},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Single Sourcewise Multiplicative Spanners"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Khuller, Raghavachari and Young. "},{"type":"element","tagName":"a","properties":{"href":"https://link.springer.com/article/10.1007/BF01294129"},"children":[{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"Balancing Minimum Spanning Trees and Shortest-Path Trees"}]}]},{"type":"text","value":", Algorithmica 1995."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"theorem","properties":{"title":"Theorem"},"children":[{"type":"text","value":"\nGiven minimum spanning tree $T_M$ and shortest path tree $T_S$ with the same root $r$ and any constant $K>0$.\nThere is an algorithm in $O(n)$ time producing a tree $T$ that has (1) total weight $\\le (1+2/K)|T_M|$ and\n(2) for all vertex $v$, the distance from $r$ to $v$ is at most $(1+K)\\mathrm{dist}(r, v)$ in $T_S$.\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h4","properties":{},"children":[{"type":"text","value":"Proof Sketch."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The algorithm maintains a subgraph $H$, and runs DFS along minimum spanning tree $T_M$.\nInitially the subgraph $H$ is set to $T_M$.\nWhenever the algorithm arrives a vertex $v$,\nand if the current distance $d[v] > (1+K)\\mathrm{dist}(r, v)$,\nthe algorithm adds the entire shortest path $P(r, v)$ to $H$."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Let paths $P(r, v_1), P(r, v_2), \\ldots, P(r, v_k)$ be the shortest path added to $H$\nduring the execution of the algorithm.\nThe total increase of the cost is $\\sum_{i=1}^k \\mathrm{dist}(r, v_i)$.\nHowever, by the time $P(r, v_i)$ is added to $H$ we have that $(1+K)\\mathrm{dist}(r, v_i) < d[v_i] \\le \\mathrm{dist}(r, v_{i-1}) + d_M(v_{i-1}, v_i)$.\nBy summing both sides from $i=1$ to $k$, we get total increase cost is no more than $\\frac{2}{K}|T_M|$."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h4","properties":{},"children":[{"type":"text","value":"重點"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"只有在 DFS 往上或往下爬的時候才 relax edge，這樣就足夠好了，不用每次重算 $H$ 上面的最短路徑。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"利用上次加 path 的位置作 telescoping sum，加起來剛好繞 MST（或任何樹）一圈。"}]},{"type":"text","value":"\n"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"SAT 問題集錦 [草稿]","category":"","path":"/algo/sat","date":"2019-01-23","description":null,"link":null,"code":null,"difficulty":null,"oj":null,"tags":null},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"CNF-SAT "}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"A+B Problem","category":"cp","path":"/cp/a-plus-b","date":"2018-11-14","description":"給定兩個整數 $A$ 以及 $B$，請輸出 $A+B$ 之值。\n","link":"https://oj.icpc.tw/problem/1","code":null,"difficulty":null,"oj":null,"tags":null},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"題目敘述"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ連結"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://oj.icpc.tw/problem/1"},"children":[{"type":"text","value":"競程日記 Problem 1. A+B Problem"}]}]},{"type":"text","value":"\n"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"平面圖的線性時間判定","category":"notes","path":"/algo/planar-graphs","date":"2018-02-06","description":null,"link":null,"code":null,"difficulty":null,"oj":null,"tags":null},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"1 深度優先搜索"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Planarity Testing"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"DFS"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Left-Right Characterization"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The original description is from de Fraysseix, Ossona de Mendez, and Rosenstiehl (2006)."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"1-Planar Graphs"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"theorem","properties":{"title":"Definition (1-planar)","c":"is-success"},"children":[{"type":"text","value":"\nA graph is called **1-planar** if it can be drawn in the plane so that each edge is crossed at most once.\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"參考資料"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Franz J. Brandenburg, "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"Characterizing and Recognizing 4-Map Graphs"}]},{"type":"text","value":", Algorithmica 2018."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Zhi-Zhong Chen, Michelangelo Grigni, and Christos H. Papadimitriou. "},{"type":"element","tagName":"a","properties":{"href":"http://rnc.r.dendai.ac.jp/~chen/papers/mg56.pdf"},"children":[{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"Map Graphs"}]}]},{"type":"text","value":", 2002."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Ulrik Brandes, "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"The Left-Right Planarity Test"}]},{"type":"text","value":", 2009."}]},{"type":"text","value":"\n"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"圖論演算法 2 - 圖論上可能的計算問題","category":"algo","path":"/algo/algorithmic-graph-theory/graph-problem-examples","date":"2019-02-12","description":null,"link":null,"code":null,"difficulty":null,"oj":null,"tags":null},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"§2.1 圖的定義"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"以數學物件表示的話，一般來說我們會把圖定義為由點集合 $V$ 和邊集合 $E$ 所形成的配對 $G=(V, E)$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"§2.2 圖的分類"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"當我們把模型抽象變成只有點和邊的時候，根據各種需求我們會自然地把所有可能的圖進行分類。比方說根據定義我們可以寫下無向圖、有向圖、無權圖、加權圖、重圖（Multi graph）、近圖（Pseudo graph）、簡單圖、無限圖等等。在這些圖上我們又可以定義道路（Walk）、行跡（Trail）、路徑（Path）、圈或環（Cycle）、連通元件（Connected Components）等等。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"基於這些基本的定義，我們可以刻劃並且分類出一系列具備相同性質的圖。\n比方說："},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"連通圖"}]},{"type":"text","value":"是一類滿足「任兩點之間都存在一條路徑的無向圖」、而"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"樹"}]},{"type":"text","value":"是一類滿足「任兩點之間都存在恰好一條路徑的無向圖」、而"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"平面圖"}]},{"type":"text","value":"是一類滿足「可以把該圖繪製在歐幾里得平面上，使任兩條邊都不相交的圖」等等。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"根據圖分類衍伸的問題"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"只要有一個性質 $P$，我們就可以把所有滿足該性質 $P$ 的圖蒐集起來變成一個類別 $\\mathcal{G}_P$。通常我們對於與性質 $P$ 相關的計算問題有以下幾種類型："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"辨認問題"}]},{"type":"text","value":"（Recognition Problem）：給定圖 $G$，判斷是否 $G\\in \\mathcal{G}_P$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"辨認且舉證"}]},{"type":"text","value":"（Witness Problem）：給定圖 $G$，除了判斷是否 $G\\in\\mathcal{G}_P$ 以外，還必須輸出一個簡潔的證據，使得基於這個證據能夠有更有效率的驗證方法。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"列舉問題"}]},{"type":"text","value":"（Enumeration Problem）：給定額外性質 $Q$，找出（或計數）所有 $\\mathcal{G}_P$ 中滿足性質 $Q$ 的圖。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"簡潔資料結構"}]},{"type":"text","value":"（Succinct Data Structure）：能否將該類圖用較少的記憶體儲存之，並且仍能夠提供足夠有效率的資料結構操作。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"§2.3  關於輸入格式"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"稍早提到的電腦與圖靈機等等，其輸入內容都是二元字串。要怎麼把一個輸入圖論的圖以二元字串來表達呢？對於一些計算問題而言，不同的輸入方式會造成演算法有著不同的執行效率。說得誇張一點的話，甚至會造成若干數量級的效率差異。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"但其實這就是約定俗成的東西，在沒有特別說明的情況下，我們總是可以依照圖的定義 $G=(V, E)$，將所有點集合 $V$ 和邊集合 $E$ 的物件依序列出來，作為電腦的輸入。因此，決定演算法執行效率的重點，在於輸入後我們將以什麼樣的資料結構儲存這個圖。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"§2.4  關於資料結構"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"一般來說儲存一張圖的方式有"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"鄰接矩陣"}]},{"type":"text","value":"（Adjacency Matrix）和"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"鄰接串列"}]},{"type":"text","value":"（Adjacency Lists）兩種方式。這兩種方式有各自的優缺點，大家有興趣可以想一下，這裡就不贅述了。"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"圖論演算法 3 - 深度優先搜尋(DFS)","category":"algo","path":"/algo/algorithmic-graph-theory/dfs","date":"2019-02-17","description":null,"link":null,"code":null,"difficulty":null,"oj":null,"tags":null},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果已經有一個圖儲存在記憶體裡面了，我們可以用哪些方式有系統地走遍這張圖呢？今天介紹的是大家耳熟能詳的"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"深度優先搜尋"}]},{"type":"text","value":"（Depth First Search）。DFS 的發展與靈感其實來自於走迷宮問題，「如何有效率並且不出差錯地走出迷宮」。而這些想法在 1950 年代左右被應用到各式各樣的演算法中，尤其是 "},{"type":"element","tagName":"a","properties":{"href":"https://en.wikipedia.org/wiki/Robert_Tarjan"},"children":[{"type":"text","value":"Robert Tarjan"}]},{"type":"text","value":" 在這段期間發表了許多驚心動魄的 DFS 應用，造福後世。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"§3.1 DFS 演算法"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"在這邊幫大家快速複習一下 DFS 和相關的性質。首先我們會在每個點定義一個的狀態：「尚未走訪（白色，white）」、「走訪中（灰色，gray）」、「已結束走訪（黑色，black）」。每一個圖上的點在任意時刻都會是這三種狀態的其中之一。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"而從一個指定節點進行深度優先搜尋的方法如下："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"$\\text{DFS}(x):$"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"首先將該節點 $x$ 的狀態改為灰色。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"考慮所有相連邊 $(x, y)\\in E$，若另一頭的節點 $y$ 是白色，就遞迴執行 $\\text{DFS}(y)$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"若所有相連邊的另一頭都已是灰色或黑色，則將節點 $x$ 狀態改為黑色。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"DFS 樹"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"在 DFS 的過程中，如果我們把所有的走訪的節點 $y$，與呼叫 $\\text{DFS}(y)$ 當下走訪的節點 $x$ 連起來，會得到一棵樹。這樣的樹我們把它稱之為 DFS 樹。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"§3.2 邊的分類"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"不難證明，對某個圖 $G$ 上面的點 $v\\in V$，在呼叫 $\\text{DFS}(v)$ 後，與 $v$ 同屬相同連通塊的所有邊都會被看過 1 次（無向邊的話會從兩個方向各自看過一次，因此總共會被看過 2 次）。我們可以對這些邊 $(x, y)$ 依照被發現當下的特性進行歸類："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"如果 $y$ 是白色，那這條邊會被稱為 tree-edge（因為會緊接著呼叫 $\\text{DFS}(y)$，所以這條邊會在 DFS 樹上）。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"如果 $y$ 是灰色，那這條邊會被稱為 back-edge。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"如果 $y$ 是黑色、而且 $x$ 是 $y$ 在 DFS 樹上面的祖先，那麼這條邊會被稱為 forward-edge。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"如果 $y$ 是黑色，但是 $x$ 並非 $y$ 在 DFS 樹上的祖先，那麼這條邊會被稱為 cross-edge。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"theorem","properties":{"title":"性質"},"children":[{"type":"text","value":"\n無向圖上面的 DFS 並不會出現 cross-edge。\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"參考資料"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://en.wikipedia.org/wiki/Depth-first_search"},"children":[{"type":"text","value":"https://en.wikipedia.org/wiki/Depth-first_search"}]}]},{"type":"text","value":"\n"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"圖論演算法 0 - 介紹","category":"algo","path":"/algo/algorithmic-graph-theory/intro","date":"2019-02-09","description":null,"link":null,"code":null,"difficulty":null,"oj":null,"tags":null},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"§0.1 引言"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"圖論可謂一種數學模型，它將現實中繁雜的問題，用抽象化的數學物件來代表。我們將從演算法的觀點，與大家分享有哪些圖論觀念，結合演算法以後能夠看透更多問題背後的本質。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"§0.2 參考書籍"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我想要紀錄一些《Algorithmic Graph Theory and Perfect Graphs》書籍的閱讀筆記。這本書是由 Martin Charles Golumbic 撰寫。第一版是 1980 年出版，而第二版則是在 2004 年出版。中文的參考資料（尤其是名詞翻譯）則推薦大家閱讀張鎮華教授撰寫的《演算法觀點的圖論》。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"§0.3 探討的方向"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"許多在圖論上重要的問題，不見得都對應著有效率的演算法。\n如同計算理論對於所有可計算的問題進行分類與比較，同一個問題對於不同系列的圖，也會有著不同的難度。而根據合適的分類方法（性質或觀察）發展出來的演算法，通常就會有效率得多。"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"圖論演算法 5 - 一筆畫問題 Euler Tour","category":"algo","path":"/algo/algorithmic-graph-theory/euler-tour","date":"2019-02-25","description":null,"link":null,"code":null,"difficulty":null,"oj":null,"tags":null},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"§4.1 Königsberg 七橋問題"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"該提到的還是會提到哈哈。大家想必對於圖論起源的七橋問題非常熟稔了，這邊就簡單地提及。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"< 待補 >"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"§4.2 一筆畫問題"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"theorem","properties":{"c":"is-link"},"children":[{"type":"text","value":"\n給定一個無向圖 $G$，是否存在一個行跡（trail）使得恰好經過所有邊各一次？\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"display","properties":{"graph":""},"children":[{"type":"text","value":"\n    "},{"type":"element","tagName":"node","properties":{"id":"1"},"children":[]},{"type":"text","value":"\n    "},{"type":"element","tagName":"node","properties":{"id":"2"},"children":[]},{"type":"text","value":"\n    "},{"type":"element","tagName":"node","properties":{"id":"3"},"children":[]},{"type":"text","value":"\n    "},{"type":"element","tagName":"node","properties":{"id":"4"},"children":[]},{"type":"text","value":"\n    "},{"type":"element","tagName":"edge","properties":{"data":"[1, 2]","bendleft":""},"children":[]},{"type":"text","value":"\n    "},{"type":"element","tagName":"edge","properties":{"data":"[1, 2]","bendright":""},"children":[]},{"type":"text","value":"\n    "},{"type":"element","tagName":"edge","properties":{"data":"[2, 3]","bendleft":""},"children":[]},{"type":"text","value":"\n    "},{"type":"element","tagName":"edge","properties":{"data":"[2, 3]","bendright":""},"children":[]},{"type":"text","value":"\n    "},{"type":"element","tagName":"edge","properties":{"data":"[1, 4]"},"children":[]},{"type":"text","value":"\n    "},{"type":"element","tagName":"edge","properties":{"data":"[2, 4]"},"children":[]},{"type":"text","value":"\n    "},{"type":"element","tagName":"edge","properties":{"data":"[3, 4]"},"children":[]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"對於這個問題 Euler 給出了非常厲害的觀察："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"theorem","properties":{"title":"一筆畫性質"},"children":[{"type":"text","value":"\n一個連通圖 $G$ 可以被一筆畫完成，若且唯若圖 $G$ 上面恰好有 0 個或 2 個奇數度數的點。此外，如果圖 $G$ 上面恰好有兩個奇度數的點，那麼存在起點與終點分別在這兩個點的一筆畫行跡。\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h4","properties":{},"children":[{"type":"text","value":"證明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"\"$\\Rightarrow$\" 這個方向比較簡單。考慮圖 $G$ 上面一筆畫的行跡，除了起點與終點以外，對於每一個點的「進入次數」與「離開次數」都是相等的，也就是說這些非起點與終點的度數都必須是偶數。此外，根據握手定理，奇度數的點的個數必須是偶數，因此得證。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"\"$\\Leftarrow$\" 我們可以對邊數 $m$ 進行歸納。$m=0$ 的時候，連通圖只有一個點，顯然所有邊可以被一筆畫完成。現在考慮 $m>0$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果 $G$ 度數都是偶數，我們隨便選一條邊 $e\\in E$，然後考慮 $G'=G-e$。如果我們能證明出 $G'$ 是連通圖，那根據數學歸納法可以直接得出"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"§4.3 歐拉路徑的演算法"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"§4.4 最小字典序"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"圖論演算法 6 - 簡單圖 Simple Graphs","category":"algo","path":"/algo/algorithmic-graph-theory/simple-grpahs","date":"2019-02-21","description":null,"link":null,"code":null,"difficulty":null,"oj":null,"tags":null},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"簡單圖大概是所有定義裡頭最簡單的了。所謂的簡單圖，就是沒有包含重邊（multi-edge）和自環（self-loop）的圖。利用前一節我們介紹的度序列，我們可以透過給定一個合法的度序列來生成簡單圖。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"§6.1 合法的簡單圖"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Havel 以及 Hakimi 分別在 1955、1962 年發表了藉由給定度序列構造簡單圖的演算法。我們說一個序列 $(d_1, d_2, \\ldots, d_n)$ 是 "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"可製圖的（graphical）"}]},{"type":"text","value":" 若且唯若這個序列是某個簡單圖的度序列。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"theorem","properties":{"title":"Havel-Hakimi 定理 [1955, 1962]"},"children":[{"type":"text","value":"\n一個非負整數序列 $(d_1, d_2, \\ldots, d_n)$ 滿足 $d_2\\ge \\cdots \\ge d_n$ 是可製圖的，若且唯若少了第一個點的序列 $(\\underbrace{d_2-1, d_3-1, \\ldots, d_{d_1+1}-1}_{\\text{總共} d_1 \\text{個}}, d_{d_1+2}, \\ldots, d_n)$ 也是可製圖的。\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h4","properties":{},"children":[{"type":"text","value":"證明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"\"$\\Leftarrow$\" 這個方向是簡單的，如果少了一個點的序列是可製圖的，那麼把這個點補回去就會得到一個滿足度數要求的簡單圖。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"\"$\\Rightarrow$\" 令滿足度序列的圖 $G$ 所成的集合為 $\\mathcal{G}$。假設存在至少一個簡單圖使得對於任意點 $v_i\\in V$ 其度數恰好是 $d_i$。我們的目標是要證明：存在 $G\\in\\mathcal{G}$ 使得 $v_1$ 的鄰居 $N(v_1) = \\set{v_2, \\ldots, v_{d_1+1}}$。對於所有圖 $G\\in\\mathcal{G}$，我們定義 $i_G$ 為最小的編號使得 $v_1$ 與 $v_2, \\ldots, v_{i_G}$ 相連，但是不與 $v_{i_G+1}$ 相連。顯然我們想證明存在一個滿足度序列的圖 $G$ 使得 $i_G = d_1+1$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我們利用反證法證明之："},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"若不然"}]},{"type":"text","value":"，$\\forall G\\in\\mathcal{G},\\ i_G \\le d_1$。令 $G$ 是所有 $\\mathcal{G}$ 裡面的圖中 $i_G$ 最大者。由於 $i_G \\le d_1$，此時必存在 $j > i_G+1$ 使得 $(v_1, v_j)\\in E$。注意到 $d_{i_G+1} \\ge d_j$，但是在該圖上 $(v_1, v_{i_G+1})\\notin E$、卻同時有 $(v_1, v_j)\\in E$。因此我們可以推得：存在另一個 $v_k\\in V$ 使得 $(v_{i_G+1}, v_k)\\in E$ 但是 $(v_j, v_k)\\notin E$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"現在讓我們把圖 $G$ 稍微修改一下：令 $G' = G -\\set{(v_{i_G+1}, v_k), (v_1, v_j)} \\cup \\set{(v_1, v_{i_G+1}), (v_j, v_k)}$。此時 $G'$ 滿足所有度序列條件，因此 $G'\\in \\mathcal{G}$。但是 $i_{G'} > i_G$，與 $i_G$ 最大之假設矛盾，得證。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"note","properties":{},"children":[{"type":"text","value":"\n這類型的證明方法被歸類為**無窮遞降法**，其實也是另一種數學歸納法的表現。這類方法在證明各種 Greedy 演算法的最佳性質的時候非常有幫助！\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"從 Havel-Hakimi 定理的敘述和證明我們不難得出具體的構造演算法。但真的得透過構造來證明指定度序列的簡單圖存在性嗎？答案是不一定需要。在 1960 年 Erdős 與 Gallai 發表了非構造性的數學論述："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"theorem","properties":{"title":"Erdős-Gallai 定理 [1960]"},"children":[{"type":"text","value":"\n一個非遞增非負整數序列 $d_1\\ge d_2\\ge \\cdots \\ge d_n$ 是可製圖的，若且唯若以下兩條件成立：\n* $d_1+\\cdots + d_n$ 是偶數。\n* 對於所有 $1\\le k\\le n$，皆有：$$ \\sum_{i=1}^k d_i \\le k(k-1) + \\sum_{i=k+1}^n \\min(d_i, k).$$\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Erdős-Gallai 定理的證明其實有點困難。最早的 1960 年的論文相當地繁雜。在 1970 年左右，法國數學家 Berge 利用網路流的概念證明了 E-G 定理。1986 年印度數學家 Choudum 提出了一個相對簡潔一點的數學歸納法證明。在這個證明裡頭，我們可以隱約看到剛才 Havel-Hakimi 定理的證明的影子。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h4","properties":{},"children":[{"type":"text","value":"證明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"\"$\\Rightarrow$\" 這個部分相當直觀：首先，對於任意簡單圖來說，由握手定理可以推得度數和必須是偶數。若我們取任意 $k$ 個點的集合 $S\\subset V$，這個圖會被拆成兩部分：$G[S]$ 以及 $G[V\\setminus S]$。對於一個簡單圖來說，$G[S]$ 至多只能有 $k(k-1)/2$ 條邊，因此這些邊貢獻的度數和至多為 $k(k-1)$。另外對於每一個 $V\\setminus S$ 裡面的點 $v_i$，其連入 $S$ 至多只有 $\\min(d_i, k)$ 條邊。於是，取 $S$ 為度數最大的 $k$ 個點，其度數和至多只能是 $k(k-1) + \\sum_{i=k+1}^n \\min(d_i, k)$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"\"$\\Leftarrow$\" 我們可以對總點數加度數 $n+\\sum d_i$ 進行歸納。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"(Base Case) 如果圖只有一個點 $n=1$，那麼 $d_1=0$ 是唯一可製圖的例子。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"(Inductive Step, Case 1) 如果 $d_n=0$，我們可以把這個點拿掉而不改變所有條件，根據歸納假設，此時存在一個簡單圖滿足要求。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"(Inductive Step, Case 2) 如果 $d_n>0$，此時顯然有 $d_n \\le n-1$。我們選取 $t$ 使得 $d_1=d_2=\\cdots = d_t > d_{t+1}$（如果 $t$ 不存在的話就讓 $t=n-1$）。接下來我們考慮修改後的度序列 $(d_1, d_2, \\ldots, d_t -1, \\ldots, d_{n-1}, d_n-1)$。選取的 $t$ 會保證新的序列也是非遞增的。接下來我們要作兩件事：首先證明新的度序列是可製圖的、然後利用做出來的圖，實現一個能對應原本度序列的圖。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"證明新的度序列是可製圖的，可以透過分析以下幾個情形證明之："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"($k\\ge t$)：比較舊序列與新序列的不等式，發現左邊的值必定 $-1$、右邊的值可能少 $1$ 或不變。因此新序列在此情形的不等式保證成立。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"($k < t$)：此時不等式左邊永遠是 $kd_1$。接下來分成四種情形討論："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"$k > d_1$：此時 $kd_1 \\le k(k-1)$，新的不等式保證成立。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"$k = d_1$：除非 $k=t-1$、$t=n-1$ 而且 $d_n=1$ 不然保證成立，但是此情形發生時，$d_1+\\cdots+d_n=t(t-1)+1$ 是個奇數，與總度數為偶數之假設矛盾。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"$d_n\\le k < d_1$："},{"type":"element","tagName":"span","properties":{"className":["has-text-success"]},"children":[{"type":"text","value":"[定理 1.16，很巧妙的一步]"}]},{"type":"text","value":" 根據舊的不等式，把變數 $k$ 用 $k+1$ 重新寫過會得到"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n$$\n\\begin{align*}\n&& (k+1)d_1 \\le & \\  (k+1)(t-1) + \\sum_{j=t+1}^{n-1} \\min(k+1, d_j) + d_n \\\\\n\\Longleftrightarrow && kd_1 \\le & \\  k (t-1) + \\sum_{j=t+1}^{n-1} \\frac{k}{k+1}\\min(k+1, d_j) + \\frac{k}{k+1} d_n \\\\\n&& \\le &\\ \nk (t-1) + \\sum_{j=t+1}^{n-1} \\min(k, d_j) + (d_n-1)\n\\end{align*}\n$$\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"$k < d_n$：不等式不會發生變化，所以保證成立。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"證明新的度序列是可製圖的以後，根據歸納假設，存在一個圖 $G'$ 滿足新的度序列。如果此時 $(v_t, v_n)\\notin E$，那我們把這條邊加上便能實現原本的度序列。如果此時 $(v_t, v_n)\\in E$，那麼我們要找另外一條邊來交換：首先因為 $d_t-1 \\le n-2$，存在一個 $v_i\\neq v_n\\in V$ 使得 $(v_t, v_i)\\notin E$。接著，由於 $d_i \\ge d_n$，存在一個 $d_j$ 使得 $(d_i, d_j)\\in E$ 但 $(d_n, d_j)\\notin E$。於是我們就可以把這個圖 $G'$ 換一下，扣掉原本的兩條邊、加回後兩條邊，得到一個 $(v_t, v_n)\\notin E$ 但保有相同度序列的圖，此時再把 $(v_t, v_n)$ 加上去就構造完畢囉。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"note","properties":{},"children":[{"type":"text","value":"\n這個定理的證明也可以在張鎮華老師的《演算法觀點的圖論》定理 1.16 找到。\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"§6.2 樹的度序列"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我們知道 $n$ 個點的樹是一個恰好有 $n-1$ 條邊的連通圖。如果 $d_1, \\cdots, d_n$ 是這顆樹的度序列，顯然必須有 $d_1+\\cdots + d_n = 2(n-1)$。不意外地，這也幾乎是從度序列建構一棵樹的充分條件。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"theorem","properties":{"title":"樹的度序列"},"children":[{"type":"text","value":"\n給定一個非遞增正整數序列 $d_1\\ge d_2\\ge \\cdots \\ge d_n$。存在一棵滿足該度序列的樹，若且唯若以下兩條件成立：\n* $d_1+\\cdots + d_n = 2(n-1)$。\n* $n=1$ 或 $d_n = 1$。\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這個證明只要用數學歸納法即可，不難。有趣的是，這個條件恰好也正是要讓一個連通圖存在的邊界條件。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"§6.3 簡單連通圖"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"theorem","properties":{"title":"連通圖的度序列"},"children":[{"type":"text","value":"\n一個序列 $(d_1, d_2, \\ldots, d_n)$ 可以實現一個簡單連通圖，若且唯若該序列是可製圖的、滿足 \"$n=1$ 或 $d_n\\ge 1$\"、並且 $\\sum d_i \\ge 2(n-1)$。\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這個證明，可以直接透過 Havel-Hakimi 定理加上樹的度序列定理的證明方法證得：每一次挑選度數最小的點，將這個點連到度數最大的那些點並移除，得到總邊數較少的可製圖序列。不難驗證此時總度數仍滿足敘述條件。根據歸納假設我們得到一個連通圖，然後加回這個點時自然也是連通圖了。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"習題"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"span","properties":{"className":["tag","is-dark"]},"children":[{"type":"text","value":"證明題"}]},{"type":"text","value":" 我們說一個兩個序列 $(a_1, a_2, \\ldots, a_n)$ 和 $(b_1, b_2, \\ldots, b_n)$ 是個二分圖序列（bigraphic），如果存在一個兩邊各自有 $n$ 個點的二分圖使得兩邊度數分別是 $a_1, \\ldots, a_n, b_1, \\ldots, b_n$。Gale-Ryser 定理 [1957] 證明了，若 $a_1\\ge \\cdots \\ge a_n$，則兩序列是 bigraphic 若且唯若"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"$\\sum_{i=1}^n a_i = \\sum_{i=1}^n b_i$，而且"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"對所有的 $1\\le k\\le n$：$\\sum_{i=1}^k a_i \\le \\sum_{i=1}^n \\min(b_i, k)$。  "}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"span","properties":{"className":["tag","is-link"]},"children":[{"type":"text","value":"演算法"}]},{"type":"text","value":" 設計一個 $O(n)$ 時間的演算法，判斷一個長度為 $n$ 的非負整數序列是否為某個簡單圖的度序列。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"span","properties":{"className":["tag","is-danger"]},"children":[{"type":"text","value":"程設題"}]},{"type":"text","value":" 幼稚園吃午餐問題？"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考資料"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"http://szhorvat.net/pelican/hh-connected-graphs.html"},"children":[{"type":"text","value":"http://szhorvat.net/pelican/hh-connected-graphs.html"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"http://kanari.logdown.com/posts/2014/03/09/erdos-gallai-theorem-conditions-for-a-sequence-to-be-graphical"},"children":[{"type":"text","value":"http://kanari.logdown.com/posts/2014/03/09/erdos-gallai-theorem-conditions-for-a-sequence-to-be-graphical"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://arxiv.org/abs/1212.5443"},"children":[{"type":"text","value":"https://arxiv.org/abs/1212.5443"}]}]},{"type":"text","value":"\n"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"圖論演算法 7 - 完全子圖 Cliques","category":"algo","path":"/algo/algorithmic-graph-theory/cliques","date":"2019-02-28","description":null,"link":null,"code":null,"difficulty":null,"oj":null,"tags":null},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果一個簡單圖的任兩個點之間都有一條邊相連，那麼這個圖被稱為"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"完全圖"}]},{"type":"text","value":"（Complete Graph）。通常我們會用 $K_n$ 來表示有 $n$ 個點的完全圖。而完全子圖（Clique）則是指給定一個簡單圖當中，任兩點之間都有連邊的一個子圖。如果一個圖 $G$ 上的完全子圖，不存在任何其他點連到這個子圖上的所有點（也就是說不存在更大的完全子圖包含它），那我們就稱這個子圖為"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"極大完全子圖"}]},{"type":"text","value":"（Maximal Clique）。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果這個完全子圖在圖上擁有最大的點數，那我們稱它為"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"最大完全子圖"}]},{"type":"text","value":"（Maximum Clique），通常我們將最大完全子圖的點數以 $\\omega(G)$ 表示之。找出最大完全子圖的大小在計算上是困難的，這是一個 $\\mathsf{NP}$-完全問題。那要怎麼找出最大完全子圖呢？我們可以先從極大完全子圖下手，如果能夠找出所有極大完全子圖，那最大的一個自然就是最大完全子圖了。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"§7.1 極大完全子圖"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Moon 跟 Moser 在 1965 年證明了任何一個有 $n$ 個點的圖 $G$，上面的極大完全子圖數量不超過 $O(3^{n/3})$ 個。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"theorem","properties":{"title":"極大完全子圖的數量上界 [Moon-Moser 1965]"},"children":[{"type":"text","value":"\n任何一個有 $n$ 個點的圖 $G$，其極大完全子圖的數量至多為：\n$$\n\\begin{cases}\n3^{n/3}, & \\text{if $n\\equiv 0 \\pmod 3$,}\\\\\n4\\times 3^{\\lfloor n/3\\rfloor}-1, & \\text{if $n\\equiv 1 \\pmod 3$,}\\\\\n2\\times 3^{\\lfloor n/3\\rfloor}, & \\text{if $n\\equiv 2 \\pmod 3$,}\\\\\n\\end{cases}\n$$\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h4","properties":{},"children":[{"type":"text","value":"證明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我們可以用逐步調整的方法，找出擁有最多極大完全子圖的圖。對於圖 $G$ 而言，考慮任兩個沒有相鄰的點 $x, y$。顯然任何的極大完全子圖，無法同時包含 $x$ 和 $y$ 兩者。我們查看圖 $G$ 上面，分別有多少個包含 $x$ 與包含 $y$ 的極大完全子圖數量。令這兩個數值為 $C_x$ 和 $C_y$。不妨假設 $C_x \\le C_y$。此時，我們將 $x$ 所有鄰邊砍掉、並且與所有 $y$ 的鄰居連邊（也就是說，$G_{\\text{新}}\\gets G_{\\text{舊}} -\\set{(x, x') \\ |\\ x'\\in \\Gamma(x)} \\cup \\set{(x, y') \\ |\\ y'\\in \\Gamma(y)}$）。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這個動作並不會減少極大完全子圖的數量。失去的極大完全子圖都是那些圖 $G_{\\text{舊}}$ 上面原本包含 $x$ 的極大完全子圖。而新增的極大完全子圖包含兩類："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"原圖上包含 $y$ 的極大完全子圖，只不過把 $y$ 換成 $x$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"「原本包含 $x$ 的極大完全子圖」的子圖，因為 $x$ 被去掉了所以變成了真正的極大完全子圖。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"但第一類至少有 $C_y$ 種，第二類至少有 $0$ 種。因此極大完全子圖的數量並不會減少。經過一連串調整之後，最後的圖會變成 $p$-分圖：整個點集合 $V$ 會被拆成若干集合 $V_1, V_2, \\ldots, V_p$，而每一個部份 $V_i$ 都是獨立集；除此之外對於任意 $i\\neq j$，$x\\in V_i, y\\in V_j$ 必定有連邊 $(x, y)\\in E$。不難得知這種時候的極大完全圖的數量是 $\\prod_i |V_i|$。而這個值在儘量分配每個部份都是 $3$ 個點的時候得到最大值（除了最後一部分可以是 2 個或 4 個點）。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"枚舉極大完全子圖"}]},{"type":"text","value":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"type":"element","tagName":"table","properties":{},"children":[{"type":"element","tagName":"thead","properties":{},"children":[{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"th","properties":{},"children":[{"type":"text","value":"演算法"}]},{"type":"element","tagName":"th","properties":{},"children":[{"type":"text","value":"複雜度"}]},{"type":"element","tagName":"th","properties":{},"children":[{"type":"text","value":"備註"}]}]}]},{"type":"element","tagName":"tbody","properties":{},"children":[{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"Bron-Kerbosch [1973]"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"很糟"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"會找到很多非極大完全子圖。"}]}]},{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"Tomita et al. [2006]"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(3^{n/3})$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"Bron-Kerbosch with pivot"}]}]},{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"Eppstein at al. [2010]"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(dn3^{d/3})$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$d$ 是 degeneracy"}]}]},{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"Tsukiyama [1977]"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(n(n^2-m)\\mu)$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$\\mu$ 是輸出的 maximal clique 數量。"}]}]},{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"Chiba and Nishizeki [1985]"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(a(G)m\\mu)$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$a(G)$ 是 arboricity of $G$。"}]}]},{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"Makino and Uno [2004]"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(\\Delta^4\\mu)$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$\\Delta=\\Delta(G)$。"}]}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"§7.2 Bron–Kerbosch 演算法"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"基本上就是個 DFS，只是在搜索過程中，我們維護三個點集合：$P, R, X$，代表我們目前欲探索的極大完全子圖，必須包含 $R$ 當中的所有點、可能包含 $P$ 當中的某些點、以及"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"不能"}]},{"type":"text","value":"包含 $X$ 中的任何一點。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Bron-Kerbosch with Pivot"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"theorem","properties":{"title":"時間複雜度分析 [Tomita et al. 2006, Eppstein et al. 2010]"},"children":[{"type":"text","value":"\n使用 Pivot 的 B-K 演算法滿足遞迴式 $$\nT(n) = \\max_k\\set{ kT(n-k) } + O(n^2), $$\n其中 $n=|P|$。\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h4","properties":{},"children":[{"type":"text","value":"證明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"令 $k=|P\\setminus \\Gamma(u)|$。\n如果挑選的 $u = \\arg\\max_{v\\in P\\cup X} |P\\cap \\Gamma(v)|$，那麼每一次遞迴呼叫保證有 $|P\\cap \\Gamma(v)|\\le n-k$。因此最壞情況下遞迴所需要的時間是 $\\max_k\\set{kT(n-k)}$。找出 Pivot 可以在 $O(n^2)$ 時間內完成。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"上面這個遞迴式解得 $T(n) = O(3^{n/3})$，剛好等於一個圖中可能的極大完全子圖的數量，非常湊巧。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"§7.3 找出一個最大完全子圖"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"列舉出所有極大完全子圖，就可以理所當然地找出最大的一個。但為了找出最大的完全子圖，不盡然需要列出所有極大完全子圖。也就是說，可能存在 worst-case 更快的演算法解決 Maximum Clique 問題。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"大部分的算法都是源自於 Tarjan and Trojanowski [1977] 找最大獨立集的演算法，加上繁複的 Case Analysis 得來的，我們將在下一節討論。"}]},{"type":"text","value":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"type":"element","tagName":"table","properties":{},"children":[{"type":"element","tagName":"thead","properties":{},"children":[{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"th","properties":{},"children":[{"type":"text","value":"演算法"}]},{"type":"element","tagName":"th","properties":{},"children":[{"type":"text","value":"複雜度"}]},{"type":"element","tagName":"th","properties":{},"children":[{"type":"text","value":"備註"}]}]}]},{"type":"element","tagName":"tbody","properties":{},"children":[{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"Bron-Kerbosch [1973]"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(1.4422^n)$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"列出所有極大完全子圖"}]}]},{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"Tarjan & Trojanowski [1977]"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$o(2^{n/3}) \\approx O(1.2599^n)$"}]},{"type":"element","tagName":"td","properties":{},"children":[]}]},{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"Jian [1986]"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(1.2346^n)$"}]},{"type":"element","tagName":"td","properties":{},"children":[]}]},{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"Robson [1986]"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(1.2108^n)$"}]},{"type":"element","tagName":"td","properties":{},"children":[]}]},{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"Robson [2001]"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(1.1888^n)$"}]},{"type":"element","tagName":"td","properties":{},"children":[]}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"參考資料"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"http://users.monash.edu.au/~davidwo/MoonMoser65.pdf"},"children":[{"type":"text","value":"http://users.monash.edu.au/~davidwo/MoonMoser65.pdf"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://www.sciencedirect.com/science/article/pii/S0304397506003586?via%3Dihub"},"children":[{"type":"text","value":"https://www.sciencedirect.com/science/article/pii/S0304397506003586?via%3Dihub"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://arxiv.org/pdf/1006.5440.pdf"},"children":[{"type":"text","value":"https://arxiv.org/pdf/1006.5440.pdf"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://www.ics.uci.edu/~goodrich/teach/graph/notes/Strash.pdf"},"children":[{"type":"text","value":"https://www.ics.uci.edu/~goodrich/teach/graph/notes/Strash.pdf"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"http://drops.dagstuhl.de/opus/volltexte/2018/8552/pdf/LIPIcs-IPEC-2017-27.pdf"},"children":[{"type":"text","value":"George Manoussakis, "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"An Output Sensitive Algorithm for Maximal Clique Enumeration in Sparse Graph"}]},{"type":"text","value":", 2018"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"習題"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"span","properties":{"className":["tag","is-link"]},"children":[{"type":"text","value":"演算法"}]},{"type":"text","value":" 給你圖 $G$ 的補圖 $\\overline{G}$。假設已知這個圖上有一個大小為 $2n/3$ 的 Clique，請你設計一個演算法找出任何一個大小為 $n/3$ 的 Clique。"}]},{"type":"text","value":"\n"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"圖論演算法 8 - 獨立集 Independent Sets","category":"algo","path":"/algo/algorithmic-graph-theory/independent-sets","date":"2019-03-06","description":null,"link":null,"code":null,"difficulty":null,"oj":null,"tags":null},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我們說圖 $G$ 上的一個點的子集合 $S\\subseteq V$ 是獨立集（Independent Set），若且唯若 $G[S]$ 沒有任何邊。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"透過直接的觀察可以得知，$S$ 在 $G$ 上是一個獨立集，等價於 $\\overline{G}[S]$ 是一個完全子圖，其中 $\\overline{G}$ 是 $G$ 的"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"補圖"}]},{"type":"text","value":"（Complement Graph）。從這個觀察也可以知道，如果我們要列舉出所有極大獨立集（Maximal Independent Set, MIS），那麼所有適用於前一節找 Maximal Clique 的演算法也通通都適用於此。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"相對應地，我們令 $\\alpha(G)$ 表示為圖 $G$ 上最大獨立集的大小。關於這個獨立集的大小，"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"§8.1 關於 $\\alpha(G)$ 的估計"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"theorem","properties":{"title":"哼哼"},"children":[{"type":"text","value":"\n對於所有的圖 $G=(V, E)$，都有：\n$$ \\alpha(G) \\ge \\sum_{v\\in V} \\frac{1}{\\deg(v) + 1} $$\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這個定理有個利用隨機演算法輕鬆證明的結論，它在平行與分散式計算上面找極大獨立集有非常顯著的應用，大家可以參考 "},{"type":"element","tagName":"a","properties":{"href":"http://www.cs.cmu.edu/afs/cs/academic/class/15750-s19/OldScribeNotes/lecture32.pdf"},"children":[{"type":"text","value":"CMU 的 Luby演算法講義"}]},{"type":"text","value":"。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"§8.2 找出最大獨立集"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"顯然枚舉所有點的子集合逐一檢查可以做到 $O(n^2 2^n)$、利用前一節列舉極大完全子圖所需要的時間為 $O(3^{n/3})\\approx O(1.4422^n)$。在此我們提供一個坊間謠傳的簡單暴搜方法："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果一個圖 $G$ 的最大度數 $\\Delta(G) \\le 2$，那麼顯然這個圖是由很多路徑和圈構成的。此時我們可以在多項式時間內找出最大獨立集。因此我們不妨假設所有遞迴中遇到的子問題，其最大度數都是 $\\ge 3$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"DFS 的方法如下：我們每次選取當前圖上度數最大的點 $v$，由於前面的假設我們知道 $\\deg(v) \\ge 3$。接下來，透過簡單的觀察可以知道：一個最大的獨立集要嘛包含 $v$ 但是不包含任何 $v$ 的鄰居 $\\Gamma(v)$（一個遞迴呼叫 $G-\\set{v}-\\Gamma(v)$）、要嘛就不包含 $v$（另一個遞迴呼叫 $G-\\set{v}$）。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"因此可以直接將時間複雜度的上界寫下來："}]},{"type":"text","value":"\n$$\nT(n) \\le T(n-1) + T(n-4) + \\text{poly}(n)\n$$\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"有一點點像 Master Theorem 的感覺，這類型的遞迴關係是有一些簡單的方法可以輕鬆推導出時間複雜度的。我們不妨假設有個實數常數 $c$ 使得 $T(n) = c^n$。只要 $c$ 滿足\n$c^3 + 1 < c^4$\n就可以讓上面的遞迴式成立了。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"透過解方程式，我們可以知道選取 $c\\approx 1.3803$ 能夠滿足條件。因此我們證得上述演算法時間複雜度為 $O(1.3803^n)$。把這個方法延伸，考慮更多的 case （度數 3, 4, 5 的點等等），就會得到 Tarjan [1977] 這篇論文的 $O(1.2599^n)$ 的上界。考慮更多更多更多的 case （度數 1~9 的點等等），再加上一些記憶化搜索的技巧就會得到 Robson [2001] 這篇論文的 $O(1.1888^n)$ 時間複雜度了。下面介紹兩個被用在 Robson 演算法裡面的加速技巧，這些技巧被廣泛應用在其他題目中，以後我們有機會碰到也會再次提及。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"加速技巧：Indirection"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"note","properties":{},"children":[{"type":"text","value":"\n當子問題大小（遞迴得到的誘導子圖點數）不超過 $\\delta n$ 的時候，可以直接用動態規劃紀錄下答案。\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"一個有 $n$ 個點的圖，其點數不超過 $\\delta n$ 的誘導子圖，數量不超過 ${n\\choose {\\delta n}}$ 個。使用 Strling's Formula 這個值算起來大概是 $\\left(\\frac{1}{\\delta^\\delta (1-\\delta)^{1-\\delta}}\\right)^n$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"假設最原始的圖有 $N$ 個點，把這個方法代入原本的遞迴式以後，所有的遞迴動作會在 $n < \\delta N$ 的時候中止。因此撇開動態規劃的時間不算，等效的遞迴時間複雜度是 $T(N-\\delta N) = c^{(1-\\delta)N}$。如果我們套用上面簡單演算法得到的 $c=1.3803$，我們可以隨意選取 $\\delta=0.09$，這樣時間複雜度可以變成 $O(\\max\\set{c^{0.91}, 1.3533}^N)$，得到效率的提升。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"把加速技巧加速：Memoization"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"note","properties":{},"children":[{"type":"text","value":"\n當點數 $\\le \\delta n$ 的子問題的所有的點**度數**夠小的時候，可以用動態規劃紀錄下答案。度數大的時候，遞迴式本身得到的解已經夠好了。\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"theorem","properties":{"title":"Fuss-Catalan Numbers [Robson 1985; Concrete Math]"},"children":[{"type":"text","value":"\n對於一個度數不超過 8 的圖 $G$，其包含 $\\delta n$ 個點的連通誘導子圖的數量不超過 $\\text{poly}(n)(7^76^{-6})^{\\delta n}$ 個。\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h4","properties":{},"children":[{"type":"text","value":"證明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"固定一個圖 $G$ 的"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"連通"}]},{"type":"text","value":"誘導子圖，我們可以從任意一個點出發，畫出一棵 BFS 樹。顯然不同的誘導子圖（點集合不同）會造出不同的 BFS 樹。所以誘導子圖 $\\leftrightarrow$ BFS 樹是一個一對多（1-to-many）的關係。只要我們給出所有這樣的 BFS 樹的數量上界，就能夠說明誘導子圖數量的上界。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"根據題目條件，每個點度數不超過 8。因此除了根節點以外，其他的點的子節點數量都不超過 7。根據 Fuss-Catalan 公式，這樣子的樹會有 $\\text{poly}(n){7n\\choose n}$ 左右。（註：可參考 OEIS "},{"type":"element","tagName":"a","properties":{"href":"http://oeis.org/A002296%EF%BC%89"},"children":[{"type":"text","value":"http://oeis.org/A002296）"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"上面這個定理要怎麼用來加速呢？如果我們只紀錄「點的總數不超過 $\\delta n$、並且該連通誘導子圖上所有點度數都不超過 8」的圖，那麼這樣的誘導子圖的總數不會超過 $\\text{poly}(n){{7\\delta n} \\choose {\\delta n}}\\approx \\text{poly}(n)(7^76^{-6})^{\\delta n}$。當 "},{"type":"element","tagName":"a","properties":{"href":"https://www.wolframalpha.com/input/?i=((7%5E7%2F(6%5E6))%5Ex)*(x%5Ex)*((1-x)%5E(1-x))+%3D+1"},"children":[{"type":"text","value":"$\\delta \\le  1/7$ 的時候"}]},{"type":"text","value":"，用這個方法會比第一種技巧需要的狀態總數來得少。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"存在度數超過 8 的點的時候怎麼辦？這時候只要用老樣子遞迴就行啦～$T(n) = T(n-1) + T(n-9) + \\text{poly}(n)$ 解出來大概是 $(1.2132)^n$，只要我們選擇的 $\\delta$ 不要太小，就可以讓 $(7^76^{-6})^{\\delta n}$ 這項大過這個時間複雜度。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"§8.3  習題"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"span","properties":{"className":["tag","is-dark"]},"children":[{"type":"text","value":"證明題"}]},{"type":"text","value":" 利用「度數為 2 的點可以忽略不計」這個觀察，證明上述演算法的另一種分析方式："}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n$$\nT(n) \\le \\begin{cases}\nT(n-1)+T(n-5) + \\text{poly}(n)\\\\\n2T(n-4)+ \\text{poly}(n)\n\\end{cases}\n$$\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"而得出 $T(n) = O(1.3247^n)$ 的結論。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{"start":2},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"span","properties":{"className":["tag","is-dark"]},"children":[{"type":"text","value":"思考題"}]},{"type":"text","value":" 解釋為什麼上述 DFS 方法找出最大獨立集的方法，沒辦法（在同樣時間複雜度情形下）「列舉」所有的極大獨立集。"}]},{"type":"text","value":"\n"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"圖論演算法 9 - 分割圖 Split Graph","category":"algo","path":"/algo/algorithmic-graph-theory/split-graph","date":"2019-03-10","description":null,"link":null,"code":null,"difficulty":null,"oj":null,"tags":null},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"若圖 $G$ 上面的點集合存在一種方法被拆成一個（可能為空的）完全子圖與一個（可能為空）的獨立集，那麼我們說圖 $G$ 是一個"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"分割圖"}]},{"type":"text","value":"（split graph）。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"§9.1 分割圖的辨認"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"theorem","properties":{},"children":[{"type":"text","value":"\nSplit graph can be recognized in linear time.\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這件事情可以透過觀察度序列來得知："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"theorem","properties":{},"children":[{"type":"text","value":"\n一個簡單圖 $G$ 是一個 split graph 若且唯若對於其度序列 $d_1\\ge d_2 \\ge \\cdots \\ge d_n$，存在一個正整數 $m$ 使得\n $$ \\sum_{i=1}^m d_i = m(m-1) + \\sum_{i=m+1}^n d_i $$\n這樣。\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"換句話說，度數大的點都會屬於完全子圖、而度數小的點都會屬於獨立集。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"§9.2 分割圖的性質"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"theorem","properties":{},"children":[{"type":"text","value":"\n分割圖的補圖也是分割圖。\n"}]},{"type":"text","value":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"type":"element","tagName":"table","properties":{},"children":[{"type":"element","tagName":"thead","properties":{},"children":[{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"th","properties":{},"children":[{"type":"text","value":"演算法問題"}]},{"type":"element","tagName":"th","properties":{},"children":[{"type":"text","value":"On Split Graphs"}]}]}]},{"type":"element","tagName":"tbody","properties":{},"children":[{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"Clique Number / 找出所有極大完全子圖"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"簡單"}]}]},{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"Chromatic Number / 圖著色"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"簡單"}]}]},{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"HamiltonianCycle"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$\\textsf{NP}$-complete"}]}]},{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"MinimumDominatingSet"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$\\textsf{NP}$-complete (從 SetCover reduce)"}]}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"§9.3 分割圖的計數"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"有標號的分割圖很簡單，這個大家自己算就可以了。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"無標號的分割圖 (non-isomorphic)"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"無標號分割圖的數量，在 2000 年由 UWA 西澳大學數學統計系的 Gordon Royle 教授提出了一個「$n$ 個點的分割圖」與「$n$ 個物件的非同構極小覆蓋集合」之間的一對一對應關係。所謂的極小覆蓋集合，就是考慮若干非空集合 $S_1, \\ldots, S_k \\subseteq [n]$，它們聯集包含所有 $[n]=\\{1, 2, \\ldots, n\\}$，但拿掉任何一個集合都湊不齊 $[n]$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"關於將 $n$ 個物件使用 $k$ 個集合最小覆蓋的方法數，已由當年在阿德萊德大學現在在澳洲伍倫貢大學的 Rodney J. Clarke 教授在 "},{"type":"element","tagName":"a","properties":{"href":"https://www.sciencedirect.com/science/article/pii/0012365X90901469"},"children":[{"type":"text","value":"1990"}]},{"type":"text","value":" 年寫下其公式："}]},{"type":"text","value":"\n$$\nt(n, k) = \\frac{1}{n!k!}\\sum_{\\alpha\\in \\mathcal{P}_n, \\beta\\in\\mathcal{P}_k} {n\\choose \\alpha}{k\\choose \\beta} \\prod_i \\left(\\left(\n    \\prod_{j} 2^{\\gcd(\\alpha_i, \\beta_j)}\\right) - 1\n    \\right)\n$$\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"有興趣的朋友可以直接從 "},{"type":"element","tagName":"a","properties":{"href":"https://oeis.org/A048194"},"children":[{"type":"text","value":"OEIS A048194"}]},{"type":"text","value":" 查看 Split Graph 的計數。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"練習題"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"span","properties":{"className":["tag","is-danger"]},"children":[{"type":"text","value":"程設題"}]},{"type":"text","value":" "},{"type":"element","tagName":"a","properties":{"href":"https://www.urionlinejudge.com.br/repository/UOJ_1974_en.html"},"children":[{"type":"text","value":"[UOJ 1974] Into Darkness"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"span","properties":{"className":["tag","is-danger"]},"children":[{"type":"text","value":"程設題"}]},{"type":"text","value":" "},{"type":"element","tagName":"a","properties":{"href":"https://main.mimuw.edu.pl/en/archive/oi/18/kon"},"children":[{"type":"text","value":"[POI 18 Stage 1] Conspiracy"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"span","properties":{"className":["tag","is-danger"]},"children":[{"type":"text","value":"程設題"}]},{"type":"text","value":" "},{"type":"element","tagName":"a","properties":{"href":"https://naipc18.kattis.com/problems/doubleclique"},"children":[{"type":"text","value":"[NAIPC 2018 pB] Double Clique"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"span","properties":{"className":["tag","is-dark"]},"children":[{"type":"text","value":"證明題"}]},{"type":"text","value":" 證明圖 $G$ 是分割圖若且唯若 $G$ 與 $\\overline{G}$ 都是弦圖(Chordal)。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考資料"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://arxiv.org/pdf/1805.03405.pdf"},"children":[{"type":"text","value":"https://arxiv.org/pdf/1805.03405.pdf"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"http://www.emis.ams.org/journals/JIS/VOL3/ROYLE/royle.pdf"},"children":[{"type":"text","value":"http://www.emis.ams.org/journals/JIS/VOL3/ROYLE/royle.pdf"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://www.sciencedirect.com/science/article/pii/0020019084901261"},"children":[{"type":"text","value":"Bertossi, "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"Dominating sets for split and bipartite graphs"}]},{"type":"text","value":", IPL 1984."}]}]},{"type":"text","value":"\n"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"SnackDown19 Elimination Round","category":"cp","path":"/cp/snckel19","date":"2018-12-08","description":null,"link":"https://www.codechef.com/SNCKEL19","code":null,"difficulty":null,"oj":null,"tags":null},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"唉唉，今天狀況超級不對啊。整個就是撞牆卡在 Suffix Palindrome 完全寫不出來，然後到了快三個半鐘頭才想到 Lighting Rectangle 要怎麼寫，還錯了一次，真是奇慘無比。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Lighting Rectangle "},{"type":"element","tagName":"a","properties":{"href":"https://www.codechef.com/SNCKEL19/problems/RECTLIT"},"children":[{"type":"text","value":"RECTLIT"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"theorem","properties":{"c":"is-info"},"children":[{"type":"text","value":"\n在一個二維座標平面上有一個 $(0, 0)$ 到 $(N-1, N-1)$ 的正方形。在這個正方形區域內有 $K$ 盞燈。對於每一盞燈而言，這盞燈為原點可以把整個平面分成四個象限。而你可以為每一盞燈選擇照亮其中一個象限（在邊界上也算是有被照亮）。現在給你這 $K$ 盞燈的位置，是否存在一種方法，讓它們可以照亮整個正方形的範圍呢？\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"簡單來說就是分 Case 題："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"在內部如果有四個點，那麼存在一種方式可以照亮所有區域。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"如果角落有一個點，那麼一定可以照亮所有區域。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"把邊分成上下、跟左右兩個部份。如果其中一個部份有兩個點，那可以照亮所有區域。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"如果邊上有一個點、而且內部有至少兩個點，那麼可以照亮所有區域。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"如果邊上有兩個點、而且內部至少有一個點，那麼可以照亮所有區域。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"除了以上情形外，其他情形都無法照亮所有區域。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"style","properties":{},"children":[{"type":"text","value":"\n#outer-rect {\n     stroke-width: 4;\n}\n.blue.quadrant.region {\n    fill: rgba(0,0,255,0.3);\n}\n.blue.quadrant.origin {\n    fill: blue;\n}\n.blue.quadrant.boundary.start,\n.blue.quadrant.boundary.end {\n    stroke-width: 2;\n    stroke: rgba(0,0,255,0.6);\n}\n.red.quadrant.region {\n    fill: rgba(255, 0, 0, 0.3);\n}\n.red.quadrant.origin {\n    fill: darkred;\n}\n.red.quadrant.boundary.start,\n.red.quadrant.boundary.end {\n    stroke-width: 2;\n    stroke: rgba(200,0,0,0.6);\n}\n.yellow.quadrant.region {\n    fill: rgba(255, 255, 0, 0.3);\n}\n.yellow.quadrant.origin {\n    fill: gold;\n}\n.yellow.quadrant.boundary.start,\n.yellow.quadrant.boundary.end {\n    stroke-width: 2;\n    stroke: rgba(233,233,0,0.6);\n}\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"mysvg","properties":{"width":300,"height":200,"viewbox":"-10 -10 330 230"},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"rect","properties":{"x":"0","y":"0","width":300,"height":200,"fill":"none","stroke":"black","id":"outer-rect"},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"display-inner","properties":{"quadrant":"","dot-at-origin":"","x":"90","y":"70","r":"600","angle-start":"0","angle-end":"90","boundary-at-start":"","boundary-at-end":"","c":"blue","clip-href":"#outer-rect"},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"display-inner","properties":{"quadrant":"","dot-at-origin":"","x":"160","y":"120","r":"600","angle-start":"270","angle-end":"360","boundary-at-start":"","boundary-at-end":"","c":"red","clip-href":"#outer-rect"},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"display-inner","properties":{"quadrant":"","dot-at-origin":"","x":"185","y":"90","r":"600","angle-start":"180","angle-end":"270","boundary-at-start":"","boundary-at-end":"","c":"yellow","clip-href":"#outer-rect"},"children":[]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"// by tmt514\n#include <cstdio>\nusing namespace std;\n\nvoid solve() {\n  int K, N;\n  scanf(\"%d%d\", &K, &N);\n  int ncorner = 0;\n  int nsidex = 0;\n  int nsidey = 0;\n  int ninside = 0;\n  for(int i=0;i<K;i++) {\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    int sx = (x==0 || x==N-1);\n    int sy = (y==0 || y==N-1);\n    if(sx && sy) { ncorner++; }\n    else if(sx) { nsidex++; }\n    else if(sy) { nsidey++; }\n    else ninside++;\n  }\n  if (ncorner==0 && nsidex==1 && nsidey==1 && ninside==0) puts(\"no\");\n  else\n  puts(4*ncorner + 2*nsidex + 2*nsidey + ninside >= 4? \"yes\": \"no\");\n}\n\nint main(void) {\n  int T;\n  scanf(\"%d\", &T);\n  while(T--) solve();\n  return 0;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Suffix Palindromes "},{"type":"element","tagName":"a","properties":{"href":"https://www.codechef.com/SNCKEL19/problems/SFXPAL"},"children":[{"type":"text","value":"SFXPAL"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"theorem","properties":{"c":"is-info"},"children":[{"type":"text","value":"\n考慮大小恰好為 $S$ 的字母集。請問有多少長度為 $N$ 的字串，其所有後綴字串都不是迴文？輸出答案除以 $M$ 的餘數。($1\\le N\\le 1000, 1\\le S\\le M-1 < 2^{30}-1$)\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這是一道很漂亮的 DP 題。假設 $f(n)$ 是答案，那麼每個字串的最後 $n-1$ 個字元都會被算入 $f(n-1)$。所以我們可以嘗試扣除掉加了一個字元以後會變成迴文的可能情形。而利用迴文的特性，我們可以證明在「加了一個字以後變成迴文」的當下，所有可能的迴文只能是來自 $f(\\lceil n/2\\rceil)$。所以，可以從 $f(1)=S$ 開始，依序計算 $f(n) = Sf(n-1) - f(\\lceil n/2\\rceil)$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"display","properties":{"array":"","data":"[\"S\", \"---------f(n-1) 之中的答案---------\"]"},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"display","properties":{"array":"","data":"[\"--反過來的 f(n/2)--\", \"------f(n/2)------\"]"},"children":[]},{"type":"text","value":"    "}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"// by tmt514\n#include <iostream>\n#include <vector>\nusing namespace std;\ntypedef long long LL;\n\nint main(void) {\n  LL N, S, M;\n  cin >> N >> S >> M;\n  vector<LL> dp(N+1);\n  dp[0] = 1;\n  dp[1] = S;\n  for (int i = 2; i <= N; i++) {\n    dp[i] = S*dp[i-1] - dp[(i+1)/2];\n    dp[i] = (dp[i]%M+M)%M;\n  }\n  cout << dp[N] << endl;\n  return 0;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Adi and the Tree "},{"type":"element","tagName":"a","properties":{"href":"https://www.codechef.com/SNCKEL19/problems/ADITREE"},"children":[{"type":"text","value":"ADITREE"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"theorem","properties":{"c":"is-info"},"children":[{"type":"text","value":"\n在一個有 $N$ 個節點的樹上，進行 $M$ 項操作。一開始所有的節點都是「關燈」的狀態。每一次操作會給你兩個點 $a, b$。然後你把點 $a$ 與點 $b$ 切換其「開/關燈」狀態。接著，每一個操作結束之後，請你幫所有亮著的燈的節點兩兩配成一對，使得配對的節點距離總和最小。每次操作後，都輸出配對後的最小總和。$(1\\le N, M\\le 250000)$\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"另一個乾淨的漂亮問題。這題的主要觀察點在於：最小的距離總和，恰好等於所有「子樹中有奇數個亮燈」節點的數量。所以我們只需要維護一個資料結構，使得每次更新兩個點後，順便更新節點的奇偶性就行了！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"要怎麼動態更新節點的奇偶性呢？我們可以利用樹鍊剖分，把一棵樹分成許多路徑，使得任何一個節點到樹根的路上至多只跨越 $O(\\log N)$ 條路徑。我們在每一條路徑上面維護一個線段樹，因此總時間複雜度是 $O(N+M\\log^2 N)$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"// by tmt514\n#include <algorithm>\n#include <cstdio>\n#include <vector>\nusing namespace std;\n\nstruct SegNode {\n  int odd, even;\n  bool inverted;\n};\n\nclass SegmentTree {\n  public:\n    vector<SegNode> seg;\n    void init(int x, int l, int r) {\n      if (l == r) seg[x] = (SegNode){0, 1, false};\n      else {\n        int m = (l+r)/2;\n        init(x*2, l, m);\n        init(x*2+1, m+1, r);\n        seg[x] = (SegNode){0, r-l+1, false};\n      }\n    }\n    void init(int n) {\n      seg.resize(4*n);\n      init(1, 1, n);\n    }\n    void push(int x, int l, int r) {\n      if (l == r) { seg[x].inverted = false; }\n      else if (seg[x].inverted) {\n        swap(seg[x*2].odd, seg[x*2].even);\n        swap(seg[x*2+1].odd, seg[x*2+1].even);\n        seg[x*2].inverted ^= 1;\n        seg[x*2+1].inverted ^= 1;\n        seg[x].inverted = false;\n      }\n    }\n    void pull(int x) {\n      seg[x].odd = seg[x*2].odd + seg[x*2+1].odd;\n      seg[x].even = seg[x*2].even + seg[x*2+1].even;\n      if (seg[x].inverted) swap(seg[x].odd, seg[x].even);\n    }\n    void toggle(int x, int l, int r, int target) {\n      if (r <= target) {\n        swap(seg[x].odd, seg[x].even);\n        seg[x].inverted ^= 1;\n      } else {\n        int m = (l+r)/2;\n        push(x, l, r);\n        toggle(x*2, l, m, target);\n        if (target > m) toggle(x*2+1, m+1, r, target);\n        pull(x);\n      }\n    }\n    int ask(int x, int l, int r, int target) {\n      if (r <= target) {\n        return seg[x].odd;\n      } else {\n        int m = (l+r)/2;\n        push(x, l, r);\n        return seg[x*2].odd + ask(x*2+1, m+1, r, target);\n      }\n    }\n};\n\nconst int N = 250000;\nvector<int> a[N];\n\nint total_odd[N];\nint parent[N];\nint depth[N];\nint child[N];\nint segtree_idx[N];\nint segtree_seq[N];\nSegmentTree t[N];\nint segtree_root[N];\n\nvoid find_depth_dfs(int x, int p=-1) {\n  parent[x] = p;\n  depth[x] = 1;\n  for(auto y : a[x]) {\n    if (y != p) {\n      find_depth_dfs(y, x);\n      if(depth[y]+1 > depth[x]) {\n        depth[x] = depth[y]+1;\n        child[x] = y;\n      }\n    }\n  }\n}\n\nint all_segids = 0;\nvoid build_segment_tree(int x, int segid=0, int d=1) {\n  segtree_idx[x] = segid;\n  segtree_seq[x] = d;\n  if (d == 1) {\n    segtree_root[segid] = x;\n    t[segid].init(depth[x]);\n  }\n  for (auto y : a[x]) {\n    if (y == parent[x]) continue;\n    if (y == child[x]) build_segment_tree(y, segid, d+1);\n    else {\n      all_segids++;\n      build_segment_tree(y, all_segids, 1);\n    }\n  }\n}\n\n// 找出修改狀態時會經過的每一條鍊，我們把每一條鍊的進入點蒐集起來。\nvoid toggle(int x) {\n  vector<int> tree_ids;\n  int c = x;\n  while (c != -1) {\n    tree_ids.push_back(c);\n    c = parent[segtree_root[segtree_idx[c]]];\n  }\n  int delta = 0;\n  for (auto c : tree_ids) {\n    auto& tree = t[segtree_idx[c]];\n    delta -= tree.seg[1].odd;\n    tree.toggle(1, 1, depth[segtree_root[segtree_idx[c]]], segtree_seq[c]);\n    delta += tree.seg[1].odd;\n    total_odd[segtree_root[segtree_idx[c]]] += delta;\n  }\n}\n\nint main(void) {\n  int n, m;\n  // 處理第一部份的輸入：紀錄整棵樹的訊息。\n  scanf(\"%d\", &n);\n  for(int i=0;i<n-1;i++) {\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    a[x].push_back(y);\n    a[y].push_back(x);\n  }\n  // 用 DFS 連結每個節點至高度最高的子節點。\n  find_depth_dfs(1);\n  \n  // 對於每一條鍊，初始化一個相應大小的線段樹。\n  build_segment_tree(1);\n\n  // 處理第二部分輸入：對於一次輸入的兩個點 A, B，改變其燈號狀態。\n  scanf(\"%d\", &m);\n  while(m--) {\n    int A, B;\n    scanf(\"%d%d\", &A, &B);\n    toggle(A);\n    toggle(B);\n    printf(\"%d\\n\", total_odd[1]);\n  }\n\n  return 0;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"其他推薦題解"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://blog.csdn.net/qq_39972971/article/details/84922322"},"children":[{"type":"text","value":"cz_xuyixuan 博客"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Recover Square "},{"type":"element","tagName":"a","properties":{"href":"https://www.codechef.com/SNCKEL19/problems/RECOVER"},"children":[{"type":"text","value":"RECOVER"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"theorem","properties":{"c":"is-info"},"children":[{"type":"text","value":"\n在一個 $N\\times N$ 大小的網格中，每一格恰有一個不同的、介於 $1$ 到 $N\\cdot N$ 的數字。如果我們把"},{"type":"element","tagName":"b","properties":{},"children":[{"type":"text","value":"所有"}]},{"type":"text","value":"曼哈頓距離是 $1$ 或 $2$ 的格子對寫下來（總共有 $M$ 個這樣的配對），請問你是否能回溯出原本的網格？($1\\le N\\le 200$，一個輸入檔中有 $1\\le T\\le 200$ 筆測試資料。)\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"感覺就是從角落用拼拼圖的方式一個一個把它拼起來。可能有點麻煩就是了..."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Adi and the Matrix "},{"type":"element","tagName":"a","properties":{"href":"https://www.codechef.com/SNCKEL19/problems/ADIMAT"},"children":[{"type":"text","value":"ADIMAT"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"theorem","properties":{"c":"is-info"},"children":[{"type":"text","value":"\n對於兩個矩陣而言，若重排一些行、然後再重排一些列之後變成相等的矩陣，那我們就說這兩個矩陣同構。請問有多少種大小為 $2^{N\\times M}$ 的不同構 0/1-矩陣？輸出答案除以 $10^9+7$ 的餘數。($1\\le N\\times M\\le 550$)\n"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"Orthogonal Vectors","category":"prob","path":"/problem/orthogonal-vectors","date":null,"description":"Given two sets $A, B\\subseteq \\set{0, 1}^d$, where $|A|=|B|=N$ and $d=\\Theta(\\log N)$. Then there exists $a\\in A$ and $b\\in B$ so that $\\langle a, b\\rangle = 0$.\n","link":null,"code":"OV","difficulty":null,"oj":null,"tags":null},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"[CF233B] Non-square Equation","category":"prob","path":"/problem/cf/241/C","date":null,"description":"有一個長 $10^5$ 公分、高 $100$ 公分的木頭箱子，箱子下方與上方各有一些水平擺放的鏡子、以及箱子左右兩端分別有一個可以讓光線進入的小孔，分別在高度 $h_l$ 以及 $h_r$ 公分處。下面的圖表示了箱子的情形：\n\n![](https://codeforces.com/predownloaded/58/b3/58b3e544e19da6e84c3667e027ccef48dd955657.png)\n\n在遊戲中，你必須要從左方的小孔中發射一束雷射光，然後讓這束光從右方小孔鑽出。每一面鏡子都有一個分數 ，若射中該面鏡子，則得到對應之分數。為了增加遊戲的趣味性，規定**雷射光只能打到每一面鏡子至多一次**。請找出最高的可能得分。鏡子數 $0\\le n\\le 100$。保證輸入的鏡子位置彼此不會重疊。\n","link":"https://codeforces.com/problemset/problem/241/C","code":"CF241C","difficulty":null,"oj":"codeforces","tags":null},"htmlAst":{"type":"root","children":[],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"[CF233B] Non-square Equation","category":"prob","path":"/problem/cf/233/B","date":null,"description":"對於正整數 $x$，我們定義 $s(x)$ 為其十進制表示法的各位數字和。現在給定 $n$ $(1\\le n\\le 10^{18})$，請你找出滿足下列方程 $$x^2+s(x)\\cdot x = n$$ 的最小正整數解 $x$ 或指出解不存在。\n","link":"https://codeforces.com/problemset/problem/233/B","code":"CF233B","difficulty":null,"oj":"codeforces","tags":null},"htmlAst":{"type":"root","children":[],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"[CF911C] Three Garlands","category":"prob","path":"/problem/cf/911/C","date":null,"description":"Mishka 買了三個聖誕樹的裝飾燈品，第 $i$ 個燈從開啟的那一剎那每間隔 $k_i$ 秒就會亮燈一下 $(1\\le k_i\\le 1500)$。Mishka 想知道是否存在三個開啟燈泡的時間 $x_1, x_2, x_3$，使得三個燈都打開以後，每一秒鐘都至少有一個燈泡亮著？\n","link":"https://codeforces.com/problemset/problem/911/C","code":"CF911C","difficulty":null,"oj":"codeforces","tags":null},"htmlAst":{"type":"root","children":[],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"找出鍊結串列的循環節","category":"guide","path":"/leetcode-guide/find-linked-list-cycle","date":"2019-05-08","description":null,"link":null,"code":null,"difficulty":null,"oj":null,"tags":null},"htmlAst":{"type":"root","children":[],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"[CF217B] Blackboard Fibonacci","category":"prob","path":"/problem/cf/217/B","date":null,"description":"費氏數列的定義為 $f_0=0, f_1=1, f_n=f_{n-2}+f_{n-1}$。Bajtek 發明了一種在黑板上計算費氏數列的方法：首先在黑板寫下數字 $0$，然後在它下面緊接著寫下數字 $1$。接著，每一次他進行下列其中之一的操作：\n\n* 操作 `T`：把上面的數字擦去，並換成兩個數字的總和。\n* 操作 `B`：把下面的數字擦去，並換成兩個數字的總和。\n\n如果一切順利，進行了 $n$ 次操作而且從 `T` 開始，將兩種操作交錯進行，那麼最後寫到黑板的數字就會是 $f_{n+1}$。\n\n問題是，Bajtek 在進行操作的時候，常常不小心重複了同一種操作許多次。例如，如果 $n=6$，原本應該要進行的操作順序是 `TBTBTB`，但如果 Bajtek 進行的操作是 `TTTBBT`，那麼會得到 $10$ 這個數字。我們定義「出錯的次數」為序列中該次操作與前一次操作相同的次數。即 `TT` 或 `BB` 出現的總次數。\n\n現在，已知 Bajtek 經過了恰好 $n$ 次操作後計算出了 $r$ 這個數字。請找出「出錯的次數」最少的操作序列，或者輸出無解。$(1\\le n, r\\le 10^6)$\n","link":"https://codeforces.com/problemset/problem/217/B","code":"CF217B","difficulty":null,"oj":"codeforces","tags":null},"htmlAst":{"type":"root","children":[],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"鏈結串列 Linked Lists","category":"guide","path":"/leetcode-guide/linked-lists","date":"2018-12-21","description":null,"link":null,"code":null,"difficulty":null,"oj":null,"tags":null},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Linked list 是一種資料結構，它利用了指標，讓在記憶體內距離很遠的資料也可以連結起來。根據每一個節點可以連結到的其他節點，大致可以分成以下兩種類型："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Singly Linked List"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"display","properties":{"linked-list":"","data":"[\"value: 1\", \"value: 2\", \"value: 3\"]"},"children":[{"type":"text","value":"\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"typedef struct Node {\n    int value;\n    Node* next;\n};\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Doubly Linked List"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"display","properties":{"linked-list":"","double":"","data":"[\"node 1\", \"node 2\", \"node 3\", \"node 4\", \"node 5\"]"},"children":[{"type":"text","value":"\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"typedef struct Node {\n    Node* prev;\n    int value;\n    Node* next;\n};\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"每一個 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"struct"}]},{"type":"text","value":" 在記憶體中會是連續的一塊空間。一般來說，我們會額外儲存一個指標 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"head"}]},{"type":"text","value":" 指向這個鏈結串列的開頭（不然就沒辦法存取了）。進行大部分的操作都是從這個 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"head"}]},{"type":"text","value":" 開始。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"theorem","properties":{"c":"is-link"},"children":[{"type":"text","value":"\n除此之外還有**環狀鏈結串列**（Circular Linked Lists）等資料結構。\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"常見的鏈結串列操作"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"就地插入 Insertion"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"給定目前節點所在指標 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"node"}]},{"type":"text","value":"，想要在該節點後方插入一個新的資料 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"new_node"}]},{"type":"text","value":"。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"就地刪除 Deletion"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"給定目前節點所在指標 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"node"}]},{"type":"text","value":"，想要刪除該節點後方的資料（非 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"node"}]},{"type":"text","value":" 本身）。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"搜尋 Search"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"給定開頭指標 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"head"}]},{"type":"text","value":" 以及目標資料 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"target"}]},{"type":"text","value":"，判斷資料是否出現在任何節點上面。"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"關於資料結構 Data Structures","category":"guide","path":"/leetcode-guide/what-is-data-structure","date":"2018-02-06","description":null,"link":null,"code":null,"difficulty":null,"oj":null,"tags":null},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"資料結構"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"資料結構是指資料被儲存在電腦（一般是指記憶體）裡面的方式。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"資料結構設計"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"先有待解決的問題、然後思考怎樣的資料結構能夠支援解決該問題的演算法。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"抽象化資料結構 Abstract Data Type"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"把一些常見的模式記錄下來，在設計演算法的時候也能夠派上用場。\n資料結構抽象化的意義，在於能夠把一個資料結構可以支援的操作列出，而不用在意底層實作的細節。我們甚至可以根據演算法的實際需求，決定要如何實作相關的操作。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://i.imgur.com/VuRAGES.png","alt":"Imgur"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"學習資料結構的目的"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"了解當初發展這些資料結構的目的為何。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"這些資料結構有哪些應用。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"這些資料結構底層的實作方式。"}]},{"type":"text","value":"\n"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"[LC326] Power of Three","category":"prob","path":"/problem/leetcode/326","date":null,"description":"給定一個整數 $x$，若這個整數是 3 的次方則回傳 `true`，否則回傳 `false`。\n","link":"https://leetcode.com/problems/power-of-three/","code":"LC326","difficulty":null,"oj":"leetcode","tags":null},"htmlAst":{"type":"root","children":[],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"[LC19] Remove Nth Node From End of List","category":"guide prob","path":"/problem/leetcode/19","date":null,"description":"給定一個鏈結串列，移除倒數第 $n$ 個節點，並回傳鏈結串列的頭。\n","link":"https://leetcode.com/problems/remove-nth-node-from-end-of-list/","code":"LC19","difficulty":null,"oj":"leetcode","tags":null},"htmlAst":{"type":"root","children":[],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"[LC206] Reverse Linked List","category":"guide prob","path":"/problem/leetcode/206","date":null,"description":"反轉給定的鍊結串列。\n","link":"https://leetcode.com/problems/reverse-linked-list/","code":"LC206","difficulty":null,"oj":"leetcode","tags":null},"htmlAst":{"type":"root","children":[],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"[TIOJ 1011] Edit Distance In Numbers","category":"my-problem","path":"/cp/tioj/1011","date":"2018-11-23","description":"對於字串來說，Edit Distance是一個著名的DP問題。現在我們把這個問題弄得簡單一點，例如：把字串換成數字。對於一個數字$A$，我們想要藉由某些操作換成數字$B$。而對於整數$K$的一個合法的操作包括以下三種情形：\n\n* 乘以 $2$ 加 $1$，即 $K=2K+1$\n* 乘以 $2$，即 $K=2K$\n* 除以 $2$，即 $K=\\lfloor K/2\\rfloor$\n\n給定整數 $A$ 和 $B$，請你求出最小的操作次數 $N$使得從 $A$ 開始操作 $N$ 次可以換成 $B$。\n","link":"https://tioj.ck.tp.edu.tw/problems/1011","code":null,"difficulty":1,"oj":"TIOJ","tags":null},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"題目敘述"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"包含兩個數字 $A, B$ ($0 \\leq A, B \\leq 2^{31}$)。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸出說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"請輸出最小操作次數 $N$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Sample Input"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"17\n15\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Sample Output"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"7\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"出處"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"95建中資訊培訓模擬試題一（Prob 3）"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ連結"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://tioj.ck.tp.edu.tw/problems/1011"},"children":[{"type":"text","value":"TIOJ 1011 - Edit Distance In Numbers"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"題解"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"把輸入的數字表示成二進位以後，所有的操作都會變成在當前的二進位字串後面加上一位數、或刪除一位數。考慮 $A$ 和 $B$ 的二進位值之後，他們的最長共同前綴（Longest Common Prefix）$S$，而最佳解就會是一路把 $A$ 除到變成 $S$，然後再一路加上末尾的位元變成 $B$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"要把數字轉換成二進位的字串、再找出他們的最長共同前綴是一件好像有點麻煩的事情（雖然也不是太麻煩）。我們可以把「加上末尾的位元變成 $B$」的步驟反過來，變成從 $B$ 開始逐一刪除末尾的 0。這樣可以得到一個單純的演算法，重複比較 $A$ 和 $B$ 誰比較大，比較大的數字除以 2，直到相同為止。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"/* by tmt514 */\n#include <iostream>\nusing namespace std;\n\nint main() {\n    int A, B, ans = 0;\n    cin >> A >> B;\n    while (A != B) {\n        (A > B? A : B) /= 2;\n        ++ans;\n    }\n    cout << ans << endl;\n    return 0;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"關於這題"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這題的概念是二進位思考，如果把輸入的數字用不同的表示方法（比方說二進位）表示出來，那麼看似麻煩的操作就會變得很直觀。"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"圖論演算法 1 - 計算理論","category":"algo","path":"/algo/algorithmic-graph-theory/computational-problem","date":"2019-02-10","description":null,"link":null,"code":null,"difficulty":null,"oj":null,"tags":null},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"§1.1 計算模型"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"什麼是計算機？我們當然可以含糊地說目前我們看到的電腦都是計算機、或是說只要可以跑程式寫扣解題的都是計算機。但這種說法是很不嚴謹的。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"西元 1936 年是個計算理論發祥的年代。同一年間先後由 Alan Turing 提出 A-Machine (就是大家後來稱之為圖靈機的東西）以及 Alonzo Church 發表了 $\\Lambda$-演算。這些計算模型的共通點都是，它明確定義了「單位時間」可以作哪些事情。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"當數學家們在討論這幾種計算模型誰比較強（能夠解比較多的問題）的時候，Church 和 Turing 證明了他們各自的計算模型計算能力是等價的（而且也等價於另一類可以用遞迴方式計算的 "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"general recursive"}]},{"type":"text","value":" 函數）。因此，著名的 Church-Turing Thesis 描述的就是：我們能假設任何可以計算的函數，都可以藉由定義在 Turing Mahcine 上的演算法實作出來。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"note","properties":{},"children":[{"type":"text","value":"「演算法」是定義在「計算模型」之上。\n而「可計算的函數」其實是一個抽象的概念，我們無法明確定義它。\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"值得一提的是，目前現實世界中的電腦，使用的是隨機存取模型（RAM Model），它已知與 Turing Machine 的計算能力是相同的。我們不需要擔心有些問題在目前的電腦上解不出來、但是在圖靈機上面可解。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"一旦決定了計算模型以後，衡量演算法的執行效率，就可以被這個計算模型的「單位時間操作」決定。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"§1.2 問題的類型"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"計算問題"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"什麼是計算問題？只要「可能可以用電腦解決的問題」都被稱作計算問題。這個定義相當不嚴謹，而且好像什麼都沒講，超級賴皮。但很幸運的是，在這一系列筆記當中，我們只需要關心比較務實一點點的、可以被我們定義下來的計算問題。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"在我們的宇宙觀(?)裡面，一個計算問題通常會包含一個"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"有限長度的輸入"}]},{"type":"text","value":"、以及一個明確的"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"輸出目標"}]},{"type":"text","value":"敘述。我們可以對於這個把常見的計算問題類型作一些分類："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"決策性問題"}]},{"type":"text","value":"(Decision Problem)：輸出的格式一律是 yes 或 no，而且對於一個輸入，問題的內容會保證恰好其中一者是正確的輸出。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"搜索問題"}]},{"type":"text","value":"(Search Problem)：題目的內容通常是一個條件，只要輸出任何一個滿足條件的解就行了。（請注意，"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"無解"}]},{"type":"text","value":"也可以是輸出的一種。）"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"計數問題"}]},{"type":"text","value":"(Counting Problem)：題目的內容仍然是一個條件，但是必須要輸出有多少滿足條件的解。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"最佳化問題"}]},{"type":"text","value":"(Optimization Problem)：題目的內容包含一個條件和一個目標函數(Objective function)，輸出的解必須要同時滿足條件、並且在該目標函數下優於所有其他滿足條件的解。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"承諾問題"}]},{"type":"text","value":"(Promise Problem)：這個是針對輸入的內容進行合理假設的一類問題。對於大多數的計算問題我們可以假設輸入的內容是任意的（或者可以說是任意有限長度的 0-1 字串 $\\{0, 1\\}^*$）。承諾問題通常會附上我們關心的「合法輸入範圍」，解決該問題的演算法沒有責任判斷輸入是否合法，也就是說，在這個合法範圍外的輸入，不管回答是什麼都被視為正確的。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"note","properties":{},"children":[{"type":"text","value":"大部分的問題可以轉化（Reduce）成決策性問題。而大部分關於計算理論的研究也都專注於決策性問題，比方說著名的 $\\mathsf{P}=\\!\\!\\!\\!?\\,\\,\\mathsf{NP}$ 問題，關注的就是兩個「由一些決策性問題組成的集合 $\\mathsf{P}$、$\\mathsf{NP}$」看看他們是否相等。\n"}]}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"圖論演算法 4 - 度序列 Degree Sequences","category":"algo","path":"/algo/algorithmic-graph-theory/degree-sequence","date":"2019-02-20","description":null,"link":null,"code":null,"difficulty":null,"oj":null,"tags":null},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"§4.1 度序列的定義"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"對於一個無向圖 $G$ 來說，我們可以把所有點的度數 $\\deg(v)$ 蒐集起來，而這樣的序列被稱為"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"度序列"}]},{"type":"text","value":"(degree sequence)。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"從演算法的角度來說，許多與次線性時間演算法（sublinear time algorithms）相關的研究，其計算模型都會假設：我們總是可以在 $O(1)$ 時間查詢一個點的度數。這對於一些估計與近似演算法具有相當的幫助。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"§4.2 握手定理"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"握手定理精確地描述了邊數與度數之間的關聯。為什麼叫做握手定理呢？如果我們把一次聚會上任何兩個人握手的情形都畫一條邊把這兩個人連起來，那麼總握手次數的兩倍就會恰好等於每個人握手次數總和。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"theorem","properties":{"title":"定理（握手定理）"},"children":[{"type":"text","value":"\n$\\sum_{v\\in V} \\deg(v) = 2|E|$.\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"備註"}]},{"type":"text","value":"：在已知 $\\sum \\deg(v)$ 為定值的情形下，考慮 $\\sum (\\deg(v))^2$ 的最大值和最小值是個很經典的代數問題呢。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"§4.3 圖上的三角形"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我們定義圖上的"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"三角形"}]},{"type":"text","value":"為圖 $G$ 的 $K_3$ 子圖。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Triangle Detection/Counting 是計算理論一個有趣且還算重要的問題。判斷一個圖是不是二分圖僅需要線性時間，但判斷這個圖是否存在三角形、或計算這個圖有多少三角形，卻出乎意料地"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"不好算"}]},{"type":"text","value":"。（或者是，大家普遍相信如果有線性時間演算法可以算出三角形的數量，那就會有超高效率演算法計算兩個矩陣的相乘。）"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"該問題與 List Intersection、以及資料庫的 join 實作演算法有著密切相關。有趣的是，一些圖上三角形的基本性質，我們可以透過度序列來瞭解他們。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"theorem","properties":{"title":"定理"},"children":[{"type":"text","value":"\n對於任意有 $m$ 條邊的簡單圖 $G$，圖上三角形的數量至多為 $O(m^{3/2})$ 個。\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h4","properties":{},"children":[{"type":"text","value":"證明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"不妨假設 $G$ 的度序列為 $d_1 \\ge d_2 \\ge \\cdots \\ge d_n$。那麼根據握手定理 $d_1+d_2+\\cdots + d_n = 2m$。此時有 $d_i \\le 2m/i$。\n現在對於圖中的每一個三角形 $\\{a, b, c\\}$ 使得 $v_a \\ge v_b \\ge v_c$，我們把它標記在編號最大的點 $v_c$ 上。於是，對於每一個點 $c$，可能掛在 $c$ 這個點上的三角形數量就至多有 $\\min\\set{{c-1\\choose 2}, {d_c-1\\choose 2}}$ 個。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"所以三角形的數量不超過"}]},{"type":"text","value":"\n$$\n\\begin{align*}\n\\sum_{c=1}^n \\min\\set{{c-1\\choose 2}, {d_c-1\\choose 2}} &\\le \\sum_{c=1}^{\\sqrt{m}}{c-1\\choose 2} + \\sum_{c=\\sqrt{m}+1}^{n} {d_c-1\\choose 2} \\\\\n&= O(m^{3/2}) \n\\end{align*}\n$$\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"§4.4 沒有三角形的圖"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"那麼，什麼樣的圖不包含三角形呢？顯然任意的二分圖都不會有三角形的存在。Mantel 在 1907 年證明了，其實完全二分圖會給出邊數最多的不含三角形的圖。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"theorem","properties":{"title":"Mantel 定理"},"children":[{"type":"text","value":"\n不含三角形的 $n$ 個點、$m$ 條邊的圖滿足 $m\\le n^2/4$。\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h4","properties":{},"children":[{"type":"text","value":"證明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"由於圖上不存在三角形，所以對於任何一條邊 $(u, v)$ 來說，必須有 $\\deg(u) + \\deg(v) \\le n$。\n我們可以把 $nm$ 展開得到："}]},{"type":"text","value":"\n$$\n\\begin{align*}\nnm = n|E| & = \\sum_{(u, v)\\in E} n\\\\\n&\\ge \\sum_{(u, v)\\in E} \\left(\\deg(u) + \\deg(v)\\right)\\\\\n& = \\sum_{u\\in V} \\left(\\deg(u)\\right)^2\\\\\n& \\ge \\left(\\frac{\\sum_{u\\in V} \\deg(u)}{n}\\right)^2 \\tag{Cauchy-Schwarz 不等式}\\\\\n& = n\\left(\\frac{2m}{n}\\right)^2 \\tag{握手定理}\\\\\n& = 4m^2/n.\n\\end{align*}\n$$\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"因此推得 $m \\le n^2/4$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"而匈牙利數學家 Turán 在 1941 年推廣了 Mantel 的定理，說明不含 $K_r$ 子圖的圖邊數最多只出現在完全 $(r-1)$-分圖上面。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"theorem","properties":{"title":"Turán 定理"},"children":[{"type":"text","value":"\n對於任意有 $n$ 個點的圖 $G$。若 $G$ 沒有 $K_r$ 子圖，那麼 $G$ 的邊數至多為 $$\n  m\\le \\left(1-\\frac{1}{r-1}\\right)\\frac{n^2}{2}$$\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"習題"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{"start":0},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"span","properties":{"className":["tag","is-dark"]},"children":[{"type":"text","value":"證明題"}]},{"type":"text","value":" 試證明：對於任意一個簡單圖，至少有兩個點度數一樣。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"span","properties":{"className":["tag","is-dark"]},"children":[{"type":"text","value":"證明題"}]},{"type":"text","value":" 試證明：對於任意圖 $G$，上面的 $k$ 個點的子圖數量至多為 $O(m^{k/2})$ 個。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"span","properties":{"className":["tag","is-link"]},"children":[{"type":"text","value":"演算法"}]},{"type":"text","value":" 請給出一個列舉圖上所有三角形的 $O(m^{3/2})$ 時間演算法。"}]},{"type":"text","value":"\n"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"[TIOJ 1009] In No Time!","category":"my-problem","path":"/cp/tioj/1009","date":"2018-11-21","description":"考試時間所剩不多，你能夠把握剩下時間完成所有題目嗎？ 給你現在時間以及考試終止時間，請你判斷還剩下多少時間可以做題目。\n","link":"https://tioj.ck.tp.edu.tw/problems/1009","code":null,"difficulty":1,"oj":"TIOJ","tags":null},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"題目敘述"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"輸入有兩行，第一行表示現在時間，第二行表示考試終止時間。時間的格式為 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"HH:MM:SS"}]},{"type":"text","value":" (時：分：秒)，終止時間永遠比現在時間晚，但兩者時間差不會超過一天(24小時)。(請注意：兩者的時間點不一定都在同一日。)"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸出說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"請輸出距離考試結束還有多久時間，以 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"HH:MM:SS"}]},{"type":"text","value":" 表示。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Sample Input"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"14:00:00\n10:00:00\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Sample Output"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"20:00:00\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"出處"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"95建中資訊培訓模擬試題一（Prob 1）"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ連結"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://tioj.ck.tp.edu.tw/problems/1009"},"children":[{"type":"text","value":"TIOJ 1009 - In No Time!"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"題解"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這題基本上就是考驗大家怎麼把輸入讀進來，如果是傳統的 C 語言的話，由於有格式化輸入 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"scanf"}]},{"type":"text","value":" 世界會變得比較輕鬆些。如果把所有時間都轉換成秒來計算的話，會比較簡單。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"/* by tmt514 */\n#include <cstdio>\n\nint read_input() {\n    // 讀取輸入並且轉換成秒數。\n    int h, m, s;\n    scanf(\"%d:%d:%d\", &h, &m, &s);\n    return (h*60+m)*60+s;\n}\n\nvoid output(int sec) {\n    printf(\"%02d:%02d:%02d\\n\", sec/3600, sec/60%60, sec%60);\n}\n\nint main() {\n    int A = read_input();\n    int B = read_input();\n    if (A >= B) {\n        // 隔天了。\n        B += 86400;\n    }\n    output(B-A);\n    return 0;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"後記"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這個時間序應該是高三上學期的時候，當時高二進了選訓營，學了很多很多東西。\n高三校內初選以後，在彭天健老師和林淑玲老師的協助下，參與了資訊校隊培訓的工作。\n剛好那個時候，北大的 OJ 有釋出版可以玩。我就下載了一套拿來架在自己家裡的主機裡面，並嘗試放了一些題目，邀請大家一起來寫。印象中當年校內預賽的題目是彭天健老師出的，在第一場練習賽之前就先放了預賽題目（TIOJ 1003~1008）讓大家練習。而這題 TIOJ 1009 應該就是正式放上的第一題了吧哈哈～"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"更早之前應該還有出過一套資訊社高二選幹部的演算法考試。那時候還沒有 OJ 可以用，克難地跟 ianchou 用 PHP 架了簡單的評分系統（從現在看起來應該到處都是漏洞哈哈）。可惜我現在一時之間找不到資料。以後有機會再補上當年那套題目吧～"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"[TIOJ 1014] 打地鼠","category":"my-problem","path":"/cp/tioj/1014","date":"2018-12-05","description":"隨著時間的腳步前進，打地鼠遊戲也不斷的翻新，最新一代的打地鼠遊戲不只測試你的反應能力，同時也考驗著你的體力和智力。地鼠基地是一個長型的基座，基座上每隔一公尺就會有一個地鼠洞，由左至右編號為 $1,2,\\ldots,n$。玩家站在這個基地的最左邊，與第一個地鼠洞相距 $1$ 公尺；拿著一根鎚子，準備開始這個遊戲。編號為 $i$ 的地鼠洞每 $T_i$ 秒地鼠會出現一次。被打的地鼠不再出現，只要將所有地鼠打完，就結束遊戲，並且紀錄從開始到結束遊戲的秒數，越快越好。現在問題來了，負責製造這個地鼠基地的遊戲廠商想要知道結束遊戲所需的最少秒數，於是拜託你幫忙寫個程式來解決它。\n\n假定玩家們的體力很好，隨時以每秒 $1$ 公尺的速度移動，並且不受移動方向改變的影響，打地鼠所花的時間也可以忽略不計。\n","link":"https://tioj.ck.tp.edu.tw/problems/1014","code":null,"difficulty":3,"oj":"TIOJ","tags":null},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"題目敘述"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"第一行有一個數字 $n$，代表地鼠洞的數量 $(1\\le n\\le 16)$。第二行有 $n$ 個數字。所有數字皆不大於 $100,000,000$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸出說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"請輸出結束遊戲所需的最少秒數 $S$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Sample Input"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"3\n3 2 5\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Sample Output"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"5\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"出處"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"95建中資訊培訓模擬試題一（Prob 6）"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ連結"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://tioj.ck.tp.edu.tw/problems/1014"},"children":[{"type":"text","value":"TIOJ 1014 - 打地鼠"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"題解"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這個題目是動態規劃，我們定義狀態 $\\dp(S, i)$ 表示玩家已經打掉集合 $S\\subseteq [n]$ 的地鼠，而且目前玩家所在位置是 $i$ 所需的最少秒數。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"/* by tmt514 */\n#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nvector<string> forest = {\n  \"*****************\",\n  \"*...*.......**..*\",\n  \"**..*....*.*.*..*\",\n  \"*......*.**.**.**\",\n  \"*..**...**..**.**\",\n  \"**.....**..*.*..*\",\n  \"*....*..........*\",\n  \"*.....****.*...**\",\n  \"****.*.*........*\",\n  \"*****************\",\n};\n\nconst int dx[4] = {0, 1, 0, -1};\nconst int dy[4] = {1, 0, -1, 0};\nint onFire[10][17];\nint onEscape[10][17];\n\nvoid bfs(int mark[10][17], int hasFire[10][17], int sx, int sy, int T) {\n  queue<int> q;\n  // 如果一開始就著火了，就應該直接死掉。\n  if (hasFire && hasFire[sx][sy] <= T) return;\n  mark[sx][sy] = T;\n  q.push(sx);\n  q.push(sy);\n  while (!q.empty()) {\n    int x = q.front(); q.pop();\n    int y = q.front(); q.pop();\n    int t = mark[x][y];\n    // 依序考慮四個方向是否可通行，如果可通行的話加到佇列裡面。\n    for (int dir = 0; dir < 4; dir++) {\n      int nx = x + dx[dir];\n      int ny = y + dy[dir];\n      if (forest[nx][ny] == '.' && \n          mark[nx][ny] == 0 &&\n          (!hasFire || hasFire[nx][ny] == 0 || hasFire[nx][ny] > t+1)) {\n        mark[nx][ny] = t+1;\n        q.push(nx);\n        q.push(ny);\n      }\n    }\n  }\n}\n\nint main() {\n  int fx, fy, sx, sy, ex, ey, T;\n  cin >> fx >> fy >> T;\n  cin >> sx >> sy >> ex >> ey;\n  // 由於火勢不會燒到避難處，所以一開始要取巧把這格改掉。\n  forest[ex][ey] = 'E';\n  bfs(onFire, NULL, fx, fy, 1);\n  // 然後把它改回變成可以通行。\n  forest[ex][ey] = '.';\n  bfs(onEscape, onFire, sx, sy, T);\n  if (onEscape[ex][ey] > 0) {\n    cout << onEscape[ex][ey]-T << endl;\n  } else {\n    cout << \"Help!\" << endl;\n  }\n  return 0;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"關於這題"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"第一次嘗試出的位元壓縮 DP，相當地有趣呢。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"其他推薦題解"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://polarischiba.blogspot.com/2018/02/tioj-1014.html"},"children":[{"type":"text","value":"PolarisChiba 的 code 收藏區：[TIOJ] 1014打地鼠"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"http://snowyojworld.blogspot.com/2014/10/tioj-1014.html"},"children":[{"type":"text","value":"藍雪的Online Judge日誌：TIOJ 1014 . 打地鼠"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"http://colistar.blogspot.com/2009/10/tioj-1014.html"},"children":[{"type":"text","value":"A Coding E. Coli：TIOJ 1014 打地鼠"}]}]},{"type":"text","value":"\n"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"[URAL1854] Negotiations with Parthians","category":"prob","path":"/problem/ural/1854","date":null,"description":"古希臘以及古羅馬人不喜歡偶數。現在 Andrian 有 $n$ $(1\\le n\\le 10^{18}-1)$ 隻羊(奇數隻)要獻給神明，為了公平，每一位神明都要得到數量相同的羊。為了更吉利，Andrian 決定將羊群獻給奇數位神明、並且這個數量也要有奇數個正因數。請問 Andrian 至多可以將羊獻給多少位神明呢？\n","link":"http://acm.timus.ru/problem.aspx?space=1&num=1854","code":"URAL1854","difficulty":null,"oj":"ural","tags":null},"htmlAst":{"type":"root","children":[],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"Divide Doughnut","category":"prob","path":"/problem/icpc/asia_hanoi_2018/D","date":"2019-01-12","description":"**這是一個互動題。**\n\n![](https://open.kattis.com/problems/dividedoughnut/file/statement/en/img-0001.png)\n\nKhue 與 Hanh 獲得了一個上面灑了一些五彩巧克力米的甜甜圈。他們想要把一個甜甜圈切成公平的一半，使得兩邊的巧克力米的數量相等。\n\n甜甜圈可以視為由 $10^9$ 個單位組成，每一個單位的甜甜圈範圍內至多只會有一顆巧克力米。已知甜甜圈上總共有 $N$ 顆巧克力米（$N$ 是偶數）。你的目標是要協助 Khue 與 Hanh 找出正確的切法，使得兩個人分別擁有連續的 $5\\times 10^8$ 單位甜甜圈，而且上面巧克力米的數量恰好有 $N/2$ 個。\n\n### 互動的部份\n\n你的任務是透過互動式詢問找出一個滿足題目條件的切法。\n\n你的程式會首先讀入一個正整數 $N$。輸入保證 $N$ 是偶數。接下來：\n* 你的程式會輸出以下三種形式之一：\n    * `QUERY u v` ($0\\le u, v < 10^9$)，詢問有多少巧克力米位於第 $u$ 單位與第 $v$ 單位之間。請注意：當 $u>v$ 時表示要計算的巧克力米是從第 $u$ 單位到第 $10^9-1$ 單位、以及第 $0$ 單位到第 $v$ 單位之間。\n    * `YES x` ($0\\le x < 10^9$)，告訴 Khue 可以拿到第 $x$ 單位到第 $(x+5\\cdot 10^8-1)\\bmod 10^9$ 單位的甜甜圈。\n    * `NO`，回答不可能切成公平的兩部份。\n* 你的程式如果問了一個 `QUERY`，那麼接下來你可以從 standard input 讀入一個整數 $S$，表示得到的答案。\n* 否則的話，你的答案會被檢查。**而你必須立刻結束程式**。\n\n對於輸入的 $N$，你的程式至多只能詢問 $30+\\lfloor\\log_2\\sqrt{N}\\rfloor$ 次。\n","link":"https://open.kattis.com/problems/dividedoughnut","code":"ICPC-HANOI-2018-D","difficulty":3,"oj":"kattis","tags":["ICPC 2018 Asia Hanoi Regional","interactive"]},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"簡化後題目敘述"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ 連結"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://open.kattis.com/problems/dividedoughnut"},"children":[{"type":"text","value":"Open Kattis - Divide Doughnut"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"題目出處"}]},{"type":"text","value":"：ICPC 2018 Asia Hanoi Regional"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這題是個很棒的二分搜尋法練習題：關鍵在於每一個單位甜甜圈上頭至多只能有一顆巧克力米。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果我們繪製一個函數 $f$，對於每一個 $x$ 值計算區間 $[x, (x+5\\cdot 10^8-1)\\bmod 10^9]$ 裡面的巧克力米數量，那麼這個函數 $f$ 的相鄰兩個值只會差 $-1, 0, 1$。注意到 $f(0) + f(5\\cdot 10^8) = N$，如果其中一個 $< N/2$ 另一個就會 $> N/2$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"於是我們可以根據 $f(a) < N/2, f(b) > N/2 \\implies \\text{存在} c\\in [a, b] \\text{使得} f(c) = N/2$。然後就可以用"},{"type":"element","tagName":"a","properties":{"href":"/algo/binary-search-applications"},"children":[{"type":"text","value":"勘根定理"}]},{"type":"text","value":"進行二分搜尋法囉！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"要特別注意的是，這題的範圍很嚴格，所以一旦範圍縮小到 $l=r$ 的時候就不需要再詢問就可以直接輸出答案了。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"#include <bits/stdc++.h>\nusing namespace std;\n\nconst int WINDOW = 500000000;\nconst int FULL = 1e9;\nint MakeQuery(int x) {\n  cout << \"QUERY \" << x << \" \" << (x + WINDOW-1)%FULL << endl;\n  int ret;\n  cin >> ret;\n  return ret;\n}\n\nint main() {\n  int N;\n  cin >> N;\n  \n  int v0 = MakeQuery(0);\n  int l = 0, r = WINDOW;\n\n  if (v == N/2) {\n    cout << \"YES \" << 0 << endl;\n    return 0;\n  }\n  \n  while (l < r) {\n    int m = (l + r) / 2;\n    int v = MakeQuery(m);\n    if (v == N/2) {\n      cout << \"YES \" << m << endl;\n      return 0;\n    } else if ((v > N/2) != (v0 > N/2)) {\n      r = m - 1;\n    } else {\n      l = m + 1;\n    }\n  }\n  cout << \"YES \" << m << endl;\n  return 0;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"夢月說"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這題跟 Codeforces 的一個互動題非常相似 "},{"type":"element","tagName":"a","properties":{"href":"https://codeforces.com/contest/1019/problem/B"},"children":[{"type":"text","value":"Codeforces 1019B - The hat"}]},{"type":"text","value":"。該場比賽舉辦的時間是 2018/08/11，其實是相當新的題目。不過該題要求的詢問次數條件相對寬鬆許多，只要不超過 60 次就可以了。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"關於競程日記"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"🍅 如果您想到更多有趣漂亮簡單乾淨的解法話歡迎留言給競程日記小編群！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"ℹ️ 這是一篇投稿給"},{"type":"element","tagName":"a","properties":{"href":"https://www.facebook.com/%E7%AB%B6%E7%A8%8B%E6%97%A5%E8%A8%98-1514973425463954/"},"children":[{"type":"text","value":"競程日記"}]},{"type":"text","value":"的文章，歡迎大家投稿、交流與分享程式解題競賽的點點滴滴！"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"[TIOJ 1013] Fire in the forest","category":"my-problem","path":"/cp/tioj/1013","date":"2018-12-01","description":"中秋節的時候有人在森林中烤肉，一不小心就釀成了火災，火勢非常猛烈，如果某個區域原本沒有著火，但是相鄰的區域著火了，那麼下一分鐘這個區域也會被火勢波及。你很不幸的身處於著火的森林中，不過好加在你隨身帶了筆記型電腦，而且你恰好有這個森林地圖的資料。由廣播得知，火勢於第 $1$ 分鐘發生於起火點 $F$，而現在已經是第 $T$ 分鐘了。你的位置在 $S$ 處，標記 $E$ 的位置代表安全的避難所，並且有直升機場可以搭乘直升機避難。地圖上標著 `*` 的地方代表不可通行的區域，`.` 則是代表可以通過的區域。時間緊迫！你得趕緊找安全的逃生路線！\n\n座標化的森林的地圖是一個長 $17$ 單位、寬 $10$ 單位的一片土地，詳細狀況如下：\n\n```\n*****************\n*...*.......**..*\n**..*....*.*.*..*\n*......*.**.**.**\n*..**...**..**.**\n**.....**..*.*..*\n*....*..........*\n*.....****.*...**\n****.*.*........*\n*****************\n```\n\n左上角的位置為 $(0,0)$，右下角的位置為 $(9,16)$。你每分鐘可以從一個區域移動至相鄰的區域(在這裡所有的相鄰都不包含對角線方向)。現在給定 $F,T$ 之值以及 $S,E$ 的位置，請你求出從 $S$ 到 $E$ 的最短時間。\n","link":"https://tioj.ck.tp.edu.tw/problems/1013","code":null,"difficulty":2,"oj":"TIOJ","tags":null},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"題目敘述"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"第一行有兩個正整數 $FX$, $FY$，代表起火點F的座標。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"第二行有一個正整數 $T (1\\le T\\le 1000)$，代表已經歷時間。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"第三行有四個正整數 $SX$, $SY$, $EX$, $EY$，代表你所在的位置以及安全避難所的位置。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"你可以假設 $F,S,E$ 皆位於可通行處。且避難所不會著火，$F,S,E$ 互不重疊。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸出說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"若可以安全逃離，請輸出從 $S$ 到 $E$ 的最短時間。若你發現身陷火場，或者你根本無法到達避難所的時候，請輸出 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"Help!"}]},{"type":"text","value":"。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Sample Input"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"1 1 \n3 \n4 1 3 3 \n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Sample Output"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"9\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"出處"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"95建中資訊培訓模擬試題一（Prob 5）"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ連結"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://tioj.ck.tp.edu.tw/problems/1013"},"children":[{"type":"text","value":"TIOJ 1013 - Fire in the forest"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"題解"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"algorithm","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"generator","properties":{},"children":[{"type":"element","tagName":"pre","properties":{},"children":[{"type":"text","value":"function*(input, ui) {\n    var forest = [\n        \"*****************\",\n        \"*...*.......**..*\",\n        \"**..*....*.*.*..*\",\n        \"*......*.**.**.**\",\n        \"*..**...**..**.**\",\n        \"**.....**..*.*..*\",\n        \"*....*..........*\",\n        \"*.....****.*...**\",\n        \"****.*.*........*\",\n        \"*****************\",\n    ];\n    forest = forest.map((e) => e.split(\"\"));\n    var fx = input.fx;\n    var fy = input.fy;\n    var T = input.T;\n    var sx = input.sx;\n    var sy = input.sy;\n    var ex = input.ex;\n    var ey = input.ey;\n    forest[fx][fy] = 'F';\n    forest[ex][ey] = 'E';\n    yield {forest: forest};\n    var t, i, j, f;\n    var d = [[0, 1], [1, 0], [0, -1], [-1, 0]];\n    for (t = 0; t < 24; t++) {\n        var newforest = JSON.parse(JSON.stringify(forest));\n        for (i = 0; i < forest.length; i++) {\n            for (j = 0; j < forest[0].length; j++) {\n                if (forest[i][j] === 'F') {\n                    for (f = 0; f < 4; f++) {\n                        var ni = i+d[f][0];\n                        var nj = j+d[f][1];\n                        if (forest[ni][nj] === '.') {\n                           newforest[ni][nj] = 'F';\n                           ui.setStyleOnce('forest', JSON.stringify([ni, nj]), {fill: 'yellow'}); \n                        }\n                    }\n                }\n            }\n        }\n        console.log(newforest);\n        forest = newforest;\n        yield {forest: forest};\n    }\n    return {forest: forest};\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"inputdata","properties":{"data":"{\"fx\":1, \"fy\":1, \"T\": 3,\n    \"sx\":4, \"sy\": 1, \"ex\": 3, \"ey\": 3}"},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"indirectdisplay","properties":{"grid":"","uihelper-node-style":"{stroke: \"none\"}","uihelper-content-map":"{\n        F:{fill: \"#FA8\", font: \"bold 24px Courier New\"},\n        \"*\":{fill: \"#555\"}\n    }","varname":"forest"},"children":[]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"可以利用 BFS 來模擬森林中的火勢蔓延的狀況。用 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"onFire"}]},{"type":"text","value":" 陣列記錄下每個格點第一次著火的時間。然後根據這個表格在 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"onEscape"}]},{"type":"text","value":" 陣列記錄下從 $S$ 出發不踩過火到該點的所有時間。在這裡分享一些有趣的實作小細節："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"使用方向陣列："},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"dx[]"}]},{"type":"text","value":" 和 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"dy[]"}]},{"type":"text","value":" 分別儲存四個方向所需要的位移數值。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"在把座標放進 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"queue"}]},{"type":"text","value":" 的時候，依序放入 $x$ 和 $y$ 座標。取出時也按照這個順序取，就不需要寫麻煩的 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"pair<int, int>"}]},{"type":"text","value":" 了。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"/* by tmt514 */\n#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nvector<string> forest = {\n  \"*****************\",\n  \"*...*.......**..*\",\n  \"**..*....*.*.*..*\",\n  \"*......*.**.**.**\",\n  \"*..**...**..**.**\",\n  \"**.....**..*.*..*\",\n  \"*....*..........*\",\n  \"*.....****.*...**\",\n  \"****.*.*........*\",\n  \"*****************\",\n};\n\nconst int dx[4] = {0, 1, 0, -1};\nconst int dy[4] = {1, 0, -1, 0};\nint onFire[10][17];\nint onEscape[10][17];\n\nvoid bfs(int mark[10][17], int hasFire[10][17], int sx, int sy, int T) {\n  queue<int> q;\n  // 如果一開始就著火了，就應該直接死掉。\n  if (hasFire && hasFire[sx][sy] <= T) return;\n  mark[sx][sy] = T;\n  q.push(sx);\n  q.push(sy);\n  while (!q.empty()) {\n    int x = q.front(); q.pop();\n    int y = q.front(); q.pop();\n    int t = mark[x][y];\n    // 依序考慮四個方向是否可通行，如果可通行的話加到佇列裡面。\n    for (int dir = 0; dir < 4; dir++) {\n      int nx = x + dx[dir];\n      int ny = y + dy[dir];\n      if (forest[nx][ny] == '.' && \n          mark[nx][ny] == 0 &&\n          (!hasFire || hasFire[nx][ny] == 0 || hasFire[nx][ny] > t+1)) {\n        mark[nx][ny] = t+1;\n        q.push(nx);\n        q.push(ny);\n      }\n    }\n  }\n}\n\nint main() {\n  int fx, fy, sx, sy, ex, ey, T;\n  cin >> fx >> fy >> T;\n  cin >> sx >> sy >> ex >> ey;\n  // 由於火勢不會燒到避難處，所以一開始要取巧把這格改掉。\n  forest[ex][ey] = 'E';\n  bfs(onFire, NULL, fx, fy, 1);\n  // 然後把它改回變成可以通行。\n  forest[ex][ey] = '.';\n  bfs(onEscape, onFire, sx, sy, T);\n  if (onEscape[ex][ey] > 0) {\n    cout << onEscape[ex][ey]-T << endl;\n  } else {\n    cout << \"Help!\" << endl;\n  }\n  return 0;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"關於這題"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"很久很久以前的北市賽（在還沒有使用 CMS 系統和使用隨身碟/磁碟輸入以前），評分的時候都是手動輸入測試資料的。當時出的模擬練習，就有點想要效法這樣的出題風格，所以森林的地圖就變成這樣 hard-code 的風格了。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"註：以前是紙本題目，所以連地圖也要在比賽進行時手刻上去 QAQ"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"其他推薦題解"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://blog.ototot.tk/2017/01/tioj-1013-fire-in-forest.html"},"children":[{"type":"text","value":"oToToT 的 code 收藏區：TIOJ 1013"}]}]},{"type":"text","value":"\n"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"Amazing Adventures","category":"prob","path":"/problem/icpc/asia_hanoi_2018/A","date":"2019-01-08","description":"在一個有 $N$ 列、$M$ 行的方格上，有四個英文字母 `B`, `C`, `G`, `U`。請你找出最短的、從 `B` 經過 `C` 到 `G` 但是不包括 `U` 的路徑，使得每一個格子（包含起點與終點）都不能重複經過。輸出這個路徑。\n","link":"https://open.kattis.com/problems/amazingadventures","code":"ICPC-HANOI-2018-A","difficulty":7,"oj":"kattis","tags":["ICPC 2018 Asia Hanoi Regional","graph modeling","min-cost max-flow"]},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"簡化後題目敘述"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"輸入包含多組測試資料，並以 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"0 0"}]},{"type":"text","value":" 作結束。每一筆測試資料包含 6 列："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"第一列有兩個正整數 $N, M$ （$1\\le M, N\\le 100$）"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"第二列有兩個正整數 $r_B, c_B$，表示英文字母 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"B"}]},{"type":"text","value":" 的位置。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"第三列有兩個正整數 $r_C, c_C$，表示英文字母 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"C"}]},{"type":"text","value":" 的位置。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"第四列有兩個正整數 $r_G, c_G$，表示英文字母 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"G"}]},{"type":"text","value":" 的位置。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"第五列有兩個正整數 $r_U, c_U$，表示英文字母 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"U"}]},{"type":"text","value":" 的位置。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"第六列為空白列。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"輸入保證 $1\\le r_B, r_C, r_G, r_U \\le N$ 且 $1\\le c_B, c_C, c_G, c_U\\le M$ 而且四個英文字母的位置不會重疊。\n所有輸入的 $N\\times M$ 加起來不會超過 $10^5$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"請注意：列的編號"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"從下往上"}]},{"type":"text","value":"編號為 1 到 $N$；行的編號"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"從左往右"}]},{"type":"text","value":"編號為 1 到 $M$。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸出說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"對於每一筆測試資料輸出 1 或 2 列。\n首先輸出是否存在滿足題目要求的路徑（"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"YES"}]},{"type":"text","value":" 或 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"NO"}]},{"type":"text","value":"）。如果答案是 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"YES"}]},{"type":"text","value":"，在第二列輸出任何一個滿足條件的最短路徑。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"3 3\n1 1\n3 3\n2 1\n2 2\n\n3 4\n1 1\n3 4\n2 1\n1 2\n\n2 2\n2 1\n2 2\n1 2\n1 1\n\n0 0\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"YES\nRRUULLD\nNO\nYES\nRD\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ 連結"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://open.kattis.com/problems/amazingadventures"},"children":[{"type":"text","value":"Open Kattis - Amazing Adventures"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"好一陣子沒有這麼痛苦地寫一個理論上有模板很好寫的東西了（淚）"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這題的關鍵是"},{"type":"element","tagName":"a","properties":{"href":"https://tmt514.github.io/algo/min-cost-max-flow"},"children":[{"type":"text","value":"最小費用流"}]},{"type":"element","tagName":"footnote","properties":{"goto":"1","show":"備註 1"},"children":[]},{"type":"text","value":"（或者，你可以說貪心地做兩次最短路徑。）\n每個格子不能經過超過一次這個條件，給我們一個很大的提示：要嘛這題是網路流、要嘛這是爆搜或連通性DP。\n我們可以令中繼的 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"C"}]},{"type":"text","value":" 作為 sink，而開頭與結束的 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"B"}]},{"type":"text","value":" 與 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"G"}]},{"type":"text","value":" 作為 source，並建立網路流的圖：對於每一個格子 $(i, j)$ 我們都把他變成兩個點 $(i, j)_{in}$ 跟 $(i, j)_{out}$，然後有一條邊從 in 連到 out，cost=1。此外，對於相鄰的兩個格子，比方說 $(i, j)$ 和 $(i, j+1)$。我們也建立兩條邊 $(i, j)_{out}\\to (i, j+1)_{in}$ 以及 $(i, j+1)_{out}\\to (i, j)_{in}$（請注意都是從 out 連到 in），cost=0。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"在這樣的圖上面找兩條「點不重複的路徑」 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"B"}]},{"type":"text","value":"$\\to$"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"C"}]},{"type":"text","value":"、"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"G"}]},{"type":"text","value":"$\\to$"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"C"}]},{"type":"text","value":"，而且讓總 cost 最小，就等價於找出最短的從 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"B"}]},{"type":"text","value":"$\\to$"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"C"}]},{"type":"text","value":"$\\to$"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"G"}]},{"type":"text","value":" 路徑。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"有模板會好很多很多很多！\n如果沒有的話，寫起來大概繪像我這樣慘慘的。有一些實作上的偷懶細節在這邊："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"每一次都用 priority queue 版本的 SPFA 找最短路徑。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"每一條邊還自帶輸出字元，這樣在找解的時候就不需要思考這條邊到底要給他 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"U"}]},{"type":"text","value":", "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"D"}]},{"type":"text","value":", "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"L"}]},{"type":"text","value":" 還是 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"R"}]},{"type":"text","value":" 了。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"下面程式碼裡面的逆向邊通通標記 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"#"}]},{"type":"text","value":"，這樣可以順便得知這條邊的 cost 到底是 $1$ 還是 $-1$（如果沿著逆向邊流，那 cost 就是 $-1$，反之為 $1$）。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Edge {\n  int to;\n  int capacity;\n  int reversed_index;\n  char ch;\n  Edge(int _to, int _c, int _r, char _ch): to(_to), capacity(_c), reversed_index(_r), ch(_ch) {}\n};\n\nclass FlowNetwork {\n  public:\n    int nid, sink;\n    vector<vector<Edge>> edges;\n    FlowNetwork() : nid(0) {\n      edges.clear();\n    }\n    void SetSink(int _sink) { sink = _sink; }\n    int AddNode() {\n      edges.push_back(vector<Edge>());\n      return nid++;\n    }\n    // 每加入一條邊，同時加上一條逆向邊，到時候增廣的時候我們必須在剩餘圖上的反向邊同步操作，\n    // 因此很需要能夠從一條邊跳到另一條。\n    void AddEdge(int from, int to, char mark) {\n      edges[from].emplace_back(to, 1, (int)edges[to].size(), mark);\n      edges[to].emplace_back(from, 0, (int)edges[from].size()-1, '#');\n    }\n\n    // 給定源點 x，找一條 cost 最小的路徑從 x 到 sink。如果找到了，順便把這條路徑增廣一下。\n    bool SPFA(int x) {\n      priority_queue<pair<int, int>> Q;\n      vector<int> dist(nid, 1e9);\n      vector<Edge> last(nid, Edge(-1,-1,-1,'X'));\n      dist[x] = 0;\n      Q.push({0, x});\n\n      while (!Q.empty()) {\n        auto it = Q.top(); Q.pop();\n        int d = -it.first;\n        int x = it.second;\n        if (d != dist[x]) continue;\n\n        for (auto&& e : edges[x]) {\n          if (e.capacity) {\n            int nd = d + (e.ch == '#' ? -1 : 1);\n            if (dist[e.to] > nd) {\n              dist[e.to] = nd;\n              last[e.to] = edges[e.to][e.reversed_index];\n              Q.push({ -nd, e.to });\n            }\n          }\n        }\n      }\n      if (last[sink].to == -1) return false;\n      x = sink;\n      while (last[x].to != -1) {\n        Edge& e = edges[last[x].to][last[x].reversed_index];\n        e.capacity--;\n        edges[e.to][e.reversed_index].capacity++;\n        x = last[x].to;\n      }\n      return true;\n    }\n\n    // 逆向追蹤還原路徑。\n    string Trace(int x) {\n      string ret = \"\";\n      while (x != sink) {\n        for (auto&& e : edges[x]) {\n          if (e.ch != '#' && e.capacity == 0) {\n            x = e.to;\n            if (e.ch != 'X') ret += e.ch;\n          }\n        }\n      }\n      return ret;\n    }\n};\n\n///////////////////////////////////////////////////////////////////////////////\n// 你看有模板的話上面都省下來了耶。\n\nint ids[105][105][2];\n\nbool solve() {\n  int M, N;\n  // 請不要讀反輸入，這樣會 debug 很久（淚）。\n  cin >> N >> M;\n\n  if (M == 0 && N == 0) return false;\n  FlowNetwork g;\n\n  // 先定義這個圖上的點。\n  for (int i = 1; i <= N; i++) {\n    for (int j = 1; j <= M; j++) {\n      ids[i][j][0] = g.AddNode();\n      ids[i][j][1] = g.AddNode();\n    }\n  }\n\n  int rB, cB, rC, cC, rG, cG, rU, cU;\n  cin >> rB >> cB >> rC >> cC >> rG >> cG >> rU >> cU;\n\n  // 把圖上的邊建立起來，記得要跳過 (rU, cU) 這格。\n  for (int x = 1; x <= N; x++) {\n    for (int y = 1; y <= M; y++) {\n      if (x == rU && y == cU) continue;\n      g.AddEdge(ids[x][y][0], ids[x][y][1], 'X');\n      const int dx[4] = {0, 1, 0, -1};\n      const int dy[4] = {1, 0, -1, 0};\n      const string dir = \"RULD\";\n      for (int f = 0; f < 4; f++) {\n        int nx = x + dx[f], ny = y + dy[f];\n        if (nx == rU && ny == cU) continue;\n        if (nx >= 1 && nx <= N && ny >= 1 && ny <= M) {\n          g.AddEdge(ids[x][y][1], ids[nx][ny][0], dir[f]);\n        }\n      }\n    }\n  }\n\n  g.SetSink(ids[rC][cC][0]);\n  if (g.SPFA(ids[rB][cB][0]) && g.SPFA(ids[rG][cG][0])) {\n    auto A = g.Trace(ids[rB][cB][0]);\n    auto B = g.Trace(ids[rG][cG][0]);\n    reverse(B.begin(), B.end());\n    for (auto&& x : B) {\n      if (x == 'U') x = 'D';\n      else if (x == 'D') x = 'U';\n      else if (x == 'L') x = 'R';\n      else if (x == 'R') x = 'L';\n    }\n    cout << \"YES\" << '\\n';\n    cout << A << B << '\\n';\n  } else {\n    cout << \"NO\" << '\\n';\n  }\n  \n  return true;\n}\n\nint main() {\n  while (solve());\n  return 0;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"備註 1"},{"type":"element","tagName":"footnote","properties":{"here":"1"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"需要關於這題更詳盡的資源請參考 "},{"type":"element","tagName":"a","properties":{"href":"https://stackoverflow.com/questions/11880738/shortest-two-disjoint-paths-between-two-specified-vertices"},"children":[{"type":"text","value":"Stackoverflow - Shortest two disjoint paths between two specified vertices"}]},{"type":"text","value":"。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"關於競程日記"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"🍅 如果您想到更多有趣漂亮簡單乾淨的解法話歡迎留言給競程日記小編群！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"ℹ️ 這是一篇投稿給"},{"type":"element","tagName":"a","properties":{"href":"https://www.facebook.com/%E7%AB%B6%E7%A8%8B%E6%97%A5%E8%A8%98-1514973425463954/"},"children":[{"type":"text","value":"競程日記"}]},{"type":"text","value":"的文章，歡迎大家投稿、交流與分享程式解題競賽的點點滴滴！"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"Jurassic Jungle","category":"prob","path":"/problem/icpc/asia_hanoi_2018/J","date":"2019-01-10","description":"給你 $N$ ($3\\le N\\le 30$) 與 $M$ 的值，請問是否存在一個恰好有 $N$ 個點與 $M$ 條邊的無向簡單圖，滿足條件：從**任意**一個節點出發、每次隨意挑選新的節點走訪、而走出來的 DFS 樹都是一條鍊（path），而且那個唯一的葉子與樹根有邊相連。\n\n如果存在這樣的圖，請輸出 `YES` 以後輸出任意一個答案。否則的話輸出 `NO`。\n","link":"https://open.kattis.com/problems/jurassicjungle","code":"ICPC-HANOI-2018-J","difficulty":6,"oj":"kattis","tags":["ICPC 2018 Asia Hanoi Regional"]},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"簡化後題目敘述"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"輸入可能包含多組測試資料。每一組測試資料包含兩個正整數 $N, M$（$3\\le N\\le 30, 0\\le M\\le \\frac{N(N-1)}{2}$）。測試資料以 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"-1 -1"}]},{"type":"text","value":" 作為結束。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸出說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果存在滿足題目要求的圖，請輸出 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"YES"}]},{"type":"text","value":" 以後輸出任意一個答案的 $M$ 條邊（點的編號為 $1, 2, \\ldots, N$）。否則的話輸出 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"NO"}]},{"type":"text","value":"。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"3 3\n5 4\n-1 -1\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"YES\n1 2\n1 3\n3 2\nNO\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ 連結"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://open.kattis.com/problems/jurassicjungle"},"children":[{"type":"text","value":"Open Kattis - Jurassic Jungle"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"題目出處"}]},{"type":"text","value":"：ICPC 2018 Asia Hanoi Regional"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"看到數字範圍，你可能會覺得或許是 DP、或許是爆搜。但很遺憾地這題是個扎扎實實的圖論數學題。不過好消息是我們不需要會證明，只要全憑直覺就可以通過這題。（這到底是好消息還是壞消息...這代表題目品質很不穩定啊。）"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"對於這個題目，一開始很容易想到的是 Cycle 跟 Complete Graph。除了這兩種圖以外，似乎其他種類的圖都不太可能存在解。快速拿到一個 Wrong Answer 以後便開始細細思索到底還缺了什麼樣的圖。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"思考許久以後，便會發現完全二分圖 Complete Bipartite Graphs，只要兩邊的點數一樣多，那麼從任何一個點隨意出發也可以隨意走出一個 Hamiltonian Cycle。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"然後我就 AC 了（當時的心情是：囧）"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"事後諸葛"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"要給出一個優雅的證明其實還滿有挑戰性的。在此我節錄了一段關鍵的引理"},{"type":"element","tagName":"footnote","properties":{"goto":"1","show":"備註1"},"children":[]},{"type":"text","value":"。假設存在一個滿足條件的圖 $G=(V, E)$，那麼我們可以隨意先畫出一個漢米爾頓圈，其頂點順序依序編號為 $v_1, v_2, \\ldots, v_n$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果除了這個 cycle 以外沒有其他弦（chord，橫越圈內兩點的邊）那麼顯然這是個滿足條件的圖（研究圖論的人會習慣把這樣的 cycle 寫作 $C_n$）。引理來了："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"theorem","properties":{},"children":[{"type":"text","value":"\n如果這個 cycle 上面有一根弦 $(v_j, v_k)\\in E$，那麼必定有 $(v_{j+1}, v_{k+1})\\in E$（不妨令 $v_{n+1}=v_1$ 避免足標溢位的問題。）\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"引理的證明很簡單：考慮以下的 Hamiltonian Path 產生方法（原題指的是恐龍的走法）—— $v_{j+1}, \\ldots, v_{k}, v_{j}, v_{j-1}, \\ldots, v_{1}, v_{n}, \\ldots, v_{k+1}$。根據題意，此時必須保證 $(v_{j+1}, v_{k+1})\\in E$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"有了這個引理以後，就可以如法炮製證明說：如果長度為 $\\ell$ 的弦存在的話，那麼長度為 $\\ell\\pm 2$ 的弦（如果長度在範圍內的話）一定也必須存在。所以最小弦長一定是橫跨兩條或三條邊。接下來要證明的是："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"如果最小弦長橫跨兩條邊而已，那這個圖必須要是完全圖 $K_n$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"如果最小弦長橫跨了三條邊，那麼點數 $n$ 必須是偶數、而且這個圖會變成完全二分圖 $K_{n/2, n/2}$。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"證明的細節實在是太細節了（不斷地找一條路徑然後說，這裡必須有邊這樣）。我們就此打住吧～"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"#include <bits/stdc++.h>\nusing namespace std;\n\nbool solve() {\n  int N, M;\n  cin >> N >> M;\n  if (N == -1 && M == -1) return false;\n\n  if (M == N) { // Cycle\n    cout << \"YES\" << '\\n';\n    for (int i=1;i<=N;i++)\n      cout << i << \" \" << (i==N?1: i+1) << '\\n';\n  } else if (M == N*(N-1)/2) { // Complete Graph\n    cout << \"YES\" << '\\n';\n    for (int i=1;i<=N;i++)\n      for(int j=i+1;j<=N;j++)\n        cout << i << \" \" << j << '\\n';\n  } else if (N%2==0 && M==(N/2)*(N/2)) { // Complete Bipartite Graph\n    cout << \"YES\" << '\\n';\n    for (int i=1;i<=N/2;i++)\n      for(int j=N/2+1;j<=N;j++)\n        cout << i << \" \" << j << '\\n';\n  } else {\n    cout << \"NO\" << '\\n';\n  }\n\n  return true;\n}\n\nint main() {\n  while(solve());\n  return 0;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"備註 1"},{"type":"element","tagName":"footnote","properties":{"here":"1"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這要追溯到 1968 年的一篇論文 "},{"type":"element","tagName":"a","properties":{"href":"https://epubs.siam.org/doi/abs/10.1137/0116056?journalCode=smjmap"},"children":[{"type":"text","value":"Randomly Traceable Graphs"}]},{"type":"text","value":"，裡面關鍵的引理 3 就是上面這個引理。而定理6 就是這整題要問的結論。很 666666 吧。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"關於競程日記"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"🍅 如果您想到更多有趣漂亮簡單乾淨的解法話歡迎留言給競程日記小編群！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"ℹ️ 這是一篇投稿給"},{"type":"element","tagName":"a","properties":{"href":"https://www.facebook.com/%E7%AB%B6%E7%A8%8B%E6%97%A5%E8%A8%98-1514973425463954/"},"children":[{"type":"text","value":"競程日記"}]},{"type":"text","value":"的文章，歡迎大家投稿、交流與分享程式解題競賽的點點滴滴！"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"Fun with Fibonacci","category":"prob","path":"/problem/icpc/asia_hanoi_2018/F","date":"2019-01-13","description":"費氏數列的遞迴定義如下：\n\n$$ F_n = F_{n-1} + F_{n-2} $$\n\n初始條件為 $F_0=0, F_1=1$。這個數列的首幾項為 0, 1, 1, 2, 3, 5, 8, 13, 21, ...\n\n我們現在定義誇張版的費氏數列\n\n* 定義 $G(1, n)$ 為第 $n$ 個費氏數列。\n* 定義 $G(2, n) = G(1, G(1, n))$。\n* 對於任意正整數 $i$，定義 $G(i, n) = G(1, G(i-1, n))$。\n\n給定 $n, k, p$，請你計算 $G(k, n)\\bmod p$ 之值。\n","link":"https://open.kattis.com/problems/funwithfibonacci","code":"ICPC-HANOI-2018-F","difficulty":8,"oj":"kattis","tags":["ICPC 2018 Asia Hanoi Regional","number theory"]},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"簡化後題目敘述"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"輸入的第一列包含一個正整數 $T$ ($1\\le T\\le 10^5$) 代表測試資料組數。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"接下來有 $T$ 列，每一列為一組測試資料，包含三個正整數 $n, k, p$（$1\\le n, k\\le 10^{18}, 1\\le p\\le 10^6$）。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ 連結"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://open.kattis.com/problems/funwithfibonacci"},"children":[{"type":"text","value":"Open Kattis - Fun with Fibonacci"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"題目出處"}]},{"type":"text","value":"：ICPC 2018 Asia Hanoi Regional"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"今天是數論小教室。看到這題範圍這麼大，其中必定有詐。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這題真的很難。而且第一步就是你真的要對費氏數列有所認識的那種難。看到計算費氏數列除以 $p$ 的餘數（注意這裡 $p$ 不是質數唷），就"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"應該"}]},{"type":"text","value":"要想到費氏數列模 $p$ 的循環節長度是 $O(p)$ 的！是不是很 OP！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"而事實上，我們可以利用以下定理刻劃出費氏數列模 $p$ 的循環節長度："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"theorem","properties":{"title":"費氏數列的循環節"},"children":[{"type":"text","value":"\n設 $p$ 為質數。則：\n* 當 $p=5$ 的時候 $F_{20} \\equiv 0, F_{21}\\equiv 1 \\pmod 5$。\n    * 這保證了循環節長度整除 $20$。\n* 當 $p\\equiv \\pm 1 \\pmod 5$ 的時候 $F_{p-1} \\equiv 0, F_{p}\\equiv 1 \\pmod 5$。\n    * 這保證了循環節長度整除 $p-1$。\n* 當 $p\\equiv \\pm 2 \\pmod 5$ 的時候 $F_{2p+2}\\equiv 0, F_{2p+3}\\equiv 1 \\pmod 5$。\n    * 這保證了循環節長度整除 $2p+2$。\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"然後經過努力推敲一下，可以推得對任意正整數 $r$，模 $p^r$ 的時候，循環節長度整除： $p^{r-1} \\times (\\text{模$p$的循環節長度})$。再根據中國剩餘定理用力觀察一下，就可以知道把一個正整數拆成許多質因數的次方積，每一個部份的循環節長度之最小公倍數（LCM）就是我們要的答案。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"上面這個定理的證明可以在"},{"type":"element","tagName":"a","properties":{"href":"https://www.math.arizona.edu/~ura-reports/071/Campbell.Charles/Final.pdf"},"children":[{"type":"text","value":"這裡"}]},{"type":"text","value":"找到唷（我不太喜歡他的證明，有些地方定義不是很清楚的感覺。之後找到更好的再換掉。）"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"有了這個以後，就可以真真正正地開始 "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Fun With Fibonacci"}]},{"type":"text","value":" 了。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"把循環節往下丟"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"對於任意正整數 $p$，我們令函數 $f(p)$ 表示循環節大小。首先我們可以做出以下觀察：\n$G(i, n) \\bmod p = F_{G(i-1, n)} \\bmod p = F_{G(i-1, n)\\bmod f(p)} \\bmod p$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我們可以把這個寫成遞迴關係，透過解決 $G(i-1, n)$ 回頭解 $G(i, n)$。這個遞迴最終得跑過 $k$ 次，基本上是個 $k=1000000000000000000$ 次的概念。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"經過了今天大量 TLE 的洗禮，我觀察到了以下幾個很酷炫的點："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"$p, f(p), f(f(p)), f(f(f(p))), \\ldots$ 這個序列非常快就進入循環了。而且，只要 3~4 步以後就會跑到"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"不動點"}]},{"type":"text","value":"！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"大部分的不動點 $p$（i.e. $f(p)=p$），都是 $2^4\\times 3\\times 5^8$ 的因數。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"處理不動點"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"好的，現在問題變成了處理 $F_{F_{F_{F_n}}} \\bmod p$...，而好消息是我們總可以把 $\\bmod p$ 往註標裡面丟。壞消息是我們要這樣做幾乎 $k$ 次啊！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"注意到每次答案都是一個介於 $[0, p-1]$ 之間的整數，若我們定義一個有 $p$ 個點的圖，其中每個點 $x\\mapsto (F_x\\bmod p)$。那麼，這樣的圖一定長得很水母森林（Jellyfish-es）。迭代 $k$ 次就相當於從 $n$ 出發，連續走 $k$ 步，看看到底停留在什麼地方，而這個地方就是答案。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"（我猜這邊需要另一個定理幫助我們快速找出答案。但我試著用各種鴉常數的方法硬迭代找循環節拿到 AC 了就是......）"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"我最後的大絕招"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"計算 $F_x\\bmod p$ 是很吃重而且很難算的。根據亂跑得結果，上述循環節大小很可能高達 $156250$ 這麼大。因為 $T\\le 10^5$，我們必須要非常非常快速的算出 $F_x\\bmod p$ 才有辦法在時限內跑完最壞測資。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"一個想法是，如果我們找到了一些巨大 cycle，那麼可以把他們存下來，因為下一次再碰到同一個 cycle 的機會是高的。但是，如果今天換了一個 $p$ 值，整個圖都會不一樣，這個存下來的東西就不能用了。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"好消息是，假若有許多不動點都整除 $18750000=2^4\\times 3\\times 5^8$，那一開始我可以偷偷用一個很大的陣列 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"special[18750000]"}]},{"type":"text","value":" 存下費氏數列每一項 $\\bmod 18750000$ 的值。萬一今天遇到 $p=10000$，我們想計算 $F_{123}\\bmod 10000$，這個值就會恰恰等於 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"special[123] % 10000"}]},{"type":"text","value":"（因為 10000 整除 18750000）。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"今天的程式碼真的非常非常傷眼，真的很對不起。我以後有空再把它淨化一下（淚）"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\nconst int N = 2000005;\nvector<bool> sieve(N);\nvector<int> primes;\n\nconst int VS = 18750000;\nint special[18750000];\n\nstruct Matrix {\n  LL a[2][2];\n  Matrix(LL A = 1, LL B = 0, LL C = 0, LL D = 1) {\n    a[0][0] = A;\n    a[0][1] = B;\n    a[1][0] = C;\n    a[1][1] = D;\n  }\n  Matrix operator % (const LL mod) const {\n    LL P = a[0][0]%mod;\n    LL Q = a[0][1]%mod;\n    LL R = Q;\n    LL S = a[1][1]%mod;\n    return Matrix(P, Q, R, S);\n  }\n  Matrix operator *(const Matrix m) const {\n    LL P = a[0][0] * m.a[0][0] + a[0][1] * m.a[1][0];\n    LL Q = a[0][0] * m.a[0][1] + a[0][1] * m.a[1][1];\n    LL R = Q;\n    LL S = a[1][0] * m.a[0][1] + a[1][1] * m.a[1][1];\n    return Matrix(P, Q, R, S);\n  }\n};\n\nMatrix MatrixPowerMod(Matrix A, LL n, LL mod) {\n  if (n == 0) return Matrix() % mod;\n  if (n == 1) return A % mod;\n  Matrix B = Matrix();\n  while (n > 0) {\n    if (n%2) B = B * A % mod;\n    A = A * A % mod;\n    n/=2;\n  }\n  return B;\n}\n\nLL Fib(LL n, LL mod) {\n  if (VS % mod == 0) return special[n] % mod;\n\n  Matrix A(1, 1, 1, 0);\n  A = MatrixPowerMod(A, n, mod);\n  return A.a[0][1];\n}\n\nLL GCD(LL x, LL y) {\n  while ((x%=y) && (y%=x));\n  return x+y;\n}\n\nLL LCM(LL x, LL y) {\n  return x / GCD(x, y) * y;\n}\n\nLL GetPrimePeriod(LL p, int k) {\n  LL result = 0;\n\n  if (p == 5) {\n    LL t = 20;\n    LL w = t; while(--k) w *= p;\n    return (result = w);\n  } else if (p%5 == 1 || p%5 == 4) {\n    LL N = 1; for(int _=0;_<k;_++) N*=p;\n    LL w = p-1; while(--k) w *= p;\n    return (result = w);\n  } else {\n    LL N = 1; for(int _=0;_<k;_++) N*=p;\n    LL w = 2*p+2; while(--k) w *= p;\n    return (result = w);\n  }\n}\n\nLL GetPeriod(LL m) {\n  LL t = 1;\n  LL copy = m;\n  for (int j = 0; primes[j] * primes[j] <= copy; j++) {\n    LL p = primes[j];\n    if (copy % p == 0) {\n      int power = 0;\n      do {\n        copy /= p;\n        ++power;\n      } while (copy % p == 0);\n      \n      t = LCM(t, GetPrimePeriod(p, power));\n    }\n  }\n  if (copy > 1) {\n   t = LCM(t, GetPrimePeriod(copy, 1));\n  }\n  return t;\n}\n\nvoid PreCompute() {\n  for (int i = 2; i <= 20000; i++) {\n    if (!sieve[i]) {\n      for (int j = i*i; j < N; j+=i)\n        sieve[j] = true;\n    }\n  }\n  for (int i = 2; i < N; i++)\n    if (!sieve[i])\n      primes.push_back(i);\n}\n\nLL pp;\nunordered_map<LL, int> pindex;\nunordered_map<LL, pair<int, int>> cycindex[128];\nvector<vector<LL>> bigcycles[128];\nint u[9375000];\nint idx[9375000] = {}, ucnt;\n\nLL getans(LL n, LL k, LL p) {\n  if (k == 1) {\n    return Fib(n, p);\n  }\n  LL next_period = GetPeriod(p);\n  if (p == next_period) {\n\n    if (pindex.find(p) == pindex.end()) {\n      int newidx = pindex.size();\n      pindex[p] = newidx;\n    }\n    int pidx = pindex[p];\n\n    vector<LL> g;\n    \n    ++ucnt;\n\n    n %= p;\n    g.push_back(n);\n    idx[n] = 0;\n    u[n] = ucnt;\n\n    for (LL i = 1; i <= k; i++) {\n      n = Fib(n, p);\n      if (cycindex[pidx].find(n) != cycindex[pidx].end()) {\n        auto [cidx, at] = cycindex[pidx][n];\n        vector<LL> &cycle = bigcycles[pidx][cidx];\n        int length = cycle.size();\n        i += (k-i)/length*length;\n        return cycle[ (k-i+at) % length ];\n      }\n      \n      //if (idx.find(n) != idx.end()) {\n      if (u[n] == ucnt) {\n        // found! from idx[n] to i-1.\n        int length = i - idx[n];\n\n        if (i>=10000 || length >=10000)\n        cerr << \"(pp=\" << pp << \") Found a cycle of length \" << length  << \" at index \" << i << endl;\n        if (length >= 1000) {\n          // Memorize it.\n          int cidx = bigcycles[pidx].size();\n          vector<LL> cycle;\n          for (int j = idx[n]; j < i; j++) {\n            cycle.push_back(g[j]);\n            cycindex[pidx][g[j]] = {cidx, j-idx[n]};\n          }\n          bigcycles[pidx].push_back(cycle);\n        }\n\n        i += (k-i)/length*length;\n        return g[idx[n] + k-i];\n      } else {\n        g.push_back(n);\n        idx[n] = i;\n        u[n] = ucnt;\n      }\n    }\n    return n;\n  }\n  LL t = getans(n, k-1, next_period);\n  return Fib(t, p);\n}\n\nvoid solve() {\n  LL n, k, p;\n  cin >> n >> k >> p;\n  LL t = getans(n, k, p);\n  cout << t << '\\n';\n}\n\nvoid PreTest() {\n  for(LL p = 2; p <= 1000000; p++) {\n    pp = p;\n    getans(576460752303423487LL, 576460752303423487LL, p);\n  }\n}\n\nvoid PreTwo() {\n  LL mod = VS;\n  special[0] = 0;\n  special[1] = 1;\n  for(int i=2;i<mod;i++) {\n    special[i] = (special[i-1]+special[i-2]);\n    if(special[i] >= mod) special[i] -= mod;\n  }\n}\n\nint main() {\n  PreCompute();\n  PreTwo();\n  // PreTest();\n  int T;\n  cin >> T;\n  while(T--) solve();\n  return 0;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"夢月說"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這題應該要 150 行以內寫完才高竿啊。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Shik說"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"BubbleCup 2013 曾經出過一道類似題，但是此題的 $T\\le 10^3$，而且 $p \\le 10^{18}$ 超大。要因數分解還得用 pollar-rho。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"有興趣的朋友們可以參考 "},{"type":"element","tagName":"a","properties":{"href":"https://www.spoj.com/problems/FRSKH"},"children":[{"type":"text","value":"SPOJ - FRSKH Fibonacci recursive sequences (hard)"}]},{"type":"text","value":"。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"http://www.bubblecup.org/Content/Media/Booklet2013.pdf"},"children":[{"type":"text","value":"題解手冊"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://github.com/zimpha/competitive-programming/blob/master/spoj/FRSKH.cc"},"children":[{"type":"text","value":"zimpha 的 FRSKH 題解"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"關於競程日記"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"🍅 如果您想到更多有趣漂亮簡單乾淨的解法話歡迎留言給競程日記小編群！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"ℹ️ 這是一篇投稿給"},{"type":"element","tagName":"a","properties":{"href":"https://www.facebook.com/%E7%AB%B6%E7%A8%8B%E6%97%A5%E8%A8%98-1514973425463954/"},"children":[{"type":"text","value":"競程日記"}]},{"type":"text","value":"的文章，歡迎大家投稿、交流與分享程式解題競賽的點點滴滴！"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"Bipartite Battle","category":"prob","path":"/problem/icpc/asia_hanoi_2018/B","date":"2019-01-09","description":"Socket 和 Bash 在玩一個叫做「Bipartite Battle」的遊戲。這個遊戲的進行方式如下：\n\n* Socket 在桌上先畫出 $N$ 組二部圖（bipartite graph）。第 $i$ 組二部圖的兩個部份，分別包含 $a_i$ 個點與 $b_i$ 個點。\n* 接下來，由 Bash 和 Socket 輪流進行。每一個回合，玩家必須選擇 $N$ 個之中的其中一個非空的圖、並且要嘛刪掉一條邊，要嘛去掉一個點。去掉點的當下，所有連著該點的邊也全部都會被去除。\n* 沒辦法進行操作的人就輸了（也就是說當所有圖的邊跟點都被刪掉以後，下一個人就輸了）。\n* Bash 是先手。\n\n當然，Socket 想要畫一些二部圖使得他能夠總是獲勝。請問 Socket 有多少種畫圖的方法？（請輸出答案除以 $10^9+7$ 的餘數。）\n","link":"https://open.kattis.com/problems/amazingadventures","code":"ICPC-HANOI-2018-B","difficulty":6,"oj":"kattis","tags":["ICPC 2018 Asia Hanoi Regional","game"]},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"簡化後題目敘述"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"第一列有一個正整數 $N$ ($1\\le N\\le 10^5$)。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"接下來的 $N$ 列每一列有兩個整數 $a_i, b_i$ ($1\\le a_i, b_i\\le 10^9$)。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸出說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"輸出 Socket 能夠獲勝的二部圖畫法，除以 $10^9+7$ 的餘數。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"1\n1 1\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"1\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"1\n1 2\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"0\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ 連結"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://open.kattis.com/problems/bipartitebattle"},"children":[{"type":"text","value":"Open Kattis - Bipartite Battle"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這是一道還算經典且有趣的題目～"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"看到「兩人、對稱式、資訊全揭露、博弈問題」"},{"type":"element","tagName":"footnote","properties":{"goto":"1","show":"備註1"},"children":[]},{"type":"text","value":"，想到的關鍵字大概就是拈遊戲（Nim Game）與 "},{"type":"element","tagName":"a","properties":{"href":"https://zh.wikipedia.org/wiki/%E5%B0%BC%E5%A7%86%E6%95%B0"},"children":[{"type":"text","value":"SG值（Sprague-Grundy Value）"}]},{"type":"text","value":"了！\n但這題的數字範圍實在是大到非常誇張，因此可以大膽猜測應該是結論題吧哇哈哈哈。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"很用力地嘗試了一些比較小的二分圖以後，首先映入眼簾的是相當不尋常的單一性：所有 $a_i+b_i=n$ 個點的樹的 SG值都相同！而且根據 $n$ 的值，這些 SG 值是交錯進行的："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"display","properties":{"array":"","min-width":"40","fixedwidth-ratios":"[2]","data":"[\"n\", 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]"},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"display","properties":{"array":"","fixedwidth-ratios":"[2]","min-width":"40","data":"[\"SG值\", 1, 2, 1, 2, 1, 2, 1, 2, 1, 2]"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"為什麼我們注意到樹呢？因為手動計算的時候，前幾小的非樹連通圖只有 cycle 而已啊，其他都是樹。我們多嘗試了一些，發現任何 $a_i+b_i=n$ 個點且恰好有 $m$ 條邊的二部圖，其 SG 值也總是相等的！於是我們可以整理出以下表格。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"display","properties":{"grid":"","uihelper-content-map":"{\n        \"0\": {fill: \"#FE8\"}\n    }","font":"12pt Roboto","data":"[[\"n\\\\m\", 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10],\n            [1,    1, \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n            [2,  \"0\",  2, \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n            [3,    1,  3,  1, \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n            [4,  \"0\",  2,\"0\",  2,\"0\", \"\", \"\", \"\", \"\", \"\", \"\"],\n            [5,    1,  3,  1,  3,  1,  3,  1, \"\", \"\", \"\", \"\"],\n            [6,  \"0\",  2,\"0\",  2,\"0\",  2,\"0\",  2,\"0\",  2, \"\"],\n            [7,    1,  3,  1,  3,  1,  3,  1,  3,  1,  3,  1]]"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"從表格看起來應該就很明顯了吧！只有在總點數 $\\sum(a_i+b_i)$ 是偶數、而且總邊數也是偶數的時候，Socket（後手）才會獲勝。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"事後諸葛"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"令 $sg(n, m)$ 表示任何一個 $n$ 個點 $m$ 條邊的二部圖的 SG 值，根據以上規律，不難發現 $sg(n, m) = (n\\bmod 2) + 2(m\\bmod 2)$。\n我們可以利用（萬用的）數學歸納法來證明任何 $n$ 個點、且 $m$ 條邊的二部圖其 SG 值都相等，而且等於該值。首先，根據 SG 值的原則："}]},{"type":"text","value":"\n$$\nsg(當前狀態) = \\mathrm{mex}\\{ sg(任何下一個狀態) \\}\n$$\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"（其中 "},{"type":"element","tagName":"a","properties":{"href":"https://en.wikipedia.org/wiki/Mex_(mathematics)"},"children":[{"type":"text","value":"mex (minimum excluded value)"}]},{"type":"text","value":" 的意思是所有非負整數中"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"沒有"}]},{"type":"text","value":"出現在集合內的最小值。）"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"現在讓我們來考慮數學歸納法的邊界條件 base case："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"當 $m=0$ 的時候，雙方都只有唯一一種方法（每次刪掉一個點），所以\n$sg(n, 0) = \\begin{cases}\n0 & \\text{當$n$是偶數，}\\\\\n1 & \\text{當$n$是奇數。}\n\\end{cases}$"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"當 $m>0$ 的時候，考慮 $n$ 個點的圖 $G$。我們可以根據歸納假設，對於所有 $m'< m$ 或 $n' < n$ 的 $sg(n', m')$ 值都已經是正確的了。\n此時玩家有兩種選擇："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"(A) 刪除一條邊、或 "}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"(B) 刪除一個點。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"情形 (A) 很單純，因為我們可以知道此時 SG 值會變成 $sg(n, m-1)$。\n情形 (B) 就有點複雜：刪掉的點 $v$ 它的度數 $\\deg(v)$ 也必須考慮進來，變成 $sg(n-1, m-\\deg(v))$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"接著我們可以按情形討論 mex 的值："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"如果 $n$ 是偶數、且 $m$ 是偶數：那麼情形 (A) 會給你新的 SG 值 $=2$，情形 (B) 會給你 $1$ 或 $3$（來自前一排），無論如何都不會拿到 $0$，因此可以斷定此時 SG 值 $= 0$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"如果 $n$ 是偶數、且 $m$ 是奇數：那麼情形 (A) 會給你新的 SG 值 $=0$、且存在一個奇數度數的點（因為總邊數是奇數、且 $G$ 是二部圖），此時情形 (B) 會給你 $1$，無論如何都不會拿到 $2$，因此可以斷定此時 SG 值 $= 2$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"如果 $n$ 是奇數、且 $m$ 是偶數：那麼情形 (A) 會給你新的 SG 值 $=3$、情形 (B) 會給你 $0$ 或 $2$（來自前一排），無論如何都不會拿到 $1$，因此可以斷定此時 SG 值 $= 1$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果 $n$ 是奇數、且 $m$ 是奇數：那麼情形 (A) 會給你新的 SG 值 $=1$、且"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"存在一個奇數度數的點（因為總邊數是奇數、且 $G$ 是二部圖），此時情形 (B) 會給你 $0$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"存在一個偶數度數的點（因為總邊數是奇數、且 $G$ 是二部圖，其中一邊一定有偶數個點，每一個點不可能 degree 都為奇數！），此時情形 (B) 會給你 $2$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"綜合以上：無論如何都不會拿到 $3$，因此可以斷定此時 SG 值 $= 3$。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"計算二部圖的數量"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我們先隨便 hold 住一條邊 $e$。然後對於任何生出來的二部圖 $G$，放上這條邊 $G+e$、或不放上這條邊 $G$，它們邊數的奇偶性顯然不同。\n於是我們可以得到一個「一對一關係」：從「所有擁有奇數條邊的圖」對應至「所有擁有偶數條邊的圖」。這說明了兩種圖的數量是相等的～"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"總共有多少種可能的圖呢？對於每一條潛在的邊，可以選、或不選，因此總共的圖的數量是 $2^{\\sum_{i} a_ib_i}$。\n也就是說，當總點數是偶數時，Socket 能夠獲勝的圖的數量恰好有 $2^{\\left(\\sum_{i} a_ib_i\\right) - 1}$ 個！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"#include <bits/stdc++.h>\nusing namespace std;\n\n\ntypedef long long LL;\n\nLL bigmod(LL a, LL n, LL mod) {\n  if (n == 0) return 1%mod;\n  if (n == 1) return a%mod;\n  LL r = bigmod(a*a%mod, n/2, mod);\n  if (n%2) r = r*a%mod;\n  return r;\n}\n\nint main() {\n  const LL mod = 1e9+7;\n  LL ret = 1;\n  int N, total = 0;\n  cin >> N;\n  for (int i = 0; i < N; i++) {\n    LL ai, bi;\n    cin >> ai >> bi;\n    total ^= ((ai%2) ^ (bi%2));\n    ret = ret * bigmod(2, ai*bi-(i==0), mod) % mod;\n  }\n  if (total) cout << 0 << endl;\n  else cout << ret << endl;\n  return 0;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"備註 1"},{"type":"element","tagName":"footnote","properties":{"here":"1"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"英文是 Two players symmetric impartial game。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"備註 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這題有一隊台大的隊伍在現場賽拿到首殺！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"關於競程日記"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"🍅 如果您想到更多有趣漂亮簡單乾淨的解法話歡迎留言給競程日記小編群！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"ℹ️ 這是一篇投稿給"},{"type":"element","tagName":"a","properties":{"href":"https://www.facebook.com/%E7%AB%B6%E7%A8%8B%E6%97%A5%E8%A8%98-1514973425463954/"},"children":[{"type":"text","value":"競程日記"}]},{"type":"text","value":"的文章，歡迎大家投稿、交流與分享程式解題競賽的點點滴滴！"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"Kingdom of Kittens","category":"prob","path":"/problem/icpc/asia_hanoi_2018/K","date":"2019-01-11","description":"給定平面上 $n$ ($1\\le n\\le 10^5$) 個點，判斷是否存在一個三角形，使得所有點都在這個三角形的邊界或頂點上？\n","link":"https://open.kattis.com/problems/kingdomofkittens","code":"ICPC-HANOI-2018-K","difficulty":8,"oj":"kattis","tags":["ICPC 2018 Asia Hanoi Regional","geometry"]},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"簡化後題目敘述"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"輸入可能包含多組測試資料。每一組測試資料第一列包含一個正整數 $n$，接下來有 $n$ 列分別包含兩個整數 $x_i, y_i$ （$-10^9\\le x_i, y_i\\le 10^9$）。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸出說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"4\n0 0\n0 2\n2 0\n2 2\n5\n0 0\n0 2\n2 0\n2 2\n1 1\n0\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"YES\nNO\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ 連結"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://open.kattis.com/problems/kingdomofkittens"},"children":[{"type":"text","value":"Open Kattis - Kingdom of Kittens"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"題目出處"}]},{"type":"text","value":"：ICPC 2018 Asia Hanoi Regional"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"唉。這種痛苦的計算幾何題好像似曾相識（遠目）"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這題的難點在於特別的 case 也太多了，尤其是，三角形可以有某個邊上面只包含一個點的情況。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"比我的作法簡單的方法應該有很多很多種。今天就獻醜了。"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"如果有更好的解法歡迎提供！"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我的作法是：先計算一個凸包（這個凸包上的點如果 $>6$ 個那就沒救了），然後找出哪些凸包上的邊「一定要出現在三角形裡面」。可能有 0~3 條。然後依據剩下的、沒有被這些邊蓋到的點，分成幾種情形討論。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"假定答案三角形的三條邊都來自凸包上面邊的延伸，那麼需要一個方法判斷：是否真的把這三條邊延伸以後可以圍住所有點。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"假定答案三角形的兩條邊來自凸包上的邊，那麼把邊上的點去掉以後，最多只會剩下一個點，我們需要另一個方法，判斷這種情形是否存在解。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"假定答案三角形的一條邊來自凸包上的邊，那麼凸包大小 $\\le 4$，此時保證有解。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"一些好用的測資"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"7\n2 0\n1 1\n0 2\n8 0\n9 1\n10 2\n5 3\n7\n0 0\n0 1\n0 2\n1 0\n2 0\n3 1\n4 3\n8\n0 0\n0 1\n0 2\n1 2\n2 2\n2 1\n2 0\n1 0\n5\n1 0\n2 0\n3 0\n1 6\n2 6\n7\n0 0\n0 0\n0 0\n0 0\n0 0\n0 0\n0 0\n6\n1 0\n2 0\n3 0\n2 6\n3 6\n4 6\n7\n1 0\n2 0\n3 0\n3 3\n0 1\n0 2\n0 3\n7\n0 2\n1 1\n2 0\n7 0\n8 1\n9 2\n5 -1\n7\n0 2\n1 1\n2 0\n3 0\n4 0\n5 1\n6 2\n7\n0 2\n1 0\n2 0\n3 0\n4 1\n5 2\n7 8\n7\n0 2\n1 0\n2 0\n3 0\n4 1\n5 2\n7 10\n7\n0 2\n1 0\n2 0\n3 0\n4 1\n5 2\n7 9\n8\n0 0\n0 1\n0 2\n1 0\n1 4\n2 0\n2 1\n2 2\n7\n0 0\n0 1\n0 2\n1 0\n2 0\n1 3\n2 3\n6\n0 0\n0 1\n5 0\n5 10\n1 9\n4 10\n6\n0 0\n0 1\n0 2\n6 0\n2 0\n5 0\n5\n0 0\n0 1\n0 2\n0 3\n0 4\n6\n0 0\n0 1\n1 0\n2 3\n3 2\n3 3\n4\n0 0\n0 2\n2 0\n1 1\n4\n0 0\n0 2\n2 0\n2 2\n5\n0 0\n0 2\n2 0\n2 2\n1 1\n0\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"答案應該要是"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"YES\nNO\nNO\nYES\nYES\nNO\nYES\nNO\nNO\nYES\nNO\nNO\nNO\nNO\nNO\nYES\nYES\nYES\nYES\nYES\nNO\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long double Double;\n\nclass Point {\n  public:\n    long long x, y;\n    \n    Point(long long _x=0, long long _y=0): x(_x), y(_y) {}\n    Point operator+(const Point &q) const {\n      return Point(x + q.x, y + q.y);\n    }\n    Point operator-(const Point &q) const {\n      return Point(x - q.x, y - q.y);\n    }\n    bool operator<(const Point &q) const {\n      if (x != q.x) return x < q.x;\n      return y < q.y;\n    }\n    bool operator==(const Point &q) const {\n      return x == q.x && y == q.y;\n    }\n    Double length() const {\n      return sqrtl(x*x+y*y);\n    }\n  friend istream& operator>>(istream& in, Point& p) {\n    in >> p.x >> p.y;\n    return in;\n  }\n    \n};\n\n\nlong long cross(const Point &p, const Point &q) {\n  return p.x * q.y - p.y * q.x;\n}\nlong long dot(const Point &p, const Point &q) {\n  return p.x * q.x + p.y * q.y;\n}\n\nDouble GetAngle(const Point &u, const Point &v) {\n  Double t = ((Double)dot(u, v) / u.length() / v.length());\n  return acosl(t);\n}\n\nbool CheckInvalid(const vector<Point> &angles) {\n  for (size_t i=0;i<angles.size();i++)\n    for(size_t j=i+1;j<angles.size();j++)\n      if(cross(angles[i], angles[j]) == 0)\n        return true;\n\n// 這邊判斷逆時針的三個方向是否真的可以湊成一個涵蓋凸包範圍的三角形。\n  if (angles.size() == 3) {\n    bool f0 = (cross(angles[0], angles[1]) < 0)^(cross(angles[0], angles[2]) < 0);\n    bool f1 = (cross(angles[1], angles[0]) < 0)^(cross(angles[1], angles[2]) < 0);\n    bool f2 = (cross(angles[2], angles[0]) < 0)^(cross(angles[2], angles[1]) < 0);\n    if (!f0 || !f1 || !f2)\n      return true;\n  }\n  return false;\n}\n\nvector<Point> p;\n\nbool IsRightTurn(int A, int B, int C) {\n  return cross(p[B]-p[A], p[C]-p[B]) <= 0;\n}\n\nbool solve() {\n  int N;\n  cin >> N;\n  if (N == 0) return false;\n\n  p.resize(N);\n  for (int i = 0; i < N; i++) cin >> p[i];\n  sort(p.begin(), p.end());\n  \n  N = unique(p.begin(), p.end()) - p.begin();\n  p.resize(N);\n\n  if (N <= 3) {\n    cout << \"YES\" << '\\n';\n    return true;\n  }\n\n  deque<int> cvx, cvx_upper;\n  for(int i=0;i<N;i++) {\n    while (cvx.size() >= 2 &&\n        IsRightTurn(cvx[cvx.size()-2], cvx[cvx.size()-1], i)) {\n      cvx.pop_back();\n    }\n    cvx.push_back(i);\n  }\n  for(int i=N-1;i>=0;i--) {\n    while (cvx_upper.size() >= 2 &&\n        IsRightTurn(cvx_upper[cvx_upper.size()-2], cvx_upper[cvx_upper.size()-1], i)) {\n      cvx_upper.pop_back();\n    }\n    cvx_upper.push_back(i);\n  }\n  for(size_t i=1;i+1<cvx_upper.size();i++) cvx.push_back(cvx_upper[i]);\n  \n  while (cvx.size() >= 3 &&\n      IsRightTurn(cvx[cvx.size()-1], cvx[0], cvx[1])) {\n    cvx.pop_front();\n  }\n\n  // 超過六條邊就一定是 NO 了。\n  if (cvx.size() > 6) {\n    cout << \"NO\" << endl;\n    return true;\n  }\n  \n\n  \n  // 所有點都要在凸包上，並紀錄哪些凸包上的邊有點。\n  vector<bool> has_edge(cvx.size(), false);\n  cvx.push_back(cvx[0]);\n  for (int i = 0; i < N; i++) {\n    int ok = false;\n    for (size_t j = 0; j+1 < cvx.size(); j++) {\n      if (cross(p[cvx[j]]-p[i], p[i]-p[cvx[j+1]]) == 0) {\n        if (cvx[j] != i && cvx[j+1] != i) {\n          has_edge[j] = true;\n        }\n        ok = true;\n      }\n    }\n    if (!ok) {\n      cout << \"NO\" << '\\n';\n      return true;\n    }\n  }\n  \n  // 如果是共線或三角形的情形，就一定是 YES 了。\n  if (has_edge.size() <= 3) {\n    cout << \"YES\" << endl;\n    return true;\n  }\n  \n\n  // 檢查必須擁有的邊是否都不平行。\n  int cnt = 0;\n  vector<Point> angles;\n  for (size_t i = 0; i+1 < cvx.size(); i++) {\n    if (has_edge[i]) {\n      angles.push_back(p[cvx[i+1]]-p[cvx[i]]);\n      ++cnt;\n    }\n  }\n  if (cnt > 3 || CheckInvalid(angles)) {\n    cout << \"NO\" << endl;\n    return true;\n  }\n\n  \n  // 少於五條邊不一定是 YES。\n  // 如果兩條邊固定了，看看是否還有兩個以上還沒蓋到的點。\n  vector<int> empty_point;\n  if(!has_edge[0] && !has_edge.back()) empty_point.push_back(0);\n  for (size_t i=1;i+1<cvx.size();i++) {\n    if(!has_edge[i] && !has_edge[i-1]) {\n      empty_point.push_back(i);\n    }\n  }\n\n  if (empty_point.empty()) {\n    cout << \"YES\" << endl;\n    return true;\n  }\n\n\n  if (cnt == 3 && !empty_point.empty()) {\n    cout << \"NO\" << endl;\n    return true;\n  }\n\n  // Case #9 有這個\n  if (has_edge.size() == 5 && cnt == 2) {\n    if (empty_point.size() == 2) {\n      if (empty_point[1] != empty_point[0]+1 &&\n          (empty_point[0] != 0 ||\n           empty_point[1] != (int)has_edge.size()-1)) {\n        cout << \"NO\" << endl;\n        return true;\n      }\n      if (empty_point[1] == (int)has_edge.size()-1 && empty_point[0] == 0)\n        swap(empty_point[0], empty_point[1]);\n      angles.push_back(p[cvx[empty_point[1]]]-p[cvx[empty_point[0]]]);\n      if (CheckInvalid(angles)) {\n        cout << \"NO\" << endl;\n        return true;\n      } else {\n        cout << \"YES\" << endl;\n        return true;\n      }\n    }\n  }\n\n\n  // 如果兩條邊固定了，取決於剩下那個點出現在那一邊。\n  if (cnt == 2 && empty_point.size() == 1 && has_edge.size() == 5) {\n    \n    int i = empty_point[0];\n    Point first = p[cvx[(i+2)%5]] - p[cvx[(i+1)%5]];\n    Point second = p[cvx[(i+4)%5]] - p[cvx[(i+3)%5]];\n    \n    if (cross(first, second) <= 0) {\n      cout << \"NO\" << endl;\n      return true;\n    }\n    \n  }\n\n\n\n  // 剩下的情況，少於五條邊一定是 YES。\n  if (has_edge.size() <= 5) {\n    cout << \"YES\" << endl;\n    return true;\n  }\n\n\n\n\n  // 只剩下兩種可能。\n  // 1. 考慮偶數位置的邊。\n  vector<Point> odds = { p[cvx[1]]-p[cvx[0]],\n    p[cvx[3]]-p[cvx[2]],\n    p[cvx[5]]-p[cvx[4]]};\n\n  if (CheckInvalid(odds) == false) {\n    bool alleven = (!has_edge[1] && !has_edge[3] && !has_edge[5]);\n    if (alleven) {\n      cout << \"YES\" << '\\n';\n      return true;\n    }\n  }\n  \n  \n  // 2. 考慮奇數位置的邊。\n  vector<Point> evens = { p[cvx[2]]-p[cvx[1]],\n    p[cvx[4]]-p[cvx[3]],\n    p[cvx[0]]-p[cvx[5]]};\n  \n  \n  if (CheckInvalid(evens) == false) {\n    bool allodd = (!has_edge[0] && !has_edge[2] && !has_edge[4]);\n    if (allodd) {\n      cout << \"YES\" << '\\n';\n      return true;\n    }\n  }\n  cout << \"NO\" << '\\n';\n  return true;\n}\n\nint main() {\n  while (solve());\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"關於競程日記"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"🍅 如果您想到更多有趣漂亮簡單乾淨的解法話歡迎留言給競程日記小編群！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"ℹ️ 這是一篇投稿給"},{"type":"element","tagName":"a","properties":{"href":"https://www.facebook.com/%E7%AB%B6%E7%A8%8B%E6%97%A5%E8%A8%98-1514973425463954/"},"children":[{"type":"text","value":"競程日記"}]},{"type":"text","value":"的文章，歡迎大家投稿、交流與分享程式解題競賽的點點滴滴！"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"Smart Thief","category":"prob","path":"/problem/icpc/asia_jakarta_2018/C","date":"2019-01-02","description":"Ayu 想要打開一個使用密碼鎖加密的箱子。為了能夠找出正確密碼，Ayu 必須要很遺憾地嘗試所有長度為 $N$ 的密碼組合。\n\n有趣的是，Ayu 發現了這套密碼鎖系統其實相當古板：當你輸入 $N$ 個數字以後，系統會自動判斷你到底輸入正確與否。如果輸入了正確的密碼，那麼箱子的鎖便會打開。反之，如果輸入了錯誤的密碼，那麼系統會很聰明地把你先前輸入的第一個數字（最早的）丟掉，這麼一來，你只要再輸入一個數字就可以讓他變成長度 $N$ 了。\n\n舉例來說，如果 $N=4$，而且 Ayu 依序輸入了 `204320435`，那麼系統實際上會檢測 6 次（共有 5 種不同的 PIN）：\n\n* `2043`\n* `0432`\n* `4320`\n* `3204`\n* `2043`\n* `0435`\n\nAyu 想要在第一天測試 $K$ 種不同的密碼。你能不能找出任何一個長度最短的字串 $S$，使得它可以讓機器檢測到任意 $K$ 個不同的密碼呢？這個古老的系統能夠鍵入的數字種類有限：它們會是 `0` 到 `9` 這些數字中的某 $M$ 個。\n","link":"https://codeforces.com/gym/102001/problem/C","code":"ICPC-JAKARTA-2018-C","difficulty":7,"oj":"codeforces-gym","tags":null},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"題目敘述"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"輸入包含 3 個整數 $N, M, K$（$1\\le N\\le 100000, 1\\le M\\le 10, 1\\le K\\le \\min(M^N, 100000)$），依序代表密碼的長度、能夠鍵入的數字種類、還有第一天想要測試的密碼量。輸入的第二列包含 $M$ 個整數：$A_i (0\\le A_i\\le 9)$ 表示能夠使用的數字們。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"你可以假設輸入的 $N, M, K$ 會使得答案字串不超過 $100000$ 位數。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸出說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"輸出任何一個滿足條件的、最短的字串 $S$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"3 2 5\n4 7\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"7477447\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"2 5 9\n1 2 3 4 5\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"1234554321\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 3"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"6 3 2\n9 3 5\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"9353593\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ 連結"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://codeforces.com/gym/102001/problem/C"},"children":[{"type":"text","value":"Codeforces Gym 102001 - C"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"首先，輸入的 $A_i$ 跟答案一點關係也沒有，因此我們總是可以假設這些數字是 $0, 1, \\ldots, M-1$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這題的關鍵字只有一個，就是 "},{"type":"element","tagName":"a","properties":{"href":"https://en.wikipedia.org/wiki/De_Bruijn_sequence"},"children":[{"type":"text","value":"De Bruijn Sequence"}]},{"type":"text","value":"。對於給定的參數 $n, m$ 來說，De Bruijn Sequence $B(n, m)\\in [m]^n$ 是一個長度為 $n^m$ 的序列，把他接成一圈以後，任何連續的 $n$ 個字元都不相同。從這個序列的存在性來說，我們就可以斷定本題的答案長度一定是 $|S|=K+N-1$。所以囉，對於輸入的 $N, M, K$，答案之一就可以是 $B(N, M)$ 接成一圈以後的任何長度為 $K+N-1$ 的子字串。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"第一種解法：一筆畫問題 Eulerian Path"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"常見的建構 De Bruijn Sequence 有兩種。第一種是將這個題目轉化成"},{"type":"element","tagName":"a","properties":{"href":"https://en.wikipedia.org/wiki/Eulerian_path"},"children":[{"type":"text","value":"一筆畫問題"}]},{"type":"text","value":"，如下圖所示（圖片參考自維基百科）："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://upload.wikimedia.org/wikipedia/commons/thumb/3/38/De_bruijn_graph-for_binary_sequence_of_order_4.svg/800px-De_bruijn_graph-for_binary_sequence_of_order_4.svg.png","style":"max-width: 300px"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"從任何一點出發，然後走過所有的邊恰好可以接出一個 $B(2, 4)$。我們可以"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"利用 DFS 解一筆畫問題"}]},{"type":"text","value":"。由於這個圖很大（上面會有 $2^{N-1}$ 個節點），所以我們不可能把整張圖生出來再跑一筆畫演算法："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"在 DFS 過程中，如果深度到達 $K$，那依循 DFS 的路徑就可以找到想要的 sequence。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"在 DFS 過程中，如果走訪完畢的邊數到達 $K$ 條，那這 $K$ 條邊也可以接成一個理想的 sequence。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"由於 DFS 演算法每一步要嘛走訪一條新的邊、或是沿著一條邊回溯（並把這條邊丟進 stack），我們很確定最多只要走訪 $2K$ 條邊就可以中止我們的演算法。判斷一條邊被走過與否，有兩種方式：把每條邊雜湊以後存起來、或是把每個點雜湊以後，映至當前還有哪些邊沒走過（是一個 $0$ 到 $M-1$ 之間的數字）。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"所以本題可以在 $O(K)$ 次雜湊存取的時間被解決。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"第二種解法：利用林登字串 Lyndon Words"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://en.wikipedia.org/wiki/Roger_Lyndon"},"children":[{"type":"text","value":"Roger Lyndon"}]},{"type":"text","value":" 是美國密西根大學的數學系教授，他在 1954 年的時候做了一些最小旋轉字典序字串的相關研究（主要是計數方面）。如果一個字串 $S$，滿足以下兩個特徵："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"非循環字串：找不到另一個字串 $P$ 和整數 $k>1$ 使得 $S=\\underbrace{PP\\cdots P}_k$"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"$S$ 是所有 $S$ 的旋轉字串中字典順序最小的。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"那麼該字串 $S$ 就是一個 Lyndon word。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"（題外話——說到旋轉字串與字典序，大家可能想到的就是 Burrows-Wheeler 轉換，這類型資料壓縮的技巧與 Lyndon Word 有著密切關聯。）"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"儘管早在 1934 年，M. H. Martin（我查不到是誰﹍）就用了類似 Lyndon word 的方法做出了 De Bruijn Sequence，但直到 1978 年才由 Harold Fredericksen 和 James Maiorana 兩位發現以下驚人的事實："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"theorem","properties":{},"children":[{"type":"text","value":"\n把所有長度整除 $n$ 的 Lyndon words，依照字典順序（注意不是長度）排序後，全部接起來，就得到一個 de Bruijn 序列了！\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"下面這個演算法是使用第二種解法製作的："},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"依照字典順序"}]},{"type":"text","value":"產生所有長度整除 $n$ 的 Lyndon words，直到我們需要的長度為止。為了解釋下面的程式碼，我們利用關於 Lyndon word 旋轉字典序最小的性質："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"theorem","properties":{},"children":[{"type":"text","value":"\n如果字串 $S$ 是一個 Lyndon word，那麼把他隨意拆成兩個子字串，左半邊的字典序保證小於右半邊。\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"有了這件事情以後，我們可以利用 DFS 一個一個字元決定。還記得 "},{"type":"element","tagName":"a","properties":{"href":"https://zh.wikipedia.org/wiki/%E5%85%8B%E5%8A%AA%E6%96%AF-%E8%8E%AB%E9%87%8C%E6%96%AF-%E6%99%AE%E6%8B%89%E7%89%B9%E7%AE%97%E6%B3%95"},"children":[{"type":"text","value":"KMP 字串匹配演算法"}]},{"type":"text","value":"嗎？我們利用 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"last[]"}]},{"type":"text","value":" 陣列描述對於所有前綴字串，與之匹配的最長前綴子字串。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"algorithm","properties":{},"children":[{"type":"text","value":"\n    "},{"type":"element","tagName":"generator","properties":{},"children":[{"type":"element","tagName":"pre","properties":{},"children":[{"type":"text","value":"        function*(input, ui) {\n            var S = input.S;\n            var n = S.length;\n            var last = [];\n            var i, j;\n            last.push(-1);\n            ui.setStyleOnce('arr', `0`, {fill: 'yellow'});\n              ui.setStyleOnce('S', `0`, {fill: 'yellow'});\n            for (i = 1; i < n; i++) {\n              yield {S: S, arr: last};\n              j = last[i-1]+1;\n              while (j > 0 && S[j] !== S[i])\n                j = last[j-1]+1;\n              last[i] = (S[i]===S[j]? j : -1)\n              for (var k = 0; k <= j; k++) {\n                ui.setStyleOnce('arr', `${i-k}`, {fill: 'lightyellow'});\n                ui.setStyleOnce('S', `${i-k}`, {fill: 'lightyellow'});\n              }\n              ui.setStyleOnce('arr', `${i}`, {fill: 'yellow'});\n              ui.setStyleOnce('S', `${i}`, {fill: 'yellow'});\n            }\n            return {S: S, arr: last};\n        }\n        "}]},{"type":"text","value":"\n    "}]},{"type":"text","value":"\n    "},{"type":"element","tagName":"inputdata","properties":{"data":"{\"S\": \"aaabaaabaaabaabbaaabaabbb\"}"},"children":[]},{"type":"text","value":"\n    "},{"type":"element","tagName":"indirectdisplay","properties":{"array":"","fixedwidth":"","minwidth":"30","highlightdiff":"","varname":"S"},"children":[]},{"type":"text","value":"\n    "},{"type":"element","tagName":"indirectdisplay","properties":{"array":"","fixedwidth":"","n":"25","minwidth":"30","highlightdiff":"","varname":"arr"},"children":[]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果輸入的字串是 Lyndon word，那麼我們可以得到兩個觀察："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"last[]"}]},{"type":"text","value":" 陣列，從左到右一旦有數字變小，永遠是從 $-1$ 開始，不會從中間繼續。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Lyndon word 做出來的 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"last[]"}]},{"type":"text","value":" 陣列，最後一個 last 值永遠是 $-1$。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"所以 DFS 就很簡單啦：每次決定到底現在的 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"last[i]"}]},{"type":"text","value":" 要等於 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"last[i-1]+1"}]},{"type":"text","value":" 還是等於 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"-1"}]},{"type":"text","value":"。如果是前者，那麼只有一種選擇，如果是後者，那麼根據「分兩半字典序必須比較大」的原則，下一個值必須是從 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"last[i-1]+1"}]},{"type":"text","value":" 對應到的字元"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"的下一個"}]},{"type":"text","value":"往後開始跳。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"#include <iostream>\n#include <vector>\nusing namespace std;\n\nstring s;\nint N, M, K;\nint current[100005];\nint a[10];\n\nstring get_string(int len) {\n  string ret = \"\";\n  for (int x = 0; x < len; x++)\n    ret += ('0' + a[current[x]]);\n  return ret;\n}\n\nvoid generate_lyndon_words(int now, int last) {\n  if (now && N%now == 0 && last == -1) {\n    s += get_string(now);\n  }\n\n  if (s.size() >= K+N-1) return;\n  if (now == N) return;\n\n  // 選擇延續 last。\n  if (now > 0) {\n    current[now] = current[last+1];\n    generate_lyndon_words(now+1, last+1);\n  }\n  // 選擇把 last 換成 -1，但是你的字典序要比原本的還要大。\n  for (int x = now? current[last+1]+1 : 0; x < M; x++) {\n    current[now] = x;\n    generate_lyndon_words(now+1, -1);\n  }\n}\n\nint main() {\n  cin >> N >> M >> K;\n  for (int i = 0; i < M; i++) cin >> a[i];\n  generate_lyndon_words(0, -1);\n  while (s.size() < K+N-1) s += s; // 某種邊界條件...\n  s = s.substr(0, K+N-1);\n  cout << s << endl;\n  return 0;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"備註"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"官方題解使用的是第一種解法的不需要 Hash 版，分成兩種情形探討："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"$M^N\\le 2^{40}$。整個 de Bruijn Graph 的邊數 $= 2^{40}$，也就是說所有的邊都可以直接以 $M$-進位轉換成 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"long long"}]},{"type":"text","value":" 數值。此時可以用 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"set<long long>"}]},{"type":"text","value":" 直接存走訪過的邊。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"$M^N > 2^{40}$。此時使用 "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"random walk"}]},{"type":"text","value":" 大法，隨機產生長度為 $K+N-1$ 的序列，有很高的機率會產出一個合法的答案。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"關於競程日記"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"🍅 如果您想到更多有趣漂亮簡單乾淨的解法話歡迎留言給競程日記小編群！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"ℹ️ 這是一篇投稿給"},{"type":"element","tagName":"a","properties":{"href":"https://www.facebook.com/%E7%AB%B6%E7%A8%8B%E6%97%A5%E8%A8%98-1514973425463954/"},"children":[{"type":"text","value":"競程日記"}]},{"type":"text","value":"的文章，歡迎大家投稿、交流與分享程式解題競賽的點點滴滴！"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"[TIOJ 1012] Rails","category":"my-problem","path":"/cp/tioj/1012","date":"2018-11-25","description":"在一個叫「堆疊市」的城市中有一個著名的火車站。由於地形限制以及經費關係，火車站及唯一的鐵路的樣子如下圖：\n\n![](https://tioj.ck.tp.edu.tw/pimgs/1012_1.jpg)\n\n現在火車從A方向來，預定從B方向離開。火車共有N節車廂，並且各車廂依次以1到N來編號。你可以假設各車廂在進站之前可以單獨與其他車廂分離，也可以單獨離開車站到往B方向的鐵軌或是車站北方的「維修鐵路」上。維修鐵路是一小段至多只能容納M節車廂的鐵軌，可以從車站依照順序將車廂移至維修鐵路，或者將車廂從維修鐵路（如果有的話）駛進車站，但是在把車廂從A開進車站的時候，維修鐵路不能有任何車廂。你可以假設在任何時間火車站都可以容納所有的車廂。但是一旦一節車廂進站後，就不能再回到A方向的鐵軌上了，並且一旦離開車站往B方向後，也不能再回到車站。\n\n現在你的任務是寫一個程式，判斷火車能否以一特定的排列方式在B方向的鐵軌上。\n","link":"https://tioj.ck.tp.edu.tw/problems/1012","code":null,"difficulty":1,"oj":"TIOJ","tags":null},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"題目敘述"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"第一行有兩個正整數 $N, M$。($1\\le N\\le 1000, 0\\le M\\le 9$)"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"第二行有 $N$ 個正整數，為 $1, 2, \\ldots, N$ 的一個排列。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸出說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"若能在 B 鐵軌上排出特定排列，請輸出 yes，否則請輸出 no。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Sample Input"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"5 1\n3 2 5 1 4\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Sample Output"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"yes\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"出處"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"95建中資訊培訓模擬試題一（Prob 4）"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ連結"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://tioj.ck.tp.edu.tw/problems/1012"},"children":[{"type":"text","value":"TIOJ 1012 - Rails"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"題解"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這題有個決定性的觀察：基本上，當一節火車從 A 進入車站時，他所排列的位置必須在所有已經進入車站的車廂最上面。也就是說，無論哪些車廂已經被送到鐵軌 B 處，從上到下的順序永遠是遞減的（與進入車站的順序相反），剛好是一個堆疊的樣子。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"於是這讓我們能用基於貪婪法的模擬來解題：如果要駛出的車廂出現在目前堆疊頂端 $M+1$ 節車廂裡面，那我們就直接把他開走。如果想要的車廂還沒有進到車站，就不斷放車廂進來，直到該節車廂一進站立馬停下來。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"/* by tmt514 */\n#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n    int N, M, x, now = 0;\n    vector<int> station;\n    cin >> N >> M;\n    for (int i = 0; i < N; i++) {\n        cin >> x;\n        // 不斷把新的車廂放進來，直到目標車廂出現為止。\n        while (now < x) station.push_back(++now);\n        // 計算目標車廂的位置。\n        auto it = find(station.begin(), station.end(), x);\n        int dist = station.end() - it;\n\n        if (dist > M+1) {\n            // 距離過遠代表得放超過 M 個車廂到上面，做不到。\n            cout << \"no\" << endl;\n            return 0;\n        } else {\n            // 否則就模擬把這節車廂開走。\n            station.erase(it);\n        }\n    }\n    cout << \"yes\" << endl;\n    return 0;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"關於這題"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這一題的原始構想是來自於 "},{"type":"element","tagName":"a","properties":{"href":"https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=455"},"children":[{"type":"text","value":"[UVa 514] Rails"}]},{"type":"text","value":"，只不過加上了一條維修鐵路，所以變得有一點不太相同，但解法還是差不多。"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"ICPC 2018 Asia Jakarta Regional","category":"cp_disabled","path":"/problem/icpc/asia_jakarta_2018","date":"2018-12-26","description":null,"link":null,"code":null,"difficulty":null,"oj":null,"tags":null},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"include-problem","properties":{"title-prefix":"Problem A. ","path":"/problem/icpc/asia_jakarta_2018/A"},"children":[{"type":"text","value":"\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"include-problem","properties":{"title-prefix":"Problem B. ","path":"/problem/icpc/asia_jakarta_2018/B"},"children":[{"type":"text","value":"\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"include-problem","properties":{"title-prefix":"Problem C. ","path":"/problem/icpc/asia_jakarta_2018/C"},"children":[{"type":"text","value":"\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"include-problem","properties":{"title-prefix":"Problem D. ","path":"/problem/icpc/asia_jakarta_2018/D"},"children":[{"type":"text","value":"\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"include-problem","properties":{"title-prefix":"Problem E. ","path":"/problem/icpc/asia_jakarta_2018/E"},"children":[{"type":"text","value":"\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"include-problem","properties":{"title-prefix":"Problem F. ","path":"/problem/icpc/asia_jakarta_2018/F"},"children":[{"type":"text","value":"\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"include-problem","properties":{"title-prefix":"Problem G. ","path":"/problem/icpc/asia_jakarta_2018/G"},"children":[{"type":"text","value":"\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"include-problem","properties":{"title-prefix":"Problem H. ","path":"/problem/icpc/asia_jakarta_2018/H"},"children":[{"type":"text","value":"\n"}]}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"Popping Balloons","category":"prob","path":"/problem/icpc/asia_jakarta_2018/F","date":"2019-01-03","description":"Ayu 和 Budi 正在一場類似 ICPC 的比賽上面決鬥。這樣的比賽題目總共有 $N$ 題，然而，參賽者比須按照指定順序依序解題。\n\nAyu 熟知她自己與 Budi 解每一題的能力，因此，Ayu 能夠事先得知兩個陣列 $A_{1, \\ldots, N}$ 以及 $B_{1, \\ldots, N}$，其中 $A_i$ 與 $B_i$ 分別表示 Ayu 和 Budi 解出第 $i$ 題所需要的時間。\n\n故事是這樣的，Ayu 知道 Budi 對突然的巨大聲響相當敏感，比方說當氣球爆炸的時刻。一旦 Budi 受到驚嚇，他手邊的工作就會立即停擺，而且當下解的題目必須**重頭開始**解。如果在恰好要解出一題的當下被嚇到，Budi 也得從頭開始才行。\n\nAyu 想利用這點勝過 Budi，她唯一能夠利用的，就是自己解出題目的當下所獲得的氣球。你可以假設 Ayu 一旦解出題目就可以立即獲得氣球，也可以立即戳破氣球（如果 Budi 同時即將解完，可憐的 Budi 就得重頭開始）。請問 Ayu 是否有戳氣球的策略使得在時間 $M$ 結束的當下，Ayu 解出的題數**嚴格大於** Budi 的呢？\n","link":"https://codeforces.com/gym/102001/problem/F","code":"ICPC-JAKARTA-2018-F","difficulty":6,"oj":"codeforces-gym","tags":null},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"題目敘述"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"輸入的第一列包含兩個正整數 $N, M$ （$1\\le N\\le 100000; 1\\le M\\le 10^9$）依序代表題目的數量與比賽的時間長度。第二列包含 $N$ 個整數 $A_i$（$1\\le A_i\\le 10^9$），第三列包含 $N$ 個整數 $B_i$（$1\\le B_i\\le 10^9$）。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸出說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果不存在任何方法使得 Ayu 最終題數嚴格大於 Budi 的題數，輸出 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"-1"}]},{"type":"text","value":"。否則的話輸出一個整數 $K$，然後在第二列輸出 $K$ 個嚴格遞增的數字：Ayu 只要在這些時間點戳破氣球，就可以贏過 Budi。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"4 30\n9 10 10 10\n4 10 5 10\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"2\n12 19\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"5 50\n10 10 10 10 10\n15 12 19 17 20\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"0\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 3"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"5 10\n15 10 5 5 5\n9 10 10 10 10\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 3"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"-1\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ 連結"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://codeforces.com/gym/102001/problem/F"},"children":[{"type":"text","value":"Codeforces Gym 102001 - F"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"俗話說得好："},{"type":"element","tagName":"s","properties":{},"children":[{"type":"text","value":"氣球恆久遠，一顆永流傳。"}]},{"type":"text","value":"如果 Ayu 在 Budi 解題目解到一半的時候戳破氣球嚇嚇他，倒不如多等一下，在 Budi 即將解出來的那剎那"},{"type":"element","tagName":"s","properties":{},"children":[{"type":"text","value":"說時遲那時快"}]},{"type":"text","value":"再把氣球戳破，讓 Budi 重來感覺豈不是更好嗎！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"假設我們有個答案，那我們可以把 Budi 的解題心路歷程記錄下來，比方說（紅色的字代表被嚇到所以沒有解出該題）："}]},{"type":"text","value":"\n$$\nB_1, B_2, \\red{B_3}, \\red{B_3}, B_3, \\red{B_4}, B_4, B_5, ...\n$$\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果今天 $B_3 < B_4$，那麼 Ayu 總是可以再多等一下，讓 Budi 重做 $B_4$ 總是比重做 $B_3$ 賺更多！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"以上的觀察引導我們使用「堆疊」的解法，去模擬 Ayu 的選擇，把得到的氣球花在 Budi 的哪些題目上頭。我們維護一個堆疊，從堆疊底部到頂部，永遠是「任務編號遞增、所花費時間嚴格遞減」並且紀錄有多少顆氣球花在這題上面。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"以下面這個例子而言，假設 Ayu 可以在以下時間 8, 20, 40, 48, 56, 65, 109, 114, 117, 118 分別獲得氣球，那堆疊的改變看起來會像這樣："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"algorithm","properties":{},"children":[{"type":"text","value":"\n    "},{"type":"element","tagName":"generator","properties":{},"children":[{"type":"element","tagName":"pre","properties":{},"children":[{"type":"text","value":"        function*(input, ui) {\n            var B = input.B;\n            var C = input.C;\n            var n = B.length;\n            var s = [];\n            var show = function(stack) {\n                return stack.map((x) => `B[${x[0]}] = ${B[x[0]]}\\n重做=${x[1]}`);\n            };\n            var bshow = function(b, s) {\n                var bmsg = [];\n                var i;\n                var v = 0;\n                for (i = 0; i < b.length; i++) {\n                    var msg = '-';\n                    v += b[i];\n                    for (j = 0; j < s.length; j++) {\n                        if (s[j][0] === i) {\n                            msg = `重做 ${s[j][1]} 次`;\n                            v += s[j][1] * b[i];\n                        }\n                    }\n                    bmsg.push(`${b[i]}\\n${msg}\\n完成時間=${v}`);\n                }\n                return bmsg;\n            };\n            var i, j;\n            for (i = 0; i < n; i++) {\n                s.push([i, C[i]]);\n                for (j = 0; j < s.length-1; j++) {\n                        ui.setStyleOnce('arr', `${j}`, {fill: 'lightyellow'});\n                        ui.setStyleOnce('B', `${s[j][0]}`, {fill: 'lightyellow'});\n                    }\n                ui.setStyleOnce('B', `${i}`, {fill: 'cyan'});\n                ui.setStyleOnce('arr', `${s.length-1}`, {fill: 'cyan'});\n                yield ({B: bshow(B,s), arr: show(s)});\n                while (s.length >= 2 &&\n                    B[s[s.length-1][0]] >=\n                    B[s[s.length-2][0]]) {\n                        s[s.length-2][1] += s[s.length-1][1];\n                        s[s.length-2][0] = s[s.length-1][0];\n                        s.pop();\n                    for (j = 0; j < s.length-1; j++) {\n                        ui.setStyleOnce('arr', `${j}`, {fill: 'lightyellow'});\n                        ui.setStyleOnce('B', `${s[j][0]}`, {fill: 'lightyellow'});\n                    }\n                    ui.setStyleOnce('B', `${i}`, {fill: 'cyan'});\n                    ui.setStyleOnce('arr', `${s.length-1}`, {fill: 'cyan'});\n                    yield ({B: bshow(B,s), arr: show(s)});\n                }\n            }\n            for (j = 0; j < s.length; j++) {\n                        ui.setStyleOnce('arr', `${j}`, {fill: 'lightyellow'});\n                        ui.setStyleOnce('B', `${s[j][0]}`, {fill: 'lightyellow'});\n                    }\n            return {B: bshow(B,s), arr: show(s)};\n        }\n        "}]},{"type":"text","value":"\n    "}]},{"type":"text","value":"\n    "},{"type":"element","tagName":"inputdata","properties":{"data":"{\"B\": [8, 10, 5, 3, 1, 9, 6, 7, 4, 2],\n               \"C\": [1, 1, 2, 1, 0, 1, 0, 0, 1, 3]}"},"children":[]},{"type":"text","value":"\n    "},{"type":"element","tagName":"indirectdisplay","properties":{"array":"","fixedwidth":"","minwidth":"30","highlightdiff":"","varname":"B"},"children":[]},{"type":"text","value":"\n    "},{"type":"element","tagName":"indirectdisplay","properties":{"array":"","fixedwidth":"","n":"5","minwidth":"30","highlightdiff":"","varname":"arr"},"children":[]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果總比賽時間 $M=119$，那麼 Ayu 能讓 Budi 在第 119 分鐘的時候還做不出最後一題，因此 Ayu 能夠獲勝。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n  int N, M;\n  cin.sync_with_stdio(false);\n  cin >> N >> M;\n  vector<long long> A(N), B(N);\n\n  for (int i = 0; i < N; i++) cin >> A[i];\n  for (int i = 0; i < N; i++) cin >> B[i];\n\n  // 先算出 Ayu 拿到每顆氣球的時間點，並算出 Ayu 可以解幾題。\n  int nsolved = 0;\n  for (int i = 1; i < N; i++) A[i] += A[i - 1];\n  for (int i = 0; i < N; i++) nsolved += (A[i] <= M);\n\n  // 我們目標就是要讓 Budi 解出第 nsolved 的時間嚴格大於 M。\n  long long t = 0;\n  vector<pair<int, int>> stack;\n  for (int i = 0, j = 0; i < nsolved; i++) {\n    int balloons = 0;\n    while (!stack.empty() && B[stack.back().first] <= B[i]) {\n      balloons += stack.back().second;\n      t -= stack.back().second * B[stack.back().first];\n      stack.pop_back();\n    }\n    t += B[i] * (balloons + 1);\n    while (j < nsolved && A[j] <= t) {\n      ++j;\n      ++balloons;\n      t += B[i];\n    }\n    stack.push_back(make_pair(i, balloons));\n  }\n\n  // 如果還是在 M 分鐘內解出來了，就輸出 -1。\n  if (t <= M) {\n    cout << \"-1\" << endl;\n    return 0;\n  }\n\n  // 計算每顆氣球被戳破的時間。\n  t = 0;\n  int j = 0;\n  vector<long long> ans;\n  for (auto [i, b] : stack) {\n    while (j < i) t += B[j++];\n    for (int l = 0; l < b; l++)\n      ans.push_back(t += B[i]);\n  }\n\n  // 輸出答案。\n  while (!ans.empty() && ans.back() > M) ans.pop_back();\n  cout << ans.size() << endl;\n  for (auto x : ans) cout << x << \" \";\n  cout << endl;\n  return 0;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"關於競程日記"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"🍅 如果您想到更多有趣漂亮簡單乾淨的解法話歡迎留言給競程日記小編群！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"ℹ️ 這是一篇投稿給"},{"type":"element","tagName":"a","properties":{"href":"https://www.facebook.com/%E7%AB%B6%E7%A8%8B%E6%97%A5%E8%A8%98-1514973425463954/"},"children":[{"type":"text","value":"競程日記"}]},{"type":"text","value":"的文章，歡迎大家投稿、交流與分享程式解題競賽的點點滴滴！"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"Boomerangs","category":"prob","path":"/problem/icpc/asia_jakarta_2018/K","date":"2019-01-07","description":"給定一個有 $N$ 個點和 $M$ 條邊的簡單圖 $G=(V, E)$。我們定義圖 $G$ 上的三元數對 $\\langle u, v, w\\rangle$ 被稱為「迴力標」若且唯若 $\\set{(u, v), (v, w)}\\subseteq E$ 而且 $u\\neq w$。\n\n給你圖 $G$，請找出最大的邊不重複「迴力標集合」。也就是說，你要輸出盡量多的迴力標三元數對，而且沒有一條邊出現在兩個你輸出的迴力標裡面。若有多組解的話，輸出任何一組都可以。\n","link":"https://codeforces.com/gym/102001/problem/K","code":"ICPC-JAKARTA-2018-K","difficulty":4,"oj":"codeforces-gym","tags":["ICPC 2018 Asia Jakarta Regional"]},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"簡化後題目敘述"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"第一列包含兩個正整數 $N, M$ ($1\\le N, M\\le 100000$)。第二列開始有 $M$ 列，每一列包含兩個整數 $u_i, v_i$ ($1\\le u_i < v_i \\le N$) 代表一條圖上的邊，你可以假設圖上的邊不會重複在輸入出現。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸出說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"第一列輸出一個整數 $K$ 表示最大的迴力標集合大小。接下來的 $K$ 列，每一列請輸出三個由單一空白間隔開的整數，代表一個迴力標 $\\langle u, v, w\\rangle$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"5 7\n1 2\n1 4\n2 3\n2 4\n2 5\n3 4\n3 5\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"3\n4 1 2\n4 3 2\n2 5 3\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"4 6\n1 2\n1 3\n1 4\n2 3\n2 4\n3 4\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"3\n1 2 3\n1 3 4\n1 4 2\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 3"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"3 3\n1 2\n1 3\n2 3\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 3"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"1\n2 1 3\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ 連結"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://codeforces.com/gym/102001/problem/K"},"children":[{"type":"text","value":"Codeforces Gym 102001 - K"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這個題目很巧妙地利用了在圖上進行 DFS （或 BFS）遍歷的特性。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我們不妨假設整個圖 $G$ 是連通的，考慮從 $G$ 上面任何一個點出發先做一次 DFS。\n由於這個圖是無向圖，所有的邊會根據搜索的情形被分成兩種：在 DFS 樹上的邊（我們稱為 tree edge）、以及不在樹上的邊（此時稱為 back edge，因為發現時一定連到 DFS 樹上的祖先）。\n我們可以把所有的 back edge「掛在」比較深的點，這麼一來整張圖就會在搜索的過程看起來像是一棵樹（BFS也會有類似的效果）。\n對於這樣的樹來說，我們總可以從「葉子」的部份以 Greedy 的方法每次抓相連的兩條 sibling 邊（他們都是從同一個節點出發找到的），然後把它變成迴力標，然後把兩條邊拔掉。\n不難發現，這種拔法可以保證 (1) 拔完之後整個圖還是連通的、以及 (2) 剩下的圖用「數學歸納法」，保證可以拔出最大迴力標的數量。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"因此，根據以上的演算法，我們也在過程中證明了最大的迴力標數量總是 $\\lfloor |E|/2\\rfloor$ 組。而實作上也可以達到線性複雜度，很小品吧 😃"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"display","properties":{"graph":"","undirected":"","unweighted":"","data":"{\n    \"nodes\": [1, 2, 3, 4, 5],\n    \"edges\": [[1, 2], [1, 4], [2, 4], [2, 3], [3, 4], [2, 5], [3, 5]],\n  }","uihelper-id-map":"{\n        \"[1,2]\":{stroke: \"blue\", strokeWidth: \"5\"},\n        \"[1,4]\":{stroke: \"blue\", strokeWidth: \"5\"},\n        \"[2,4]\":{stroke: \"green\", strokeWidth: \"5\"},\n        \"[2,3]\":{stroke: \"green\", strokeWidth: \"5\"},\n        \"[3,4]\":{stroke: \"red\", strokeWidth: \"5\"},\n        \"[3,5]\":{stroke: \"red\", strokeWidth: \"5\"},\n    }"},"children":[{"type":"text","value":"\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"#include <iostream>\n#include <tuple>\n#include <vector>\nusing namespace std;\n\nint N, M;\nvector<int> a[100005];\nint x[100005], y[100005];\nint used[100005];\nvector<tuple<int, int, int>> ans;\n\nint neighbor(int eid, int u) { return x[eid] + y[eid] - u; }\n\n// 如果 dfs 回來以後還有一條邊沒有被配對，那就回傳這條邊，否則回傳 -1。\nint dfs(int u, int from=-1) {\n  int at_hand = -1;\n  // 依序考慮過所有的邊，但是因為 dfs 會經過同一個點很多次，\n  // 所以不妨用一個類似 stack 的方式實作，每走過一條邊就把這條邊去掉。\n  while (!a[u].empty()) {\n    int eid = a[u].back();\n    a[u].pop_back();\n    if (used[eid]) continue;\n    used[eid] = true;\n    int v = neighbor(eid, u);\n    int ret = dfs(v, eid);\n    if (ret == -1) continue;\n    if (at_hand == -1) {\n      at_hand = ret;\n    } else {\n      ans.emplace_back(v, u, neighbor(at_hand, u));\n      at_hand = -1;\n    }\n  }\n  if (at_hand != -1 && from != -1) {\n    ans.emplace_back(neighbor(at_hand, u), u, neighbor(from, u));\n    return -1;\n  } else if (from != -1) {\n    return from;\n  }\n  return -1;\n}\n\nint main() {\n  cin >> N >> M;\n  for (int i = 0; i < M; i++) {\n    cin >> x[i] >> y[i];\n    a[x[i]].push_back(i);\n    a[y[i]].push_back(i);\n  }\n  // 對於每個點進行 DFS，如果早就探索完了，那相鄰邊也都會被拔光，所以不用擔心重複搜索。\n  for (int i = 1; i <= N; i++) dfs(i);\n  \n  cout << ans.size() << endl;\n  // C++17 Structural Binding 好物，越來越像 python 了。\n  for (auto [u, v, w]: ans)\n    cout << u << \" \" << v << \" \" << w << '\\n';\n  return 0;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"備註 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"其實這題的重點在於把 Graph 透過搜索的過程拆成樹，然後在樹上面做迴力標的分組。大家可以試著用 BFS 寫看看～"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"備註 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"不好意思，今天操作型動畫來不及生出來...如果生出來的圖有點醜的話，大家可以多重新整理幾次喔～"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"關於競程日記"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"🍅 如果您想到更多有趣漂亮簡單乾淨的解法話歡迎留言給競程日記小編群！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"ℹ️ 這是一篇投稿給"},{"type":"element","tagName":"a","properties":{"href":"https://www.facebook.com/%E7%AB%B6%E7%A8%8B%E6%97%A5%E8%A8%98-1514973425463954/"},"children":[{"type":"text","value":"競程日記"}]},{"type":"text","value":"的文章，歡迎大家投稿、交流與分享程式解題競賽的點點滴滴！"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"[TIOJ 1010] Prefix and Postfix","category":"my-problem","path":"/cp/tioj/1010","date":"2018-11-22","description":"我們說字串 $A$ 是字串 $B$ 的Prefix（前綴字串），若且唯若字串 $B$ 的前 $len(A)$ 個字母與 $A$ 完全相同，其中 $len(A)$ 指的是字串 $A$ 的長度。例如： “Exam” 和 “Example”都是 “Example” 的 Prefix，但是 “Ample”和 “Exapple” 都不是 “Example” 的 Prefix。同樣的，當 $B$ 的後 $len(A)$ 個字母與 $A$ 完全相同的時候，我們稱 $A$ 是 $B$ 的 Suffix (後綴字串)。給定兩個字串 $P$, $Q$，請你找出最長的字串 $S$ 使得 $S$ 是 $P$ 的 Prefix，同時也是 $Q$ 的 Suffix。\n","link":"https://tioj.ck.tp.edu.tw/problems/1010","code":null,"difficulty":1,"oj":"TIOJ","tags":null},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"題目敘述"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"兩個字串 $P$, $Q$ 各佔一行，只包含小寫英文字母，長度皆不超過 1000 字元。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸出說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"輸出最長的字串 $S$ 的長度 $len(S)$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Sample Input"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"example\nexam\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Sample Output"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"4\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"出處"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"95建中資訊培訓模擬試題一（Prob 2）"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ連結"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://tioj.ck.tp.edu.tw/problems/1010"},"children":[{"type":"text","value":"TIOJ 1010 - Prefix and Postfix"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"題解"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"注意到輸入的字串長度不超過 1000 個字元，所以我們只要逐一枚舉所有第一個字串的 prefix，看看它是不是第二個字串的 suffix 就好了～"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"要取出子字串，可以利用 C++ 的 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"<string>"}]},{"type":"text","value":" 函式庫。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"/* by tmt514 */\n#include <algorithm>\n#include <string>\n#include <iostream>\nusing namespace std;\n\nint main() {\n    string P, Q;\n    cin >> P >> Q;\n    int ans = min(P.size(), Q.size());\n    while (ans > 0 && (P.substr(0, ans) != Q.substr(Q.size()-ans)))\n        --ans;\n    cout << ans << endl;\n    return 0;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"關於這題"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這題顯然是個字串匹配的問題，而且是 KMP 演算法的直接應用。但是根據輸入規模，找出能夠通過測試的最單純演算法，才是取得先機的關鍵。"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"Lexical Sign Sequence","category":"prob","path":"/problem/icpc/asia_jakarta_2018/H","date":"2019-01-05","description":"給你一個包含 $0, 1, -1$ 的序列 $P$，你的任務是要把所有 $0$ 換成 $\\pm 1$，並同時滿足以下 $K$ 個條件：每一個條件由三個整數 $A_i, B_i, C_i$ 描述之，表示從第 $A_i$ 個數加至第 $B_i$ 個數的總和，必須要 $\\ge C_i$。\n\n若有解，請輸出字典順序最小的序列。否則的話輸出 `Impossible`。\n","link":"https://codeforces.com/gym/102001/problem/H","code":"ICPC-JAKARTA-2018-H","difficulty":5,"oj":"codeforces-gym","tags":["ICPC 2018 Asia Jakarta Regional"]},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"簡化後題目敘述"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"輸入的第一列包含兩個整數 $N, K$ ($1\\le N\\le 100000; 0\\le K \\le 100000$) 代表序列的長度與條件的數量。第二列包含 $N$ 個整數 $P_i$ ($-1\\le P_i\\le 1$)，若 $P_i=0$ 代表第 $i$ 個位置還沒有決定是 $-1$ 還是 $1$，否則的話 $P_i$ 的值已經固定了。接下來的 $K$ 列每一列包含三個整數 $A_i, B_i, C_i$ ($1\\le A_i \\le B_i\\le N; -N\\le C_i\\le N$)。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸出說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"若這樣的序列存在，輸出 $N$ 個以空白隔開的整數。否則輸出 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"Impossible"}]},{"type":"text","value":"。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"3 2\n0 0 0\n1 2 2\n2 3 -1\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"1 1 -1\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"3 2\n0 -1 0\n1 2 2\n2 3 -1\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"Impossible\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ 連結"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://codeforces.com/gym/102001/problem/H"},"children":[{"type":"text","value":"Codeforces Gym 102001 - H"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"通常要找出最小的字典順序的題目，絕對與 Greedy 演算法脫不了干係。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"從前面填過去"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這題一個直接的想法就是從最前面開始，依序在空格（$P_i=0$ 處）填上 $-1$，並看看是否違反任何一個條件。但直接做要花 $O(NK)$ 的時間，所以實際上我們需要對每個條件 $j$ 維護一個值 ${\\mathit{remain}}=$「再補幾個 $-1$ 就不夠了」。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"假設我們現在填到第 $i$ 個位置了。令 $S$ 為目前與這個位置有關的所有條件形成的集合。我們考慮 $S$ 內所有條件的 ${\\mathit{remain}}$ 值。如果當前有某個 ${\\mathit{remain}} < 0$，代表沒救了；如果當前有某個 ${\\mathit{remain}}=0$，代表這格一定要填上 $1$，否則的話，我們總是可以貪婪地把這格填上 $-1$、並且把所有 $S$ 內條件的 ${\\mathit{remain}}$ 值通通減 $1$。（這一步可以透過宣告並維護一個全域變數 ${\\mathit{offset}}$，在常數時間內辦到把所有條件 ${\\mathit{remain}}$ 值通通 $-1$）。判斷是否存在 ${\\mathit{remain}}=0$ 就相當於判斷集合 $S$ 裡面的最小值是否 $=0$，這個可以透過一個 heap 辦到。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"於是，整個演算法就可以在 $O(N + K\\log K)$ 時間內完成。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"從後面改回來"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"另一個我覺得在演算法上面很實用的方法——拖延法（Lazy Evaluation，總是拖到最後一刻才作必要的改變），也可以用在這題當中。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我們先把所有能夠填數字的地方全部填上 $-1$，然後逐一檢視每個條件 $(A_i, B_i, C_i)$，如果這個條件沒有被滿足，那我們便貪心地從 $B_i$ 往回查看，把所有能改的 $-1$ 依序改成 $1$，直到條件被滿足為止。如果按照"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"右界"}]},{"type":"text","value":" $B_i$ 由小到大依序把條件加進去的話，每一次把 $-1$ 改成 $1$ 的過程，都保證會造福未來的條件，因此感情上我們可以得到字典順序最小的解。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"檢查一個條件需要計算一段連續和，如果不想花太多力氣的話，一個簡單的 "},{"type":"element","tagName":"a","properties":{"href":"https://zh.wikipedia.org/wiki/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84"},"children":[{"type":"text","value":"Fenwick Tree(BIT)"}]},{"type":"text","value":" 就可以達到目標。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我們注意到，當我們決定要把一個 $-1$ 改成 $1$ 的時候，這個數字就再也不會更改了。按照右界順序考慮條件有個實作上方便之處：可以把「仍然可改」的位置丟進一個"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"堆疊"}]},{"type":"text","value":"裡面，這個堆疊最上面的索引就恰好是距離當前右界最接近的一個。每一次需要把一個 $-1$ 變成 $1$ 就從這個堆疊上面拿 index 就好。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"堆疊的部分時間複雜度是 $O(N)$，對於每一個條件來說，除了修改 $-1$ 以外，其餘要花的時間只有一開始計算區間和所需的時間，因此整體時間複雜度為 $O(N+K\\log N)$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"#include <iostream>\n#include <vector>\nusing namespace std;\n\nint input[100005];\nint now[100005];\nvector<pair<int, int>> hook[100005];\nvector<int> stack;\nint N, K;\n\n// 一個活生生、跳脫框架（好像不太應該）的 Fenwick Tree。\nint bit[100005];\n\n// 把 x 這格的值加上 v。\nvoid add(int x, int v) {\n  while (x <= N) {\n    bit[x] += v;\n    x += (x & -x);\n  }\n}\n\n// 計算序列前 x 項的總和。\nint ask(int x) {\n  int ret = 0;\n  while (x) {\n    ret += bit[x];\n    x -= (x & -x);\n  }\n  return ret;\n}\n\n// 計算序列從第 l 項到第 r 項的總和。\nint ask(int l, int r) { return ask(r) - ask(l - 1); }\n\nint main() {\n  cin >> N >> K;\n  for (int i = 1; i <= N; i++) cin >> input[i];\n  for (int i = 1; i <= N; i++) now[i] = (input[i] != 0 ? input[i] : -1);\n  for (int i = 1; i <= N; i++) add(i, now[i]);\n  // 把所有條件依照右界的順序\n  for (int i = 0; i < K; i++) {\n    int l, r, c;\n    cin >> l >> r >> c;\n    hook[r].push_back({l, c});\n  }\n  for (int i = 1; i <= N; i++) {\n    // 如果現在這格是空的，就把註標塞進堆疊裡備用。\n    if (input[i] == 0) stack.push_back(i);\n    \n    // 逐一掃過所有右界在 i 的條件，並試圖滿足他們。\n    for (auto [l, c] : hook[i]) {\n      int v = ask(l, i);\n      // 如果當前總和仍不達 c，就必須把最接近的 -1 改成 1。\n      while (v < c) {\n        if (stack.empty() || stack.back() < l) {\n          puts(\"Impossible\");\n          return 0;\n        }\n        v += 2;\n        now[stack.back()] = 1;\n        add(stack.back(), 2);\n        stack.pop_back();\n      }\n    }\n  }\n  for (int i = 1; i <= N; i++) {\n    cout << now[i] << ' ';\n  }\n  cout << endl;\n  return 0;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"備註"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"稍微多想一下下，這題其實可以做到 $O(N+K)$。不過以這題的範圍而言，$O(N+K\\log N)$ 或 $O(N+K\\log K)$ 都相當足夠了。大致作法如下：首先經過線性時間預處理，把已經固定數值的地方全部處理掉。因此題目可以轉化為在一個空的序列上指定 $\\pm 1$ 的數值。接下來，我們可以利用 Disjoint Set，維護已經被改成 $1$ 的所有位置（以區間的方式儲存，如果相鄰兩個位置都是 $1$，那麼這兩個位置同屬一個 Set。）"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"display","properties":{"array":"","min-width":"32","fixedwidth":"","uihelper-content-map":"{\n        \"1\":{fill: \"#FA8\"},\n    }","data":"[\"-1\", \"-1\", \"-1\", \"1\", \"1\", \"-1\", \"1\", \"1\", \"-1\", \"-1\", \"-1\", \"1\", \"1\", \"1\", \"-1\"]"},"children":[{"type":"text","value":"\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"因此計算連續和的任務就等價於紀錄當前區間「左方」（包含自己）的區間長度總和。這個「左方區間長度總和」的值，很幸運地不會頻繁地被更新（因為更新只會從已考慮過的位置最右邊開始，也就是當前的最右邊的區間。）"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"display","properties":{"array":"","min-width":"32","fixedwidth-ratios":"[1,1,1,2,1,2,1,1,1,3,1]","data":"[0, 0, 0, \"2\", 2, \"4\", 4, 4, 4, \"7\", 7]"},"children":[{"type":"text","value":"\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Disjoint Set Union 的演算法在這個情形下（每一次只 Union 相鄰兩個區間）是可以做到 worst-case $O(1)$ 的。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"關於 Greedy 演算法的正確性證明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這真的真的很恐怖。不要問。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Greedy 演算法是一類，通常直覺上很對，證明起來卻很崩潰的一類演算法（一淚眼算法）。可以參考 "},{"type":"element","tagName":"a","properties":{"href":"https://cs.stackexchange.com/questions/59964/how-to-prove-greedy-algorithm-is-correct"},"children":[{"type":"text","value":"Stack Exchange"}]},{"type":"text","value":"、"},{"type":"element","tagName":"a","properties":{"href":"http://www.cs.cornell.edu/courses/cs482/2007su/exchange.pdf"},"children":[{"type":"text","value":"康乃爾大學講義"}]},{"type":"text","value":"、"},{"type":"element","tagName":"a","properties":{"href":"https://web.stanford.edu/class/archive/cs/cs161/cs161.1138/handouts/120%20Guide%20to%20Greedy%20Algorithms.pdf"},"children":[{"type":"text","value":"史丹佛大學講義"}]},{"type":"text","value":"對於證明貪婪演算法的正確性所下的註解。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"關於競程日記"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"🍅 如果您想到更多有趣漂亮簡單乾淨的解法話歡迎留言給競程日記小編群！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"ℹ️ 這是一篇投稿給"},{"type":"element","tagName":"a","properties":{"href":"https://www.facebook.com/%E7%AB%B6%E7%A8%8B%E6%97%A5%E8%A8%98-1514973425463954/"},"children":[{"type":"text","value":"競程日記"}]},{"type":"text","value":"的文章，歡迎大家投稿、交流與分享程式解題競賽的點點滴滴！"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"Go Make It Complete","category":"prob","path":"/problem/icpc/asia_jakarta_2018/G","date":"2019-01-04","description":"給定一個無向簡單圖 $G$，找出最大的整數 $k$，使得存在一個包含所有尚未被加入 $G$ 的邊的序列 $L$，使得依序把這些邊 $(x, y)$ 加入圖 $G$ 的當下，$\\delta_x+\\delta_y \\ge k$。其中 $\\delta_x, \\delta_y$ 是當下點 $x$ 和點 $y$ 在圖 $G$ 上的度數。\n","link":"https://codeforces.com/gym/102001/problem/G","code":"ICPC-JAKARTA-2018-G","difficulty":5,"oj":"codeforces-gym","tags":null},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"簡化後題目敘述"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"輸入的第一列包含兩個整數 $N, M$ ($2\\le N\\le 500; 0\\le M < \\frac{N\\times (N-1)}{2}$) 代表點的數量與現存的邊數。接下來的 $M$ 列每一列包含兩個正整數 $a_i, b_i$ ($1\\le a_i < b_i \\le N$) 表示一條現存的邊。輸入保證任何配對 $(a_i, b_i)$ 只會出現至多一次。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸出說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"輸出所求的整數 $k$ 值。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"4 3\n1 2\n2 3\n3 4\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"3\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"5 0\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"0\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 3"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"5 2\n1 2\n3 4\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 3"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"2\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ 連結"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://codeforces.com/gym/102001/problem/G"},"children":[{"type":"text","value":"Codeforces Gym 102001 - G"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這題可以用枚舉法的概念，對於每一個 $k$ 值判斷是否存在一個加入邊的序列滿足條件。演算法如下："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"把所有滿足 $\\delta_x+\\delta_y\\ge k$ 但不在圖上的邊蒐集起來，加入一個佇列 $Q$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"只要佇列非空，抓一條佇列中的邊 $(x, y)$，把它加入圖中；掃過一次所有與點 $x$ 和點 $y$ 相鄰的所有不在圖上的邊，並判斷是否能夠把它們加入佇列。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"如果最終所有的邊都被加入了佇列，就代表這個 $k$ 值是個成功的 $k$ 值。反之則不行：在任意時刻加不進佇列的邊永遠度數和小於 $k$。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"以上的演算法的第一步會花 $O(N^2)$ 時間掃過所有點對。\n第二步可能會考慮 $O(N^2)$ 個點對、而每一條邊加入後會花 $O(N)$ 時間掃過相鄰的不在圖上的邊，因此第二步所花時間是 $O(N^3)$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"不難發現只要 $k$ 是答案，$k-1$ 也會是答案。於是我們可以對 $k$ 進行二分搜尋法，找到滿足條件的最大 $k$ 值。時間複雜度 $O(N^3\\log N)$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"但事實上二分搜尋法是不必要的。對於某個 $k$，若第二步完成後，還有邊沒有被加入圖上，那麼我們把 $k\\gets k-1$ 時，剛才那些已經加入的邊，顯然可以依照同樣順序被加入圖上。因此，我們只需要重新對剩下的邊跑過上述演算法即可。注意到最大可能的 $k$ 為 $(N-2)+(N-2)$，第一步可能要重新跑 $O(N)$ 次，因此總花費時間是 $O(N^3)$，第二步每一條邊仍然只會被加入到佇列至多一次，所以也還是 $O(N^3)$。我們就得到一個 $O(N^3)$ 的乾淨算法啦～"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"#include <algorithm>\n#include <iostream>\n#include <queue>\nusing namespace std;\n\nint a[505][505];\nint deg[505];\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n  for (int i = 0; i < m; i++) {\n    int x, y;\n    cin >> x >> y;\n    a[x][y] = a[y][x] = 1;\n    deg[x]++;\n    deg[y]++;\n  }\n  int k;\n  for (k = 2 * (n - 2); k >= 0; k--) {\n    queue<pair<int, int>> q;\n    // 第一步\n    for (int x = 1; x <= n; x++)\n      for (int y = x + 1; y <= n; y++)\n        if (!a[x][y] && deg[x] + deg[y] >= k) {\n          q.push({x, y});\n        }\n    // 第二步\n    while (!q.empty()) {\n      auto [x, y] = q.front();\n      q.pop();\n      if (a[x][y]) continue;\n      m++;\n      a[x][y] = a[y][x] = 1;\n      deg[x]++;\n      deg[y]++;\n      for (int z = 1; z <= n; z++) {\n        if (x != z && !a[x][z] && deg[x] + deg[z] >= k) q.push({x, z});\n        if (y != z && !a[y][z] && deg[y] + deg[z] >= k) q.push({y, z});\n      }\n    }\n    // 第三步\n    if (m >= n * (n - 1) / 2) break;\n  }\n  cout << k << endl;\n  return 0;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"備註"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果要再快個常數倍的話（大約兩倍），可以把第一步很多不必要的檢查節省起來：事先把所有沒在圖上的邊依照 $\\delta_x+\\delta_y$ 的值放到某個陣列裡面。在第二步更新的當下，可以順便更新 $(x, z)$ 和 $(y, z)$ 的度數和。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Open Question"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這題如果把 Queue 拿掉，變成以下的 code 會變得更快。不曉得有沒有辦法證明下面的 while loop 只會跑 $O(N)$ 次？"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"#include <algorithm>\n#include <iostream>\n#include <queue>\nusing namespace std;\n\nint a[505][505];\nint deg[505];\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n  \n  auto addedge = [&](int x, int y) {\n    a[x][y] = a[y][x] = 1;\n    deg[x]++;\n    deg[y]++;\n  };\n  for (int i = 0; i < m; i++) {\n    int x, y;\n    cin >> x >> y;\n    addedge(x, y);\n  }\n  int k = 2 * (n - 2);\n  while (m < n * (n - 1) / 2) {\n    int v = 0;\n    for (int x = 1; x <= n; x++)\n      for (int y = x + 1; y <= n; y++)\n        if (!a[x][y])\n            v = max(v, deg[x] + deg[y]);\n    k = min(k, v);\n    for (int x = 1; x <= n; x++)\n      for (int y = x + 1; y <= n; y++)\n        if (!a[x][y] && deg[x] + deg[y] >= k) {\n          m++;\n          addedge(x, y);\n        }\n  }\n  cout << k << endl;\n  return 0;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"關於競程日記"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"🍅 如果您想到更多有趣漂亮簡單乾淨的解法話歡迎留言給競程日記小編群！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"ℹ️ 這是一篇投稿給"},{"type":"element","tagName":"a","properties":{"href":"https://www.facebook.com/%E7%AB%B6%E7%A8%8B%E6%97%A5%E8%A8%98-1514973425463954/"},"children":[{"type":"text","value":"競程日記"}]},{"type":"text","value":"的文章，歡迎大家投稿、交流與分享程式解題競賽的點點滴滴！"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"As Rich as Crassus","category":"prob","path":"/problem/icpc/asia_nakhon_pathom_2018/H","date":"2019-01-29","description":"給你三個數字 $N_1, N_2, N_3$ 以及三個餘數 $x^3\\bmod N_1, x^3\\bmod N_2, x^3\\bmod N_3$。已知對於所有 $i=1,2,3$ 皆有 $x^3 > N_i$、而且 $N_1, N_2, N_3$ 兩兩互質。求出滿足條件的最小 $x$。\n","link":"https://codeforces.com/gym/101987","code":"ICPC-2018-NAKHON-PATHOM-H","difficulty":5,"oj":"codeforces-gym","tags":["ICPC 2018 Asia Seoul Regional"]},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"簡化後題目敘述"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"display","properties":{"input-format":"","format":"multi-input"},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"variable","properties":{"type":"int","id":"T","ge":"1","le":"10"},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"repeat","properties":{"times":"T"},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"variable","properties":{"array":"","size":3,"type":"int","id":"N","gt":"0","lt":"2^{21}"},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"variable","properties":{"array":"","size":3,"type":"int","id":"x^3\\bmod N"},"children":[]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸出說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"對於每筆測試資料輸出題目所求的 $x$ 值。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"2\n6 11 19\n5 4 11\n25 36 7\n16 0 6\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"5\n6\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ 連結"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://codeforces.com/gym/102091"},"children":[{"type":"text","value":"Codeforces Gym"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"題目出處"}]},{"type":"text","value":"：ICPC 2018 Asia Nakhon Pathom Regional"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"對於輸入的三個 $x^3\\bmod N_i$ 值來說，如果我們能分別找出所有可能的 $x\\bmod N_i$ ($i=1,2,3$)，那麼就可以利用"},{"type":"element","tagName":"a","properties":{"href":"https://zh.wikipedia.org/wiki/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86"},"children":[{"type":"text","value":"中國剩餘定理"}]},{"type":"text","value":"，對所有可能的組合，計算出可能的 $x$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這題的測試資料看起來不太嚴謹。如果有發現可能有錯誤的地方再麻煩跟我說～謝謝！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n\nLL inv(LL x, LL y, LL p = 1, LL q = 0, LL r = 0, LL s = 1) {\n  return y ? p : inv(y, x % y, r, s, p - (x / y) * r, q - (x / y) * s);\n}\n\n// 使用條件：\n// (1) 0 <= x1 < m1; 0 <= x2 < m2\n// (2) m2 * m2 不會溢位。\n// (3) 2 * m1 * m2 不會溢位。\nLL CRT2(LL x1, LL m1, LL x2, LL m2) {\n  LL t = inv(m1, m2);\n  t %= m2;\n  LL z = (t * (x2 - x1) % m2 + m2) % m2;\n  return (x1 + z * m1) % (m1 * m2);\n}\n\nvoid solve() {\n  int N[3], R[3] = {};\n  for (int i = 0; i < 3; i++)\n    cin >> N[i];\n  for (int i = 0; i < 3; i++)\n    cin >> R[i];\n  vector<int> candidates[3];\n  for (int i = 0; i < 3; i++)\n    for (LL x = 0; x < N[i]; x++) {\n      if (x * x * x % N[i] == R[i]) {\n        candidates[i].push_back(x);\n      }\n    }\n  vector<LL> sol;\n\n  for (auto r1 : candidates[0])\n    for (auto r2 : candidates[1])\n      for (auto r3 : candidates[2]) {\n        LL x = CRT2(r1, N[0], r2, N[1]);\n        x = CRT2(x, (LL)N[0] * N[1], r3, N[2]);\n        sol.push_back(x);\n      }\n\n  sort(sol.begin(), sol.end());\n  int maxn = max(N[0], max(N[1], N[2]));\n  for (auto s : sol)\n    if (s * s > maxn || s * s * s > maxn) {\n      cout << s << endl;\n      break;\n    }\n}\n\nint main() {\n  int T;\n  cin >> T;\n  while (T--)\n    solve();\n  return 0;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"關於競程日記"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"🍅 如果您想到更多有趣漂亮簡單乾淨的解法話歡迎留言給競程日記小編群！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"ℹ️ 這是一篇投稿給"},{"type":"element","tagName":"a","properties":{"href":"https://www.facebook.com/%E7%AB%B6%E7%A8%8B%E6%97%A5%E8%A8%98-1514973425463954/"},"children":[{"type":"text","value":"競程日記"}]},{"type":"text","value":"的文章，歡迎大家投稿、交流與分享程式解題競賽的點點滴滴！"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"Cosmetic Survey","category":"prob","path":"/problem/icpc/asia_seoul_2018/B","date":"2019-01-27","description":"現在有 $m$ 種化妝品，讓 $n$ 個人來評分。每一個人都會給你一張列表，描述他們有多偏好這個化妝品。寫 1 表示最喜歡、寫 2 表示次喜歡，以此類推。如果是 0 表示都不喜歡（是在列表的最末端）。偏好順序允許重複。\n\n對於任兩種化妝品，我們可以定義 $d(X, Y)$ 為有多少人喜歡 $X$ 嚴格勝過 $Y$。如果 $d(X, Y) > d(Y, X)$，那麼我們可以在圖上定義一條邊、權重為 $d(X, Y)$。而任何從 $X$ 到 $Y$ 的路徑上，其最小的邊權重，的最大可能值，就被我們定義為 $S(X, Y)$。如果 $X$ 到 $Y$ 之間不存在任何路徑，就定義 $S(X, Y) = 0$。\n\n請找出所有可能的優勝化妝品 $X$：滿足對所有 $Y$ 都有 $S(X, Y) \\ge S(Y, X)$。\n","link":"https://codeforces.com/gym/101987","code":"ICPC-2018-SEOUL-B","difficulty":4,"oj":"codeforces-gym","tags":["ICPC 2018 Asia Seoul Regional"]},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"簡化後題目敘述"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"第一列包含兩個正整數 $m, n$ ($1\\le m, n\\le 500$)。第二列開始有 $n$ 列，每一列恰好有 $m$ 個介於 $0$ 到 $10^6$ 之間的整數，代表一個人依序對編號 $1$ 到 $m$ 的化妝品的偏好順序。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸出說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"請由小到大輸出所有可能的優勝化妝品編號。可以證明至少存在一個這樣的化妝品。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"3 4\n1 1 1\n0 0 0\n2 2 2\n3 3 3\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"1 2 3\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"4 5\n1 0 1 1\n1 1 5 2\n2 1 3 6\n0 1 0 1\n1 2 2 2\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"1 2\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 3"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"5 4\n0 1 0 2 1\n1 7 2 1 0\n4 5 2 3 3\n1 2 9 0 2\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"5\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ 連結"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://codeforces.com/gym/101987"},"children":[{"type":"text","value":"Codeforces Gym"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"題目出處"}]},{"type":"text","value":"：ICPC 2018 Asia Seoul Regional"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"直接按照定義找出每一個配對 $(X, Y)$ 之間的距離就可以了。"},{"type":"element","tagName":"a","properties":{"href":"https://en.wikipedia.org/wiki/Widest_path_problem"},"children":[{"type":"text","value":"最大瓶頸距離"}]},{"type":"text","value":"可以使用 Floyd-Warshall 演算法迅速解決。這樣的話時間複雜度是 $O(m^3+m^2n)$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"#include <bits/stdc++.h>\nusing namespace std;\n\nint g[505][505];\n\nint main() {\n  const int INF = 1e9;\n  int m, n;\n  cin >> m >> n;\n  for (int i = 1; i <= n; i++) {\n    vector<int> preference(m + 1);\n    for (int j = 1; j <= m; j++) {\n      cin >> preference[j];\n      if (preference[j] == 0)\n        preference[j] = INF;\n    }\n    for (int j = 1; j <= m; j++)\n      for (int k = j + 1; k <= m; k++)\n        if (preference[j] < preference[k]) {\n          g[j][k]++;\n        } else if (preference[j] > preference[k]) {\n          g[k][j]++;\n        }\n  }\n\n  for (int i = 1; i <= m; i++)\n    for (int j = i + 1; j <= m; j++)\n      if (g[i][j] == g[j][i])\n        g[i][j] = g[j][i] = 0;\n      else if (g[i][j] < g[j][i])\n        g[i][j] = 0;\n      else\n        g[j][i] = 0;\n\n  for (int k = 1; k <= m; k++)\n    for (int i = 1; i <= m; i++)\n      for (int j = 1; j <= m; j++)\n        if (i != j)\n          g[i][j] = max(g[i][j], min(g[i][k], g[k][j]));\n\n  vector<int> sol;\n  for (int i = 1; i <= m; i++) {\n    bool ok = true;\n    for (int j = 1; j <= m; j++)\n      if (g[i][j] < g[j][i])\n        ok = false;\n    if (ok)\n      sol.push_back(i);\n  }\n  for (auto x : sol)\n    cout << x << ' ';\n  cout << endl;\n  return 0;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"備註"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這道題目的模型其實是來自於 "},{"type":"element","tagName":"a","properties":{"href":"https://en.wikipedia.org/wiki/Schulze_method"},"children":[{"type":"text","value":"Schulze method"}]},{"type":"text","value":"，是一種透過提交偏好順序選出最佳若干選擇（可以不只選出一個）的選舉模型。從維基百科上面看起來，這個方法被廣泛地運用在"},{"type":"element","tagName":"a","properties":{"href":"https://en.wikipedia.org/wiki/Schulze_method#Users"},"children":[{"type":"text","value":"各種組織"}]},{"type":"text","value":"裡面。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"而最大瓶頸路徑問題可以在 $O(n^{(3+\\omega)/2})\\le O(n^{2.688})$ 時間內被"},{"type":"element","tagName":"a","properties":{"href":"https://dl.acm.org/citation.cfm?id=1496813"},"children":[{"type":"text","value":"求出"}]},{"type":"text","value":"。其中 $\\omega$ 是所有矩陣相乘演算法能夠做到的最小指數。（目前的紀錄是 2.373）。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"關於競程日記"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"🍅 如果您想到更多有趣漂亮簡單乾淨的解法話歡迎留言給競程日記小編群！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"ℹ️ 這是一篇投稿給"},{"type":"element","tagName":"a","properties":{"href":"https://www.facebook.com/%E7%AB%B6%E7%A8%8B%E6%97%A5%E8%A8%98-1514973425463954/"},"children":[{"type":"text","value":"競程日記"}]},{"type":"text","value":"的文章，歡迎大家投稿、交流與分享程式解題競賽的點點滴滴！"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"Insider's Identity","category":"prob","path":"/problem/icpc/asia_hanoi_2018/I","date":"2019-01-14","description":"在一個遙遠的星球上，一個情報單位打算派遣一些間諜到地球上進行偵查任務。\n為了確保偵查任務能夠在極為機密的情形下進行，情報單位打算指派每一個間諜一個秘密 ID。\n\n每一個 ID 由一個長度為 $n$ 的 01-字串 (binary string) 組成。\n為了避免敵人的滲透，情報單位選擇了一個由 `1` 和 `*` 組成的模版 $P$，如果這個模版能夠成功與 ID 進行配對，那麼就可以判斷這個 ID 為真。\n\n對於一個字串 $S=s_1s_2\\cdots s_n$ 以及一個模版 $P=p_1\\cdots p_m$ 成功配對的定義如下：\n\n* 若 $m = n$，而且對所有 $i$，要嘛 $s_i=$`1` 或 $p_i=$`*`。\n* 若 $m < n$，而且在 $S$ 內部存在一個長度為 $m$ 的子字串成功與 $P$ 配對。\n\n請幫助情報單位計算總共有多少 ID 可以使用。\n","link":"https://open.kattis.com/problems/insidersidentity","code":"ICPC-HANOI-2018-I","difficulty":6,"oj":"kattis","tags":["ICPC 2018 Asia Hanoi Regional"]},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"簡化後題目敘述"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"輸入的第一列包含一個正整數 $n$ $(1\\le n\\le 50)$ 表示 ID 的長度。\n第二列有一個由 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"1"}]},{"type":"text","value":" 和 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"*"}]},{"type":"text","value":" 組成的模版字串 $P$ $(1\\le |P|\\le 30)$，"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸出說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"輸出一個正整數表示長度為 $n$ 且滿足條件 $P$ 的字串數量。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"10 \n1\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"1023\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"3\n1*1\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"2\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ 連結"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://open.kattis.com/problems/insidersidentity"},"children":[{"type":"text","value":"Open Kattis - Insider's Indentity"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"題目出處"}]},{"type":"text","value":"：ICPC 2018 Asia Hanoi Regional"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這題一臉就是動態規劃囉。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"首先，我們可以注意到由於輸入模版的 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"*"}]},{"type":"text","value":" 不超過 15 個，因此全部把他們枚舉出來數量大概不會太多。\n考慮一個字串集合 $\\mathcal{S}$，我們想要知道有多少字串，使得至少有一個子字串出現在 $\\mathcal{S}$ 中，這是一個『試著不要重複計數』的技術問題。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"定義 $\\dp(i, \\mathit{suffix})$ 表示長度為 $i$ 的字串、其後綴字串為 $\\mathit{suffix}$、而且 $\\mathit{suffix}$ 是所有該字串後綴字串之中，出現在 $\\mathrm{prefix}(\\mathcal{S})$ 集合裡面"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"最長"}]},{"type":"text","value":"的那一個。其中 $\\mathrm{prefix}(\\mathcal{S})$ 是所有 $\\mathcal{S}$ 前綴字串所形成的集合。於是，對於每一個 $\\dp(i, \\mathit{suffix})$ 我們可以考慮把該狀態"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"推"}]},{"type":"text","value":"(push)到下一個狀態去"},{"type":"element","tagName":"footnote","properties":{"goto":"1","show":"備註1"},"children":[]},{"type":"text","value":"："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"$\\dp(i+1, \\delta(\\mathit{suffix} + \\texttt{\"0\"})) {\\texttt{ += }} \\dp(i, \\mathit{suffix})$"},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"\n$\\dp(i+1, \\delta(\\mathit{suffix} + \\texttt{\"1\"})) {\\texttt{ += }} \\dp(i, \\mathit{suffix})$"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"而事實上，$\\mathit{suffix} + \\texttt{\"0\"}$ 很可能不復存在於前綴集合 $\\mathrm{prefix}(\\mathcal{S})$ 了。\n因此我們需要一個轉移函數 $\\delta$，它可以幫我們不斷把字串的頭去掉，直到剩下來的字串出現在前綴集合，而此時我們不難證明這個剩下來的字串會是整個長度為 $i+1$ 字串中，最長出現在前綴集合的後綴字串（好拗口|||）"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"最後，如果 $\\mathit{suffix} + \\texttt{\"0\"}$ (或 $\\mathit{suffix} + \\texttt{\"1\"}$) 真的出現在 $\\mathcal{S}$ 裡面了，那麼代表所有落到 $\\dp(i+1, \\mathit{suffix} + \\texttt{\"0\"})$ 的字串都滿足題目要求，我們就直接把這個數量（乘上後面隨意補滿的 01-字串方法數）加到答案裡面，而不用轉移它了。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"為了加快查找的速度，我們可以一開始就把用得到的所有"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"狀態"}]},{"type":"text","value":"與"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"狀態轉移"}]},{"type":"text","value":"儲存下來，並且直接給他們一個編號。如此一來，實際計算動態規劃的轉移部分，可以完全使用陣列處理，提升了不少效率。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"由於每一個 suffix 都是長度不超過 30 的二元字串，我們可以用 $\\left(2^{\\text{suffix 長度}} + \\mathit{suffix}\\right)$ 這個整數來儲存。而轉移、匹配都可以用位元運算來處理。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n\n\nint main() {\n  int n;\n  string S;\n  cin >> n >> S;\n\n  // 枚舉所有可能的前綴集合。\n  vector<int> state_space;\n  function<void(int, int)> dfs = [&](int now, int i) {\n    state_space.push_back(now + (1<<i));\n    if (i + 1 < S.size()) {\n      if (S[i] == '*') dfs(now*2, i+1);\n      dfs(now*2+1, i+1);\n    }\n  };\n  dfs(0, 0);\n  sort(state_space.begin(), state_space.end());\n  state_space.resize(unique(state_space.begin(), state_space.end()) - state_space.begin());\n\n\n  // 產生不同長度的模版，用來比對。\n  vector<int> patterns = {0};\n  for (int i = 0, p = 0; i < (int)S.size(); i++) {\n    p = p * 2 + (S[i] == '1');\n    patterns.push_back(p);\n  }\n  \n  // 計算下一個狀態轉移。\n  const int DONE = -1;\n  auto GetNextValidState = [&](int state) -> int {\n    int len = 31 - __builtin_clz(state);\n    for (int i = len; i >= 0; i--) {\n      if ((state&patterns[i]) == patterns[i]) {\n        if (i == S.size()) {\n          // 如果已匹配整個字串，就可以停下來了。\n          return DONE;\n        } else {\n          // 取得離散化後的狀態編號。\n          int nxt = (1<<i) + (state & ((1<<i)-1));\n          return lower_bound(state_space.begin(), state_space.end(), nxt) - state_space.begin();\n        }\n      }\n    }\n    return 1;\n  };\n\n  // 對所有狀態，列出下一個狀態的編號。\n  vector<int> add0(state_space.size()), add1(state_space.size());\n  for (int i = 0; i < state_space.size(); i++) {\n    int state = state_space[i];\n    add0[i] = GetNextValidState(state*2);\n    add1[i] = GetNextValidState(state*2+1);\n  }\n  \n  // 開始跑動態規劃。\n  LL ans = 0;\n  vector<LL> dp(state_space.size(), 0);\n  dp[0] = 1;\n\n  for (int i = 1; i <= n; i++) {\n    vector<LL> dp_next(state_space.size(), 0);\n    for (int j = 0; j < state_space.size(); j++) {\n      if (add0[j] == DONE)\n        ans += dp[j] * (1LL<<(n-i));\n      else\n        dp_next[add0[j]] += dp[j];\n      if (add1[j] == DONE)\n        ans += dp[j] * (1LL<<(n-i));\n      else\n        dp_next[add1[j]] += dp[j];\n    }\n    dp.swap(dp_next);\n  }\n  cout << ans << endl;\n  return 0;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"關於競程日記"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"🍅 如果您想到更多有趣漂亮簡單乾淨的解法話歡迎留言給競程日記小編群！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"ℹ️ 這是一篇投稿給"},{"type":"element","tagName":"a","properties":{"href":"https://www.facebook.com/%E7%AB%B6%E7%A8%8B%E6%97%A5%E8%A8%98-1514973425463954/"},"children":[{"type":"text","value":"競程日記"}]},{"type":"text","value":"的文章，歡迎大家投稿、交流與分享程式解題競賽的點點滴滴！"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"Disks Arrangement","category":"prob","path":"/problem/icpc/asia_seoul_2018/C","date":"2019-01-25","description":"給你 $n$ 個圓盤，他們半徑分別是 $r_1, r_2, \\ldots, r_n$。已知這些圓盤中最大半徑與最小半徑的比值嚴格小於 $4$。這麼做有什麼好處呢？這麼做可以保證對於任意的圓盤排列 $\\sigma(1), \\sigma(2), \\ldots, \\sigma(n)$ 來說，若依照該排列將所有圓盤立直靠攏，那麼必定只會有相鄰的兩個圓盤碰到（如下圖 Figure C.1），而不會有如下圖 Figure C.2 的情形。\n\n![Imgur](https://i.imgur.com/BcifK4v.png)\n\n請找出在任意排列中，靠攏之後的圓盤寬度之最小值。\n","link":"https://codeforces.com/gym/101987","code":"ICPC-2018-SEOUL-C","difficulty":7,"oj":"codeforces-gym","tags":["ICPC 2018 Asia Seoul Regional","graph"]},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"簡化後題目敘述"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"輸入的第一列包含一個正整數 $n$ ($1\\le n\\le 1000$)，第二列包含 $n$ 個正整數代表圓盤的半徑，所有半徑都介於 $1$ 到 $10^6$ 之間。最大半徑與最小半徑的比值小於 $4$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸出說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"請輸出一個浮點數 $z$，表示圓盤擺放後的最小寬度，如果正確答案是 $OPT$，那麼你的輸出 $z$ 必須滿足 $OPT-10^{-5} < z < OPT + 10^{-5}$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"4\n4 2 7 6\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"34.99452\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"5\n13 7 4 15 10\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"90.14124\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ 連結"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://codeforces.com/gym/101987"},"children":[{"type":"text","value":"Codeforces Gym"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"題目出處"}]},{"type":"text","value":"：ICPC 2018 Asia Seoul Regional"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"不妨假設所有的半徑是由小到大排好順序的：$r_1\\le r_2\\le\\cdots\\le r_n$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"假設有兩個圓盤半徑分別為 $r_i$ 與 $r_j$。把這兩個圓盤緊靠的時候，其圓心之間的距離是 $2\\sqrt{r_ir_j}$。我們構造一個有 $n+1$ 個點的"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"加權無向完全圖"}]},{"type":"text","value":"，其頂點編號為 $\\set{0, 1, \\ldots, n}$。對於所有的 $1\\le i, j\\le n$，定義 $(i, j)$ 這條邊的權重 $w(i, j) = 2\\sqrt{r_ir_j}$。此外，對於所有的 $1\\le j\\le n$，定義 $w(0, j)=r_j$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"定義完畢以後，我們會不小心發現所求的值就"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"恰恰好"}]},{"type":"text","value":"是這個圖上計算"},{"type":"element","tagName":"a","properties":{"href":"https://zh.wikipedia.org/wiki/%E6%97%85%E8%A1%8C%E6%8E%A8%E9%94%80%E5%91%98%E9%97%AE%E9%A2%98"},"children":[{"type":"text","value":"旅行銷售員問題（Travelling Salesman Problem, TSP）"}]},{"type":"text","value":"的解。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果大家有聽過 TSP 問題的話，應該會知道在一般情形下這個問題是 NP-完備的。如果出在比賽中，$n$ 又大成這樣，想必事有蹊蹺。推敲至此，不難判斷——這題定是個結論題！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"因此對於該題最一般的通解就是：隨意生出一些小測資，並觀察解的規律。然後就可以構造答案了。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"依稀記得在 "},{"type":"element","tagName":"a","properties":{"href":"https://www.facebook.com/notes/%E8%B3%87%E8%A8%8A%E7%AB%B6%E8%B3%BD%E9%81%B8%E6%89%8B%E6%96%B0%E6%89%8B%E6%9D%91/toi-2018-%E9%A1%8C%E7%9B%AE%E6%87%B6%E4%BA%BA%E5%8C%85/2083123898642973/"},"children":[{"type":"text","value":"TOI 2018 選訓營"}]},{"type":"text","value":" 有一道奇怪的佔總分只有 3 分的子題，就是在滿足"},{"type":"element","tagName":"a","properties":{"href":"https://en.wikipedia.org/wiki/Monge_array"},"children":[{"type":"text","value":"四邊形不等式"}]},{"type":"text","value":"（不管他是凹還是凸）的對稱矩陣"},{"type":"element","tagName":"footnote","properties":{"goto":"1","show":"備註1"},"children":[]},{"type":"text","value":"（對應到無向圖）中，解決 TSP 問題。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"遺憾的是，我們構造的圖不完全滿足四邊形不等式。好消息是，把 $0$ 那點移除以後，剩下的矩陣（不妨讓對角線就等於 $2r_i$）會滿足四邊形不等式。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"從 "},{"type":"element","tagName":"a","properties":{"href":"http://alexandria.tue.nl/openaccess/Metis211810.pdf"},"children":[{"type":"text","value":"這篇文章"}]},{"type":"text","value":" 當中可以看出一些端倪～如果我們要在剩下的矩陣中找 TSP，那麼正確答案的"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"環狀排列"}]},{"type":"text","value":"總是以下兩個其中一種："}]},{"type":"text","value":"\n$$\n\\begin{cases}\n\\sigma_1 = \\langle 1, 3, 5, 7, 9, 11, 13, \\ldots, 14, 12, 10, 8, 6, 4, 2\\rangle\\\\\n\\sigma_2 = \\langle n, 2, n-2, 4, n-4, 6, \\ldots, 5, n-3, 3, n-1, 1\\rangle\n\\end{cases}\n$$\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這裡要強調的是環狀排列。這題的答案會是把 $\\sigma_2$ 旋轉至中間（$n/2$ 附近），原因是因為加上兩邊的圓盤邊邊以後，我們建構的圖上，真正的 TSP 會等於「拿掉 $0$ 這個點以後，剩下圖的 TSP」 額外加上一個 $(\\sqrt{r_x} - \\sqrt{r_y})^2$，而總覺得可以透過某些證明（這裡空間不夠了我應該寫不出來（說不定可能是錯的？））保證選取旋轉至中間的 $\\sigma_2$ 會是答案。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我的程式碼有點偷懶，沒有旋轉到中間，乾脆每個地方都轉一轉，看看找出來的值誰最小。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  int n;\n  cin >> n;\n  vector<double> a(n);\n  for (int i = 0; i < n; i++)\n    cin >> a[i];\n  sort(a.begin(), a.end());\n\n  // 構造我們要的 sigma_2\n  vector<int> p(n + 1);\n  for (int i = 0; i < n; i++)\n    p[i] = i;\n  for (int i = 1, j = n - 2; i < j; i += 2, j -= 2)\n    swap(p[i], p[j]);\n  p[n] = p[0];\n\n  // 計算 TSP 的結果。\n  long double sum = 0;\n  for (int i = 0; i < n; i++) {\n    sum += 2 * sqrtl(a[p[i]] * a[p[i + 1]]);\n  }\n\n  // 然後遍歷相鄰的邊，加上額外的 cost，找出最小值。\n  long double best =\n      a[p[0]] + a[p[n - 1]] + sum - 2 * sqrtl(a[p[0]] * a[p[n - 1]]);\n  for (int i = 0; i + 1 < n; i++) {\n    best = min(best,\n               a[p[i]] + a[p[i + 1]] + sum - 2 * sqrtl(a[p[i]] * a[p[i + 1]]));\n  }\n  cout << fixed << setprecision(9) << best << endl;\n  return 0;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"備註 1"},{"type":"element","tagName":"footnote","properties":{"here":"1"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"滿足四邊形不等式的矩陣叫做 Monge Array。如果它剛好是個"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"對稱"}]},{"type":"text","value":"的方陣的話，那就叫做 "},{"type":"element","tagName":"a","properties":{"href":"https://en.wikipedia.org/wiki/Supnick_matrix"},"children":[{"type":"text","value":"Supnick Matrix"}]},{"type":"text","value":"。要注意的是我們這題的不等式符號是反的。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"備註 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"有空來介紹 "},{"type":"element","tagName":"a","properties":{"href":"https://openaccess.nhh.no/nhh-xmlui/bitstream/handle/11250/164224/Halskau_2000.pdf?sequence=1&isAllowed=y"},"children":[{"type":"text","value":"100種你所不知道的 TSP"}]},{"type":"text","value":" 好了XD~"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"關於競程日記"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"🍅 如果您想到更多有趣漂亮簡單乾淨的解法話歡迎留言給競程日記小編群！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"ℹ️ 這是一篇投稿給"},{"type":"element","tagName":"a","properties":{"href":"https://www.facebook.com/%E7%AB%B6%E7%A8%8B%E6%97%A5%E8%A8%98-1514973425463954/"},"children":[{"type":"text","value":"競程日記"}]},{"type":"text","value":"的文章，歡迎大家投稿、交流與分享程式解題競賽的點點滴滴！"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"Circuits","category":"prob","path":"/problem/icpc/asia_seoul_2018/A","date":"2019-01-24","description":"給平面上 $n$ 個矩形，問任意兩條水平線能夠切過的矩形數量的最大值。（切在矩形邊上也算數）。\n","link":"https://codeforces.com/gym/101987","code":"ICPC-2018-SEOUL-A","difficulty":4,"oj":"codeforces-gym","tags":["ICPC 2018 Asia Seoul Regional"]},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"簡化後題目敘述"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"第一列包含整數 $n$ ($3\\le n\\le 100000$)。接下來的 $n$ 列每一列包含四個整數 $u_x, u_y, v_x, v_y$ ($u_x < v_x$ 且 $u_y > v_y$) 表示一個矩形的兩個角落座標，其中 $(u_x, u_y)$ 是左上角、而 $(v_x, v_y)$ 是右下角。所有座標範圍都在 $-10^7$ 和 $10^7$ 之間。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸出說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"輸出兩條水平線能切出的最大矩形數量。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"5\n0 13 4 4\n2 14 11 9\n7 17 12 12\n3 5 16 0\n5 2 13 1\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"5\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"5\n0 4 4 0\n1 3 3 1\n5 8 9 4\n0 12 4 8\n1 11 3 9\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"4\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ 連結"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://codeforces.com/gym/101987"},"children":[{"type":"text","value":"Codeforces Gym"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"題目出處"}]},{"type":"text","value":"：ICPC 2018 Asia Seoul Regional"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這題是線段樹/區間樹很直接的應用。由於切割的都是水平線，對於每一個輸入的矩形只要考慮它的 Y-座標區間就可以了。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"利用掃描線的概念，考慮其中 Y-座標較低的那條線的位置（比方說讓一個變數 $y_0$ 從下到上慢慢推進）。固定了這條線 $y=y_0$ 以後，問題便轉化為：從所有比這條線還要高的區間中，找出一個 $y$ 值使得戳到的區間數量最大。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"隨著 $y_0$ 值變大，比這條線還要高的區間，會一個一個減少。因此我們需要一種動態資料結構，支援把區間移除後，仍可以找出能戳到最多區間的水平線。一個簡單的想法是直接使用區間樹，在 $y_0$ 值變大的時候逐步把踩到的區間移除。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"下面的程式碼從另一個方向處理區間樹的操作。我們先對所有區間 $I_0, I_1, \\ldots, I_{n-1}$ 依照左界排序（這個順序就是當 $y_0$ 變大的時候，會依序移除區間的順序）。然後我們倒著順序把區間一個一個加入線段樹，並且計算區間們 $I_i, I_{i+1}, \\ldots, I_{n-1}$ 的最大重疊數量（儲存在 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"localmax[i]"}]},{"type":"text","value":" 這個變數裡面）。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"預處理完畢以後，我們讓 $y_0$ 沿著離散化後的區間座標一路遞增，紀錄當前 $y=y_0$ 切到的區間數量（"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"now"}]},{"type":"text","value":"），並且找出最小的 $j$ 使得 $I_j$ 左界是嚴格大於 $y_0$ 的。我們的所求就是（"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"now + localmax[j]"}]},{"type":"text","value":"）"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"#include <bits/stdc++.h>\nusing namespace std;\n\n// 離散化：把所有需要的座標記錄下來，排序以後換成離散化後的座標。\nint discretize(vector<pair<int, int>> &a) {\n  vector<int> lisan;\n  for (auto &it : a) {\n    lisan.push_back(it.first);\n    lisan.push_back(it.second);\n  }\n  sort(lisan.begin(), lisan.end());\n  lisan.resize(unique(lisan.begin(), lisan.end()) - lisan.begin());\n  for (size_t i = 0; i < a.size(); i++) {\n    a[i].first =\n        lower_bound(lisan.begin(), lisan.end(), a[i].first) - lisan.begin() + 1;\n    a[i].second = lower_bound(lisan.begin(), lisan.end(), a[i].second) -\n                  lisan.begin() + 1;\n  }\n  return lisan.size();\n}\n\n// 區間樹的節點要存的東西。\nstruct Node {\n  int max, sum;\n  Node(int _max = 0, int _sum = 0) : max(_max), sum(_sum) {}\n};\n\nint main() {\n  // 輸入很大所以要加快讀取輸入的速度。\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n\n  vector<pair<int, int>> a;\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    int ux, uy, vx, vy;\n    cin >> ux >> uy >> vx >> vy;\n    a.emplace_back(vy, uy);\n  }\n  // Ranges become [1, m].\n  int m = discretize(a);\n  sort(a.begin(), a.end());\n\n  // Find best offset for an interval tree.\n  int offset = m + 1;\n  while ((offset & -offset) != offset)\n    offset += (offset & -offset);\n\n  vector<int> localmax(n + 1, 0);\n  vector<Node> segtree(2 * offset);\n  const auto pull = [&](int x) {\n    if (x >= offset) {\n      segtree[x].max = segtree[x].sum;\n    } else {\n      segtree[x].max =\n          max(segtree[x * 2].max, segtree[x * 2 + 1].max) + segtree[x].sum;\n    }\n  };\n  auto add_segment = [&](int x, int v) {\n    while (x) {\n      if (x % 2 == 0) {\n        segtree[x].sum += v;\n        pull(x);\n        --x;\n      } else {\n        x /= 2;\n        pull(x + 1);\n      }\n    }\n  };\n\n  for (int i = n - 1; i >= 0; i--) {\n    add_segment(offset + a[i].second, 1);\n    add_segment(offset + a[i].first - 1, -1);\n    localmax[i] = segtree[1].max;\n  }\n\n  vector<int> change(m + 2);\n  for (int i = 0; i < n; i++) {\n    change[a[i].first]++;\n    change[a[i].second + 1]--;\n  }\n  int ans = 0;\n  for (int i = 0, j = 0, now = 0; i <= m; i++) {\n    while (j < n && a[j].first <= i)\n      ++j;\n    now += change[i];\n    ans = max(ans, now + localmax[j]);\n  }\n\n  cout << ans << endl;\n  return 0;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"關於競程日記"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"🍅 如果您想到更多有趣漂亮簡單乾淨的解法話歡迎留言給競程日記小編群！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"ℹ️ 這是一篇投稿給"},{"type":"element","tagName":"a","properties":{"href":"https://www.facebook.com/%E7%AB%B6%E7%A8%8B%E6%97%A5%E8%A8%98-1514973425463954/"},"children":[{"type":"text","value":"競程日記"}]},{"type":"text","value":"的文章，歡迎大家投稿、交流與分享程式解題競賽的點點滴滴！"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"Flying Squirrel","category":"prob","path":"/problem/icpc/asia_nakhon_pathom_2018/A","date":"2019-02-23","description":"f\n","link":"https://codeforces.com/gym/102091","code":"ICPC-2018-NAKHON-PATHOM-H","difficulty":6,"oj":"codeforces-gym","tags":["ICPC 2018 Asia Nakhon Pathom Regional"]},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"簡化後題目敘述"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"display","properties":{"input-format":""},"children":[{"type":"text","value":"\n    "},{"type":"element","tagName":"variable","properties":{"type":"int","id":"N","ge":"1","le":"10"},"children":[]},{"type":"text","value":"\n    "},{"type":"element","tagName":"variable","properties":{"type":"int","id":"M","ge":"1","le":"10"},"children":[]},{"type":"text","value":"\n    "},{"type":"element","tagName":"variable","properties":{"array":"","size":"N","type":"int","id":"H","ge":"1","le":"N"},"children":[]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸出說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"對於每筆測試資料輸出題目所求的 $x$ 值。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"2\n6 11 19\n5 4 11\n25 36 7\n16 0 6\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"5\n6\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ 連結"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://codeforces.com/gym/102091"},"children":[{"type":"text","value":"Codeforces Gym"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"題目出處"}]},{"type":"text","value":"：ICPC 2018 Asia Nakhon Pathom Regional"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"對於輸入的三個 $x^3\\bmod N_i$ 值來說，如果我們能分別找出所有可能的 $x\\bmod N_i$ ($i=1,2,3$)，那麼就可以利用"},{"type":"element","tagName":"a","properties":{"href":"https://zh.wikipedia.org/wiki/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86"},"children":[{"type":"text","value":"中國剩餘定理"}]},{"type":"text","value":"，對所有可能的組合，計算出可能的 $x$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這題的測試資料看起來不太嚴謹。如果有發現可能有錯誤的地方再麻煩跟我說～謝謝！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n\nLL inv(LL x, LL y, LL p = 1, LL q = 0, LL r = 0, LL s = 1) {\n  return y ? p : inv(y, x % y, r, s, p - (x / y) * r, q - (x / y) * s);\n}\n\n// 使用條件：\n// (1) 0 <= x1 < m1; 0 <= x2 < m2\n// (2) m2 * m2 不會溢位。\n// (3) 2 * m1 * m2 不會溢位。\nLL CRT2(LL x1, LL m1, LL x2, LL m2) {\n  LL t = inv(m1, m2);\n  t %= m2;\n  LL z = (t * (x2 - x1) % m2 + m2) % m2;\n  return (x1 + z * m1) % (m1 * m2);\n}\n\nvoid solve() {\n  int N[3], R[3] = {};\n  for (int i = 0; i < 3; i++)\n    cin >> N[i];\n  for (int i = 0; i < 3; i++)\n    cin >> R[i];\n  vector<int> candidates[3];\n  for (int i = 0; i < 3; i++)\n    for (LL x = 0; x < N[i]; x++) {\n      if (x * x * x % N[i] == R[i]) {\n        candidates[i].push_back(x);\n      }\n    }\n  vector<LL> sol;\n\n  for (auto r1 : candidates[0])\n    for (auto r2 : candidates[1])\n      for (auto r3 : candidates[2]) {\n        LL x = CRT2(r1, N[0], r2, N[1]);\n        x = CRT2(x, (LL)N[0] * N[1], r3, N[2]);\n        sol.push_back(x);\n      }\n\n  sort(sol.begin(), sol.end());\n  int maxn = max(N[0], max(N[1], N[2]));\n  for (auto s : sol)\n    if (s * s > maxn || s * s * s > maxn) {\n      cout << s << endl;\n      break;\n    }\n}\n\nint main() {\n  int T;\n  cin >> T;\n  while (T--)\n    solve();\n  return 0;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"關於競程日記"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"🍅 如果您想到更多有趣漂亮簡單乾淨的解法話歡迎留言給競程日記小編群！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"ℹ️ 這是一篇投稿給"},{"type":"element","tagName":"a","properties":{"href":"https://www.facebook.com/%E7%AB%B6%E7%A8%8B%E6%97%A5%E8%A8%98-1514973425463954/"},"children":[{"type":"text","value":"競程日記"}]},{"type":"text","value":"的文章，歡迎大家投稿、交流與分享程式解題競賽的點點滴滴！"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"Parentheses","category":"prob","path":"/problem/icpc/asia_seoul_2018/F","date":"2019-01-28","description":"給你一個用 26 個英文字母當作運算子、加減乘除當作運算元、可能會包含括弧的算式。請你判斷這是否為一個合法的算式，如果是的話，是否有使用標準括弧規範？（也就是每個括弧內恰好對應到唯一的運算子。）\n","link":"https://codeforces.com/gym/101987","code":"ICPC-2018-SEOUL-F","difficulty":3,"oj":"codeforces-gym","tags":["ICPC 2018 Asia Seoul Regional"]},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"簡化後題目敘述"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"輸入僅有一列，包含題目所述之算式。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸出說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"輸出 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"proper"}]},{"type":"text","value":", "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"improper"}]},{"type":"text","value":" 或是 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"error"}]},{"type":"text","value":"。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"a + a\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"proper\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"(b+( a+c )) + b\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"proper\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 3"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"c + ((b) + a)\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 3"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"improper\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 4"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"c+(a%/b)\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 4"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"error\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 5"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"x + ((y + z)\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 5"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"error\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 6"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"a b + (c + b)\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 6"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"error\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 7"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"x + y + z\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 7"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"improper\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ 連結"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://codeforces.com/gym/101987"},"children":[{"type":"text","value":"Codeforces Gym"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"題目出處"}]},{"type":"text","value":"：ICPC 2018 Asia Seoul Regional"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"可以直接用堆疊模擬，把同一個括弧層看到的東西，用一個字串表示的話應該要是「運算元、運算子、運算元、運算子、...、運算元」交錯排列。如果是 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"proper"}]},{"type":"text","value":" 的話，有括弧的情形必須要恰好僅有一個運算子。最外層要特判一下這樣。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"或許會有更短也不容易寫錯的寫法？"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"#include <bits/stdc++.h>\nusing namespace std;\n\nbool proper = true;\nbool correct = true;\n\nstring S;\n\nstring RemoveSpace(string& S) {\n  string T = \"\";\n  for (auto x: S) if (x != ' ') T += x;\n  return T;\n}\n\n// 合法的序列會是 x+x+x+...+x\nvoid UpdateCorrectness(vector<char>& c) {\n  if (c.size()%2==0) { correct = false; return; }\n  for (size_t i = 1; i < c.size(); i++)\n    if (c[i] == c[i-1]) {\n      correct = false;\n      return;\n    }\n  if (c[0] != 'x') { correct = false; return; }\n}\n\nint main() {\n  getline(cin, S);\n  S = RemoveSpace(S);\n  vector<vector<char>> levels(1);\n  for (size_t i = 0, now = 1; i < S.size(); i++) {\n    if (S[i] == '(') {\n      levels.back().push_back('x');\n      ++now;\n      levels.resize(now);\n    } else if (S[i] == ')') {\n      UpdateCorrectness(levels.back());\n      if (levels.back().size() != 3) proper = false;\n      levels.pop_back();\n      --now;\n      if (now <= 0) {\n        correct = false;\n        break;\n      }\n      levels.resize(now);\n    } else if (S[i] >= 'a' && S[i] <= 'z') {\n      levels.back().push_back('x');\n    } else {\n      levels.back().push_back('+');\n    }\n  }\n\n  if (levels.size() != 1) {\n    correct = false;\n  } else {\n    UpdateCorrectness(levels[0]);\n    if (S[0] == '(' && levels[0].size() == 1) proper = false;\n    if (levels[0].size() != 1 && levels[0].size() != 3) proper = false;\n  }\n \n  if (correct && proper) {\n    cout << \"proper\" << endl;\n  } else if (correct && !proper) {\n    cout << \"improper\" << endl;\n  } else if (!correct) {\n    cout << \"error\" << endl;\n  }\n  return 0;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"關於競程日記"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"🍅 如果您想到更多有趣漂亮簡單乾淨的解法話歡迎留言給競程日記小編群！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"ℹ️ 這是一篇投稿給"},{"type":"element","tagName":"a","properties":{"href":"https://www.facebook.com/%E7%AB%B6%E7%A8%8B%E6%97%A5%E8%A8%98-1514973425463954/"},"children":[{"type":"text","value":"競程日記"}]},{"type":"text","value":"的文章，歡迎大家投稿、交流與分享程式解題競賽的點點滴滴！"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"LED","category":"prob","path":"/problem/icpc/asia_seoul_2018/E","date":"2019-01-26","description":"給你 $n$ 筆資料點 $(v_i, l_i)$。你的目標是要找出一個由參數 $0< V_1< V_2$ 以及 $0\\le L_1 \\le L_2$ 定義出來的三階段函數 $F(v) = \\begin{cases}\n0 & \\text{if } 0\\le v < V_1\\\\\nL_1 & \\text{if } V_1\\le v < V_2\\\\\nL_2 & \\text{if } v\\ge V_2\n\\end{cases}$，使得這個函數引出的誤差值最小。誤差的定義如下：\n$ \\text{error}(F) = \\max_{1\\le i\\le n}|l_i - F(v_i)|\\text{。}\n$\n","link":"https://codeforces.com/gym/101987","code":"ICPC-2018-SEOUL-E","difficulty":4,"oj":"codeforces-gym","tags":["ICPC 2018 Asia Seoul Regional"]},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"簡化後題目敘述"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"第一列有一個正整數 $n$ （$1\\le n\\le 300000$）。接下來的 $n$ 列每一列有兩個整數 $v_i, l_i$，這些數字都介於 $0$ 到 $10^9$ 之間。輸入保證所有 $v_i$ 都不重複。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸出說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"輸出最小誤差值，精確到小數點以下第一位。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"5\n0 0\n2 1\n3 5\n6 7\n7 11\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"1.0\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"10\n5 9\n8 9\n0 0\n23 18\n26 18\n2 0\n3 0\n13 9\n18 9\n21 18\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"0.0\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ 連結"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://codeforces.com/gym/101987"},"children":[{"type":"text","value":"Codeforces Gym"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"題目出處"}]},{"type":"text","value":"：ICPC 2018 Asia Seoul Regional"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"可以對答案做二分搜：如果存在一個誤差 $\\le  x$ 的函數，那就會存在一個誤差 $\\le x'$ 的函數（$x \\le x'$）。於是只要有個方法判斷對於給定誤差值 $x$，是否存在一個函數 $F$ 其誤差值 $\\le x$ 就行了。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"固定好誤差值以後，我們可以試圖把序列分成連續的三段。顯然第一段可以盡可能地把 $\\le x$ 的那些數字吃掉。接下來得要判斷能否將剩下的數字分成兩段，並決定 $L_1$ 與 $L_2$ 的值並使得兩段的誤差值皆 $\\le x$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"若存在一個誤差值不超過 $x$ 的函數，那麼指定 $L_1= (\\text{第二段的最大值})-x$、以及 $L_2=(\\text{第二與第三段的最大值})-x$ 也得是一個誤差不超過 $x$ 的函數。我們可以用線性時間預處理這兩個值，並且判斷它們是否滿足題目要求。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"下面程式碼有很多地方可以省略不算，但是為了保持結構的完整性我還是把他們都寫下來了。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"有個很心機的地方，要注意到當輸入的 $(v, l)$ 數對裡面的 $v=0$ 的時候，不能把 $l$ 算入第二段或第三段。為了避免它影響二分搜的實作，這種情形出現時，不妨就直接定為二分搜的值 $x$ 的下界吧。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"#include <bits/stdc++.h>\nusing namespace std;\n\nbool test(const vector<int> &a, int twice_x) {\n  int n = a.size();\n  vector<int> lmax(n), rmax(n), lmin(n), rmin(n);\n\n  // 找出第一段。\n  int start = 0;\n  while (start < n && a[start] * 2 <= twice_x)\n    start++;\n  if (start >= n - 1)\n    return true;\n\n  // 處理第二段與第三段。\n  lmax[start] = a[start];\n  lmin[start] = a[start];\n  rmax[n - 1] = a[n - 1];\n  rmin[n - 1] = a[n - 1];\n\n  for (int i = start + 1; i < n; i++) {\n    lmax[i] = max(lmax[i - 1], a[i]);\n    lmin[i] = min(lmin[i - 1], a[i]);\n  }\n  for (int i = n - 2; i >= start; i--) {\n    rmax[i] = max(rmax[i + 1], a[i]);\n    rmin[i] = min(rmin[i + 1], a[i]);\n  }\n\n  // 枚舉可能的分界點。\n  for (int i = start; i + 1 < n; i++) {\n    int L1_minus_x = lmax[i] - twice_x;\n    int L2_minus_x = rmax[start] - twice_x;\n    if (L1_minus_x <= lmin[i] && L2_minus_x <= rmin[i + 1])\n      return true;\n  }\n\n  return false;\n}\n\nint main() {\n  // 輸入檔比較大，所以要用較快的輸入方式。\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n\n  int n;\n  cin >> n;\n  vector<pair<int, int>> input;\n  for (int i = 0; i < n; i++) {\n    int x, y;\n    cin >> x >> y;\n    input.emplace_back(x, y);\n  }\n  sort(input.begin(), input.end());\n\n  // 把輸入轉存到陣列裡面，v值排好序以後就不需要了。\n  vector<int> a;\n  for (auto it : input)\n    a.push_back(it.second);\n\n  // 定義二分搜的左右界。\n  long long l = (input[0].first == 0 ? a[0] * 2 : 0), r = 2e9, ans = 2e9;\n  while (l <= r) {\n    long long m = (l + r) / 2;\n    if (test(a, m)) {\n      ans = m;\n      r = m - 1;\n    } else {\n      l = m + 1;\n    }\n  }\n\n  cout << ans / 2 << \".\" << (ans % 2 * 5) << endl;\n  return 0;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"備註"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這題畢竟只是一連串的「連續片段最大值、最小值查詢」。因此如果我們使用 "},{"type":"element","tagName":"a","properties":{"href":"https://en.wikipedia.org/wiki/Range_minimum_query"},"children":[{"type":"text","value":"RMQ問題"}]},{"type":"text","value":" 的相關演算法——包含 $O(n)-O(1)$ 的預處理（+/-1 RMQ、建立最大值與最小值的稀疏表格 Sparse Table），再加上使用三分搜找出第二與第三段之間的分界，整題的時間複雜度可以變成 $O(n+\\log C\\log n)$。再用力一點的話可以把二分搜的部份離散化，作到 $O(n+\\log^2 n) = O(n)$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"關於競程日記"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"🍅 如果您想到更多有趣漂亮簡單乾淨的解法話歡迎留言給競程日記小編群！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"ℹ️ 這是一篇投稿給"},{"type":"element","tagName":"a","properties":{"href":"https://www.facebook.com/%E7%AB%B6%E7%A8%8B%E6%97%A5%E8%A8%98-1514973425463954/"},"children":[{"type":"text","value":"競程日記"}]},{"type":"text","value":"的文章，歡迎大家投稿、交流與分享程式解題競賽的點點滴滴！"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"TV Show Game","category":"prob","path":"/problem/icpc/asia_seoul_2018/K","date":"2019-01-23","description":"舞台上有 $k$ （$k\\ge 3$）盞燈，每一盞燈可以設定成紅色 `R` 或藍色 `B`。現在有 $n$ 個要求：每一個要求內容都包含三個條件，每個條件都以 $(l, c)$ 表示，代表第 $l$ 盞燈設定為顏色 $c$。只要滿足兩個以上的條件，就算滿足了該要求。\n\n若存在一組設定燈的顏色的方法，請輸出任何一組解。否則輸出 `-1`。\n","link":"https://codeforces.com/gym/101987","code":"ICPC-2018-SEOUL-K","difficulty":5,"oj":"codeforces-gym","tags":["ICPC 2018 Asia Seoul Regional"]},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"簡化後題目敘述"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"第一列包含兩個正整數 $k, n$ ($3 < k\\le 5000, 1\\le n\\le 10000$)。第二列開始每一列包含三個形如 $(l, c)$ 的條件，皆以空白隔開。（$1\\le l \\le k, c\\in \\set{{\\tt R}, {\\tt B}}$）"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸出說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果存在一個可行解，請輸出一個長度為 $k$ 的字串，其中第 $i$ 個字元代表了第 $i$ 盞燈的顏色。若不存在解的話請輸出 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"-1"}]},{"type":"text","value":"。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"7 5\n3 R 5 R 6 B\n1 B 2 B 3 R\n4 R 5 B 6 B\n5 R 6 B 7 B\n1 R 2 R 4 R\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"BRRRBBB\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"5 6\n1 B 3 R 4 B\n2 B 3 R 4 R\n1 B 2 R 3 R\n3 R 4 B 5 B\n3 B 4 B 5 B\n1 R 2 R 4 R\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"-1\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ 連結"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://codeforces.com/gym/101987"},"children":[{"type":"text","value":"Codeforces Gym"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"題目出處"}]},{"type":"text","value":"：ICPC 2018 Asia Seoul Regional"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這個問題乍看之下非常的 "},{"type":"element","tagName":"a","properties":{"href":"https://en.wikipedia.org/wiki/Boolean_satisfiability_problem"},"children":[{"type":"text","value":"3-SAT"}]},{"type":"text","value":"，但是多了「至少要滿足兩個以上」這個條件後，這個問題變成了 MAJ-3-SAT。而加強了條件的 MAJ-3-SAT 問題可以輕鬆轉化成 "},{"type":"element","tagName":"a","properties":{"href":"https://en.wikipedia.org/wiki/2-satisfiability"},"children":[{"type":"text","value":"2-SAT"}]},{"type":"text","value":" 的問題，於是能在多項式（線性）時間內解掉。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"（廣義版的 MAJ-SAT，即不限定每一個要求內含的條件數量。這個問題是 "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"PP"}]},{"type":"text","value":"-complete 的。按照 "},{"type":"element","tagName":"a","properties":{"href":"https://en.wikipedia.org/wiki/PP_(complexity)"},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"PP"}]}]},{"type":"text","value":" 的定義來看，它同時包含了 "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"NP"}]},{"type":"text","value":" 以及 "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"co-NP"}]},{"type":"text","value":"，因此難度看起來比一般的 "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"SAT"}]},{"type":"text","value":" 還高。但意外有趣的是，MAX-3-SAT 簡單很多。）"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"對於每一個要求 $(\\text{條件一} \\lor \\text{條件二}\\lor\\text{條件三})$，如果得滿足至少兩個條件的話，就會完全等價於拆成三個至少滿足一個條件的要求："}]},{"type":"text","value":"\n$$\n(\\text{條件一} \\lor \\text{條件二})\\land (\\text{條件二}\\lor\\text{條件三}) \\land (\\text{條件三}\\lor\\text{條件一})\n$$\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"於是，我們就可以利用一般解決 "},{"type":"element","tagName":"a","properties":{"href":"https://en.wikipedia.org/wiki/2-satisfiability"},"children":[{"type":"text","value":"2-SAT"}]},{"type":"text","value":" 的演算法（建立一個"},{"type":"element","tagName":"a","properties":{"href":"https://en.wikipedia.org/wiki/Implication_graph"},"children":[{"type":"text","value":"關聯圖 Implication Graph"}]},{"type":"text","value":"，然後計算"},{"type":"element","tagName":"a","properties":{"href":"https://en.wikipedia.org/wiki/Strongly_connected_component"},"children":[{"type":"text","value":"強連通元件 Strongly Connected Component"}]},{"type":"text","value":"，然後再用貪求法找出一組解。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"下面我們使用 "},{"type":"element","tagName":"a","properties":{"href":"https://en.wikipedia.org/wiki/Kosaraju%27s_algorithm"},"children":[{"type":"text","value":"Kosaraju 演算法"}]},{"type":"text","value":" 計算強連通元件"},{"type":"element","tagName":"footnote","properties":{"goto":"1","show":"備註1"},"children":[]},{"type":"text","value":"。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"#include <bits/stdc++.h>\nusing namespace std;\n\nclass Graph {\npublic:\n  int n;\n  vector<vector<int>> adj;\n  vector<vector<int>> rev;\n  vector<int> scc;\n  vector<int> visited;\n  vector<vector<int>> groups;\n  int nscc;\n  Graph(int _n) : n(_n) {\n    adj.resize(n);\n    rev.resize(n);\n    visited.resize(n, 0);\n    scc.resize(n, 0);\n    groups.resize(n+1);\n    nscc = 0;\n  }\n  void AddEdge(int x, int y) {\n    adj[x].push_back(y);\n    rev[y].push_back(x);\n  }\n  void ComputeSCC() {\n    vector<int> stack;\n    for (int i = 0; i < n; i++)\n      if (visited[i] == 0)\n        _dfs1(stack, i);\n    while (!stack.empty()) {\n      int x = stack.back();\n      stack.pop_back();\n      if (visited[x] == 1) {\n        ++nscc;\n        _dfs2(x);\n      }\n    }\n  }\n\nprivate:\n  void _dfs1(vector<int> &stack, int x) {\n    visited[x] = 1;\n    for (int y : adj[x])\n      if (visited[y] == 0)\n        _dfs1(stack, y);\n    stack.push_back(x);\n  }\n  void _dfs2(int x) {\n    visited[x] = 2;\n    scc[x] = nscc;\n    groups[nscc].push_back(x);\n    for (int y : rev[x])\n      if (visited[y] == 1)\n        _dfs2(y);\n  }\n};\n\nint ReadNode() {\n  int l;\n  string c;\n  cin >> l >> c;\n  return l * 2 + (c[0] == 'R');\n}\n\nint main() {\n  int k, n;\n  cin >> k >> n;\n  Graph g(k * 2 + 10);\n  for (int i = 0; i < n; i++) {\n    int x[4];\n    for (int j = 0; j < 3; j++)\n      x[j] = ReadNode();\n    x[3] = x[0];\n    for (int j = 0; j < 3; j++) {\n      g.AddEdge(x[j] ^ 1, x[j + 1]);\n      g.AddEdge(x[j + 1] ^ 1, x[j]);\n    }\n  }\n  g.ComputeSCC();\n\n  // 判斷是否無解。\n  for (int i = 1; i <= k; i++) {\n    if (g.scc[i * 2] == g.scc[i * 2 + 1]) {\n      cout << \"-1\" << endl;\n      return 0;\n    }\n  }\n\n  // 從縮圖之後從相依順序末端開始，以貪求法找出一組 2-SAT 解。\n  vector<bool> taken(g.n, false);\n  for (int scc = g.nscc; scc > 0; scc--) {\n    bool ok = true;\n    for (int x : g.groups[scc])\n      if (taken[x ^ 1])\n        ok = false;\n    if (ok) {\n      for (int x : g.groups[scc])\n        taken[x] = true;\n    }\n  }\n\n  // 把解答輸出。\n  string ret = \"\";\n  for (int i = 1; i <= k; i++) {\n    if (taken[i * 2] == true) {\n      ret += \"B\";\n    } else {\n      ret += \"R\";\n    }\n  }\n\n  cout << ret << endl;\n  return 0;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"備註 1"},{"type":"element","tagName":"footnote","properties":{"here":"1"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"教育部的雙語對照辭典把 Strongly Connected Component 翻譯成"},{"type":"element","tagName":"a","properties":{"href":"http://terms.naer.edu.tw/detail/2426323/?index=2"},"children":[{"type":"text","value":"強連接組件"}]},{"type":"text","value":"，真的很工程噎。我一直在思考到底是強連通元件、強連通分量、還是強連通分支，原來還漏了強連接系列呀（嘆）"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"關於競程日記"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"🍅 如果您想到更多有趣漂亮簡單乾淨的解法話歡迎留言給競程日記小編群！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"ℹ️ 這是一篇投稿給"},{"type":"element","tagName":"a","properties":{"href":"https://www.facebook.com/%E7%AB%B6%E7%A8%8B%E6%97%A5%E8%A8%98-1514973425463954/"},"children":[{"type":"text","value":"競程日記"}]},{"type":"text","value":"的文章，歡迎大家投稿、交流與分享程式解題競賽的點點滴滴！"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"Future Generation","category":"prob","path":"/problem/icpc/asia_jakarta_2018/J","date":"2019-01-06","description":"給你 $N$ ($1\\le N\\le 15$) 個字串 $S_1, \\ldots, S_N$ ($1\\le |S_i| \\le 15$)。現在請你對於每一個字串 $S_i$，找出一個非空的子序列 $A_i$，使得 $A_1, A_2, \\ldots, A_N$ 依照字典順序是嚴格遞增的。\n\n輸出最大的 $|A_1|+|A_2|+\\cdots + |A_N|$ 之值。若無解的話要輸出 `-1`。\n","link":"https://codeforces.com/gym/102001/problem/J","code":"ICPC-JAKARTA-2018-J","difficulty":4,"oj":"codeforces-gym","tags":["ICPC 2018 Asia Jakarta Regional"]},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"簡化後題目敘述"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"第一列包含一個正整數 $N$ ($1\\le N\\le 15$)。第二列開始有 $N$ 列，每一列包含一個僅由大寫字母組成的字串 $S_i$ ($1\\le |S_i|\\le 15$)\n。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸出說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"輸出最大的 $|A_1|+|A_2|+\\cdots + |A_N|$ 之值。若無解的話要輸出 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"-1"}]},{"type":"text","value":"。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"3\nKARIM\nPARBUDI\nCHANDRA\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"16\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"2\nZORO\nANDI\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"-1\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 3"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"7\nHAVE\nFUN\nIN\nICPC\nJAKARTA\nTWENTY\nEIGHTEEN\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 3"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"25\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ 連結"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://codeforces.com/gym/102001/problem/J"},"children":[{"type":"text","value":"Codeforces Gym 102001 - J"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"總之就是很直白的動態規劃囉。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"對於所有 $i$，我們可以先把所有 $S_i$ 的子序列列出來，並且排序好。假設這樣的子序列有 $m_i$ 個（不難得知 $m_i < 2^{|S_i|}$），我們令這樣的序列為 $S_i^{(0)} < S_i^{(1)} < \\cdots < S_i^{(m_i-1)}$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"定義 $\\dp[i][j]$ 為作到第 $i$ 個字串且選取 $A_i \\le S_i^{(j)}$ 的時候，$|A_1|+\\cdots + |A_i|$ 可能的最大值。此時我們可以列出遞迴式："}]},{"type":"text","value":"\n$$\n\\dp[i][j] = \\begin{cases}\n\\max_{k:\\ S_{i-1}^{(k)} < S_i^{(j)}} \\left\\{ \\dp[i-1][k] + |S|\\right\\} \\\\\n\\dp[i][j-1] & \\text{考慮結束在字典順序更小的情形。}\n\\end{cases}\n$$\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"注意到此時 $\\dp[i][0], \\dp[i][1], \\ldots$ 這是一個非遞減的序列。因此要讓 $\\dp[i-1][k] + |S|$ 的值最大，就等價於讓 $k$ 的值盡量大！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"實作上由於 $j$ 變大的時候，對應的 $k$ 也非遞減，我們可以利用 two pointer 的技巧，維護 $j$ 和 $k$ 兩個足標。在 $O(|S_i|\\times 2^{|S_i|})$ 的時間更新一整排的 $\\dp[i][0, \\ldots, m-1]$ 值（在兩個足標追趕的過程中，由於每次都是比較兩個字串，所以需要花 $O(|S_i|)$ 的時間推進一個足標）。因此整體時間複雜度為 $O(\\sum_{1\\le i\\le N} |S_i| 2^{|S_i|}) \\approx O(15^2\\times 2^{15})$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring S[15];\nvector<string> a[15];\nint dp[15][1<<15];\n\n// 產生一個字串的所有子序列。\nvoid GetAllSubstrings(string s, vector<string>& result) {\n  result.push_back(\"\");\n  for (int i = 0; i < (int)s.size(); i++) {\n    int n = result.size();\n    for (int j = 0; j < n; j++) {\n      result.push_back(result[j]+s[i]);\n    }\n  }\n  // 把找到的子序列依照字典順序排序，注意這邊 result[0] 會是空字串。\n  sort(result.begin(), result.end());\n}\n\nint main() {\n  int N;\n  cin >> N;\n  for (int i = 0; i < N; i++) cin >> S[i];\n  for (int i = 0; i < N; i++) GetAllSubstrings(S[i], a[i]);\n\n  const int INF = 1e5;\n  // 初始化動態規劃的首排。\n  dp[0][0] = -INF; // 不允許有空字串，所以給他 -INF。\n  for (int i = 1; i < (1<<S[0].size()); i++)\n    dp[0][i] = max(dp[0][i-1], (int)a[0][i].size());\n\n  // 然後依照遞迴關係計算剩下的部份。\n  for (int i = 1; i < N; i++) {\n    dp[i][0] = -INF; // 一樣不允許有空字串，所以給他 -INF。\n    for (int j = 1, k = 0; j < (1<<S[i].size()); j++) {\n        while (k < (1<<S[i-1].size()) && a[i-1][k] < a[i][j]) ++k;\n        dp[i][j] = max(dp[i][j-1], dp[i-1][k-1] + (int)a[i][j].size());\n    }\n  }\n  \n  int ans = dp[N-1][(1<<S[N-1].size())-1];\n  if (ans < 0) cout << \"-1\" << endl;\n  else cout << ans << endl;\n  return 0;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"備註"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果把所有的字串都預處理產生出來以後，用 Bucket Sort (桶子排序法) 把所有的字串全部排序起來。這麼一來就可以省下硬比較兩字串的時間，可以加速到 $O(15\\times 2^{15})$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"關於競程日記"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"🍅 如果您想到更多有趣漂亮簡單乾淨的解法話歡迎留言給競程日記小編群！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"ℹ️ 這是一篇投稿給"},{"type":"element","tagName":"a","properties":{"href":"https://www.facebook.com/%E7%AB%B6%E7%A8%8B%E6%97%A5%E8%A8%98-1514973425463954/"},"children":[{"type":"text","value":"競程日記"}]},{"type":"text","value":"的文章，歡迎大家投稿、交流與分享程式解題競賽的點點滴滴！"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"Largest Triangle","category":"prob","path":"/problem/icpc/asia_singapore_2018/A","date":"2019-01-21","description":"給你平面上 $N$ 個整數點，求任三個點構成的三角形之最大面積。\n","link":"https://open.kattis.com/problems/largesttriangle","code":"ICPC-SINGAPORE-A","difficulty":4,"oj":"kattis","tags":["ICPC 2018 Asia Singapore Regional"]},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"簡化後題目敘述"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"第一列有一個正整數 $N$ ($3\\le N\\le 5000$)，接下來的 $N$ 列每一列有兩個整數 $x, y$ ($0\\le x, y\\le 4\\cdot 10^7$)。輸入的點可能會重複、也可能會有三點共線。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸出說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"輸出最大三角形面積，答案的絕對誤差必須在 $10^{-5}$ 以內。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"7\n0 0\n0 5\n7 7\n0 10\n0 0\n20 0\n10 10\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"100.00000\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ 連結"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://open.kattis.com/problems/largesttriangle"},"children":[{"type":"text","value":"Open Kattis - Largest Triangle"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"題目出處"}]},{"type":"text","value":"：ICPC 2018 Asia Singapore Regional"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"首先，我們可以證明面積最大的三角形，其三個頂點一定會出現在凸包上。\n於是，在求出凸包以後，我們依序枚舉每一個點，再利用 two pointers 的單調性跑過另外兩個點，從而得到一個 $O(N^2)$ 時間的演算法。根據 "},{"type":"element","tagName":"a","properties":{"href":"https://arxiv.org/abs/1705.11035"},"children":[{"type":"text","value":"這篇論文"}]},{"type":"text","value":" 指出，有一個 $O(n\\log n)$ 時間複雜度的分而治之演算法能夠找出答案。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n\nclass Point {\npublic:\n  LL x, y;\n  Point(LL _x = 0, LL _y = 0) : x(_x), y(_y) {}\n  Point operator+(const Point &p) const { return Point(x + p.x, y + p.y); }\n  Point operator-(const Point &p) const { return Point(x - p.x, y - p.y); }\n  bool operator<(const Point &p) const {\n    if (x != p.x)\n      return x < p.x;\n    return y < p.y;\n  }\n  bool operator==(const Point &p) const { return x == p.x && y == p.y; }\n  friend istream &operator>>(istream &cin, Point &p) {\n    cin >> p.x >> p.y;\n    return cin;\n  }\n};\n\nLL cross(const Point &p, const Point &q) { return p.x * q.y - p.y * q.x; }\n\nLL seen_largest_area;\nLL Triangle(Point A, Point B, Point C) {\n  LL v = cross(A, B) + cross(B, C) + cross(C, A);\n  v = v > 0 ? v : -v;\n  seen_largest_area = max(seen_largest_area, v);\n  return v;\n}\n\nvoid ComputeConvexHull(vector<Point> &hull, const vector<Point> &points) {\n  hull.clear();\n  for (auto &p : points) {\n    while (hull.size() >= 2 &&\n           cross(hull.back() - hull[hull.size() - 2], p - hull.back()) <= 0)\n      hull.pop_back();\n    hull.push_back(p);\n  }\n}\n\nint main() {\n  int N;\n  cin >> N;\n  vector<Point> p(N);\n  for (int i = 0; i < N; i++)\n    cin >> p[i];\n  sort(p.begin(), p.end());\n  p.resize(unique(p.begin(), p.end()) - p.begin());\n  vector<Point> upper_hull, lower_hull;\n  ComputeConvexHull(lower_hull, p);\n  reverse(p.begin(), p.end());\n  ComputeConvexHull(upper_hull, p);\n  for (size_t i = 1; i + 1 < upper_hull.size(); i++)\n    lower_hull.push_back(upper_hull[i]);\n\n  size_t M = lower_hull.size();\n  for (size_t i = 0; i < M; i++)\n    lower_hull.push_back(lower_hull[i]);\n\n  seen_largest_area = 0;\n  for (size_t i = 0; i < M; i++)\n    for (size_t j = i + 1, k = j; j < i + M; j++) {\n      while (k < i + M &&\n             Triangle(lower_hull[i], lower_hull[j], lower_hull[k + 1]) >\n                 Triangle(lower_hull[i], lower_hull[j], lower_hull[k]))\n        ++k;\n    }\n  printf(\"%.9f\\n\", (double)seen_largest_area / 2.0);\n  return 0;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"關於競程日記"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"🍅 如果您想到更多有趣漂亮簡單乾淨的解法話歡迎留言給競程日記小編群！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"ℹ️ 這是一篇投稿給"},{"type":"element","tagName":"a","properties":{"href":"https://www.facebook.com/%E7%AB%B6%E7%A8%8B%E6%97%A5%E8%A8%98-1514973425463954/"},"children":[{"type":"text","value":"競程日記"}]},{"type":"text","value":"的文章，歡迎大家投稿、交流與分享程式解題競賽的點點滴滴！"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"Edit Distance","category":"prob","path":"/problem/icpc/asia_jakarta_2018/A","date":"2019-01-01","description":"對於兩個給定的字串 $S$ 和 $T$，我們定義 $edit(S, T)$ 為從 $S$ 經過若干插入字元、修改字元、刪除字元等操作後得到 $T$ 所需要的最少步數。\n\nAyu 有一個二元字串 $S$（$1\\le |S|\\le 2000$），她想要找到另一個字串 $T_{max}$ 使得 $edit(S, T_{max})$ 最大。即對於所有與 $S$ 等長的 $T$，$edit(S, T_{max})\\ge edit(S, T)$。不過呢，為了讓事情變得簡單些，她希望你能夠幫她的忙，找到任何一個與 $S$ 長度相同的字串 $T$，只要 $edit(S, T) > |S|/2$ 即可。\n\n當然，你也可以選擇輸出 $T_{max}$，事實上我們可以證明 $edit(S, T_{max}) > |S|/2$。這也保證了對於任意輸入一定有解。\n","link":"https://codeforces.com/gym/102001/problem/A","code":"ICPC-JAKARTA-2018-A","difficulty":3,"oj":"codeforces-gym","tags":null},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"題目敘述"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"對於兩個給定的字串 $S$ 和 $T$，我們定義其 "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"Edit Distance"}]},{"type":"element","tagName":"footnote","properties":{"goto":"1","show":"備註1,2"},"children":[]},{"type":"text","value":" $edit(S, T)$ 為從 $S$ 經過若干插入字元、修改字元、刪除字元等操作後得到 $T$ 所需要的最少步數。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Ayu 有一個二元字串 $S$（$1\\le |S|\\le 2000$），她想要找到另一個字串 $T_{max}$ 使得 $edit(S, T_{max})$ 最大。即對於所有與 $S$ 等長的 $T$，$edit(S, T_{max})\\ge edit(S, T)$。不過呢，為了讓事情變得簡單些，她希望你能夠幫她的忙，找到任何一個與 $S$ 長度相同的字串 $T$，只要 $edit(S, T) > |S|/2$ 即可。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"當然，你也可以選擇輸出 $T_{max}$，事實上我們可以證明 $edit(S, T_{max}) > |S|/2$。這也保證了對於任意輸入一定有解。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"輸入僅有一行包含二元字串 $S$（$1\\le |S|\\le 2000$）。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸出說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"輸出一個與 $S$ 長度相等的二元字串 $T$，滿足 $edit(S, T) > |S|/2$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"0011\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"1100\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"1100101\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"0011010\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ 連結"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://codeforces.com/gym/102001/problem/A"},"children":[{"type":"text","value":"Codeforces Gym 102001 - A"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果單純把所有數字都反過來，可能不太行。比方說以下的反例："},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"01010101"}]},{"type":"text","value":"，反過來就變成 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"10101010"}]},{"type":"text","value":"，顯然我們只要刪掉第一個字元並且補到後面去就行了。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"換一個想法想，如果字串長度 $n$ 是奇數，那麼根據 $edit({\\tt{000\\cdots 0}}, S) + edit(S, {\\tt{111\\cdots 1}}) \\ge edit({\\tt{000\\cdots 0}}, {\\tt{111\\cdots 1}}) = n$，我們知道其中一個一定會超過 $n/2$，因為 $n$ 是奇數，所以一定有一個會嚴格大於 $n/2$。換句話說，$n$ 是奇數的時候很好解決！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"那 $n$ 是偶數的時候怎麼辦？考慮 $S$ 的前 $n-1$ 個 bit（此時 $n-1$ 是奇數）我們稱這個前綴為 $S_0$。根據前一段的論述，我們可以找出一個"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"等長的"}]},{"type":"text","value":" $T_0$ 滿足 $edit(S_0, {T_0})\\ge \\lceil \\frac{n-1}{2}\\rceil = n/2$。此時顯然有 $edit(S, {T_0}), edit(S_0, \\red{T_0{\\tt{0}}}), edit(S_0, \\red{T_0{\\tt{1}}}) \\ge n/2$"},{"type":"element","tagName":"footnote","properties":{"goto":"3","show":"備註3"},"children":[]},{"type":"text","value":"。還記得計算 edit distance 的動態規劃嗎？無論我們在 $T_0$ 後面補哪個字元 $x$，總能夠有"}]},{"type":"text","value":"\n$$\n    edit(S, \\red{T_0x}) = \\min \\begin{cases}\n    edit(S_0, T_0) + (S[n-1] {\\tt{==}} x) & \\text{修改字元}\\\\\n    edit(S_0, \\red{T_0x}) + 1 & \\text{刪除字元}\\\\\n    edit(S, T_0) + 1 & \\text{插入字元}\n    \\end{cases}\n$$\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這時候注意到：如果我們選定 $x\\neq S[n-1]$，無論是哪種 case 都至少保證此時 $edit(S, \\red{T_0x}) > n/2$，達到目標！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"為了實作方便，我們考慮的是 $S$ 的末 $n-1$ 個字元，然後找到 $T$ 以後再根據 $S[0]$ 把相對應的字元放到前面。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"#include <iostream>\n#include <string>\nusing namespace std;\n\nint main() {\n  string s, t;\n  cin >> s;\n  \n  // 計算字串中 0 和 1 出現的個數。\n  int b[2] = {};\n  for (int i = 1; i < s.size(); i++) b[s[i]=='1']++;\n  \n  // 構造出距離比較遠的全 0 或全 1 字串。\n  t = string(s.size(), '0' + (b[0] > b[1]));\n  \n  // 然後把第一個字元改成與 s[0] 不同的字元，並且輸出。\n  t[0] = '0' + '1' - s[0];\n  cout << t << endl;\n  return 0;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"備註 1"},{"type":"element","tagName":"footnote","properties":{"here":"1"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Edit Distance 好像又被稱為 "},{"type":"element","tagName":"a","properties":{"href":"https://en.wikipedia.org/wiki/Levenshtein_distance"},"children":[{"type":"text","value":"Levenshtein Distance"}]},{"type":"text","value":"，是一種衡量兩個字串是否有多接近的指標（metric，不是 pointer XD）。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"備註 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Edit Distance 滿足三角不等式：$edit(A, B)+edit(B, C) \\ge edit(A, C)$，白話文解釋就是從 $A$ 換到 $C$ 的方法，至少有先從 $A$ 變成 $B$ 再從 $B$ 變成 $C$ 來得好。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"theorem","properties":{"title":"演算法豆知識","c":"is-primary"},"children":[{"type":"text","value":"\n在[強指數時間假說](/algo/strong-exponential-time-hypothesis)為真的前提之下，計算兩個長度為 $n$ 字串的 Edit Distance (exact) 至少得花 $\\Omega(n^{2-\\epsilon})$ 的時間。但是就近似演算法 (Approximation Algorithms) 而言， 2018 年 FOCS 的一篇最佳論文 [_Approximating Edit Distance Within Constant Factor in Truly Sub-Quadratic Time_](https://arxiv.org/abs/1810.03664)，在 $\\tilde{O}(n^{12/7})$ 時間內保證得到 $1680$-approxmation 的近似解，是為近期的一個重大突破。（作者們相信稍微用他們的方法再努力一下就可以做到 $(3+\\epsilon)$-approximation）\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"備註 3"},{"type":"element","tagName":"footnote","properties":{"here":"3"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"解答上面有一句話：此時顯然有 $edit(S, {T_0}), edit(S_0, \\red{T_0{\\tt{0}}}), edit(S_0, \\red{T_0{\\tt{1}}}) \\ge n/2$。這句話必須在 $|S_0|= |T_0|$ 的時候才成立。當 $|S_0|\\neq|T_0|$ 的時候，你能找到反例嗎？"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"關於競程日記"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"🍅 如果您想到更多有趣漂亮簡單乾淨的解法話歡迎留言給競程日記小編群！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"ℹ️ 這是一篇投稿給"},{"type":"element","tagName":"a","properties":{"href":"https://www.facebook.com/%E7%AB%B6%E7%A8%8B%E6%97%A5%E8%A8%98-1514973425463954/"},"children":[{"type":"text","value":"競程日記"}]},{"type":"text","value":"的文章，歡迎大家投稿、交流與分享程式解題競賽的點點滴滴！"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"Bitwise","category":"prob","path":"/problem/icpc/asia_singapore_2018/D","date":"2019-01-16","description":"給你 $N$ 個數字 $A_1, A_2, \\ldots, A_N$ **圍成一圈**。你的任務是要把這些數字分成 $K$ 個連續的區段（長度任意），使得每一個區段 OR 起來的值，其 AND 起來的值最大。\n","link":"https://open.kattis.com/problems/bitwise","code":"ICPC-SINGAPORE-D","difficulty":4,"oj":"kattis","tags":["ICPC 2018 Asia Singapore Regional"]},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"簡化後題目敘述"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"第一列有兩個正整數 $N, K$ （$1\\le K\\le N\\le 5\\cdot 10^5$）。\n第二列包含 $N$ 個整數，第 $i$ 個整數為 $A_i$（$0\\le A_i\\le 10^9$）。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸出說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"輸出一個整數。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"4 2\n2 3 4 1\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"3\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"6 3\n2 2 2 4 4 4\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"4\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 3"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"4 1\n0 1 2 3\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 3"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"3\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ 連結"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://open.kattis.com/problems/bitwise"},"children":[{"type":"text","value":"Open Kattis - Bitwise"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"題目出處"}]},{"type":"text","value":"：ICPC 2018 Asia Singapore Regional"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果沒有第一筆範例測資，可能就會誤以為整個序列不是接成一圈。所以有這樣一筆範例測資是很好的。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這題是要求最大化 ${\\tt AND}_{\\text{所有區間}}({\\tt OR}_{x\\in {\\text{區間}}} x)$。如果題目的目標函數改成：最大化 ${\\min}_{\\text{所有區間}}(\\sum_{x\\in {\\text{區間}}} x)$，而且把接成一圈改成一般的直線序列，那就會變成一纇很經典的經典題"},{"type":"element","tagName":"footnote","properties":{"goto":"1","show":"備註1"},"children":[]},{"type":"text","value":"。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"直線版的解法"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"對於經典題來說，一個作法是可以對答案做二分搜尋法：假設我們猜測答案是 $\\ge v$，那麼我們可以使用貪心的方法，從左邊刷過去，只要恰好累積到總和 $\\ge v$ 的區間，就可以把它切斷，然後開始累積下一個新的區間。如果最後能夠蒐集到至少 $K$ 個區間，那就存在一種分區間的方法滿足答案 $\\ge v$ 了。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"當我們從 MIN-SUM 函數換成 AND-OR 函數的時候，也可以如法炮製。不過呢，因為每一個位元實際上是分開的，我們的二分搜尋法可以寫成以下的等價描述：逐步判斷第 $29, 28, \\ldots, 1$ 個 bit 能否出現在答案中；如果可以的話，就把它加進目前搜尋到的目標答案。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"變成環狀"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"現在有個問題，就是不知道該從哪裡開始第一個區間。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我們可以注意到，對於這個問題來說，如果存在一個用上述 greedy 方式切出來的區間切法，那麼區間的結束點，都會出現在 "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"初獲得新的 bit"}]},{"type":"text","value":" 的那個位置。因為每一個數字都只有至多 30 個 bit，所有可能的區間開頭，至多只有 30 種。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"時間複雜度是 $O(30\\times 30\\times N)$。不曉得有沒有快一點的作法？"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"#include <bits/stdc++.h>\nusing namespace std;\n\nint N, K;\nvector<int> A;\n\nbool Test(int mask) {\n  int seeking = 0;\n  for (int start = 0; start < N; start++) {\n    if ((mask&(seeking|A[start])) != (mask&seeking)) {\n      int now = 0, groups = 0;\n      for (int i = start+1; i <= start+N; i++) {\n        now |= A[i];\n        if ((now&mask) == mask) {\n          groups++;\n          now = 0;\n        }\n      }\n      groups += ((now&mask) == mask);\n      if (groups >= K) return true;\n    }\n    seeking |= A[start];\n  }\n  return false;\n}\n\nint main() {\n  cin >> N >> K;\n  A.resize(N*2);\n  for (int i = 0; i < N; i++) cin >> A[i];\n  for (int i = 0; i < N; i++) A[N+i] = A[i];\n  int mask = 0;\n  for (int bit = 29; bit >= 0; bit--) {\n    if (Test(mask + (1<<bit))) {\n      mask += (1<<bit);\n    }\n  }\n  cout << mask << endl;\n  return 0;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"經典題蒐集"},{"type":"element","tagName":"footnote","properties":{"here":"1"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"筆者是在古早的TOI選訓營遇到這個問題的，但現在資料似乎已不可考。以下類似題的目標函數都是：最小化 $\\max_{\\text{所有區間}}(\\sum_{x\\in \\text{區間}} x)$"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://tioj.ck.tp.edu.tw/problems/1432"},"children":[{"type":"text","value":"TIOJ 1432 - 骨牌遊戲"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://tioj.ck.tp.edu.tw/problems/1465"},"children":[{"type":"text","value":"TIOJ 1465 - H遊戲密笈 - EXTREME"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2274"},"children":[{"type":"text","value":"UVa 11299 - Separating Rods"}]},{"type":"text","value":" (感謝夢月提供)"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果輸入的數字並不總是正數，那麼題目就會變難了（因為沒有了貪心法該有的性質：如果 $[i, j]$ 是一個超過總和的區間，$\\Longrightarrow [\\le i, \\ge j]$ 也都超過總和）。大家有興趣可以挑戰一下以下的題目："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://www.spoj.com/problems/SEQPAR/"},"children":[{"type":"text","value":"SPOJ SEQPAR - Partion the sequence"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"關於競程日記"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"🍅 如果您想到更多有趣漂亮簡單乾淨的解法話歡迎留言給競程日記小編群！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"ℹ️ 這是一篇投稿給"},{"type":"element","tagName":"a","properties":{"href":"https://www.facebook.com/%E7%AB%B6%E7%A8%8B%E6%97%A5%E8%A8%98-1514973425463954/"},"children":[{"type":"text","value":"競程日記"}]},{"type":"text","value":"的文章，歡迎大家投稿、交流與分享程式解題競賽的點點滴滴！"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"Sliding Blocks","category":"prob","path":"/problem/icpc/asia_singapore_2018/H","date":"2019-01-18","description":"在一個 $N\\times M$ 大小的方格棋盤上，一開始恰好有一個格子上頭有個方塊，而棋盤的其他地方都是空的。現在，你可以逐步把一些方塊從棋盤的邊界，沿著水平或垂直方向**滑入**棋盤中。放入棋盤的方塊會一直滑，直到撞到某個現存於棋盤上的方塊停止。\n\n現在給你一個盤面，已知第一塊初始的方塊位置。請問能否用滑的滑出這個盤面？保證輸入的盤面所有方塊的位置連接成一棵樹：也就是說，如果我們把方塊當作節點、緊黏著邊的兩個方塊建立一條邊，那麼整個圖會形成一棵樹。\n","link":"https://open.kattis.com/problems/slidingblocks","code":"ICPC-SINGAPORE-H","difficulty":5,"oj":"kattis","tags":["ICPC 2018 Asia Singapore Regional"]},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"簡化後題目敘述"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"第一列有三個正整數 $N, M, B$ （$1\\le N, M, B\\le 4\\cdot 10^5$），依序代表棋盤的列數與行數，還有方格總數。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"接下來有 $B$ 列，每一列有兩個數字 $r, c$ （$1\\le r\\le N$; $1\\le c\\le M$）代表方格的位置。這 $B$ 列中的第一列，包含了初始方塊的位置。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸出說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果不存在任何構造棋盤上方塊的方式，請輸出 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"impossible"}]},{"type":"text","value":"。否則的話，輸出 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"possible"}]},{"type":"text","value":"，然後從第二列開始輸出 $B-1$ 列，每一列包含一個滑入方塊的指令：首先有一個方向 $c\\in\\{$ "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"<"}]},{"type":"text","value":", "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":">"}]},{"type":"text","value":", "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"^"}]},{"type":"text","value":", "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"v"}]},{"type":"text","value":" $\\}$。然後會跟著滑入方塊的列號($r$) 或行號($c$)。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"3 4 6\n1 1\n1 2\n2 2\n2 3\n3 3\n3 4\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"possible\n< 1\n^ 2\n< 2\n^ 3\n< 3\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"3 4 9\n3 1\n2 1\n1 1\n1 2\n1 3\n1 4\n2 4\n3 4\n3 3\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"impossible\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ 連結"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://open.kattis.com/problems/slidingblocks"},"children":[{"type":"text","value":"Open Kattis - Sliding Blocks"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"題目出處"}]},{"type":"text","value":"：ICPC 2018 Asia Singapore Regional"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"因為棋盤上的所有方塊會形成一棵樹，所以我們從初始方塊開始進行 DFS/BFS，就可以得知每一個方塊滑入的方向了。根據這個滑入的方向，同一行或同一列的相鄰方塊，必須有先後順序才行（總不能先把鄰居都放進去，這樣自己就滑不進去了）。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"因此，只要準確掌握好先後順序，最後進行一個拓撲排序，就可以把答案找出來啦！請參考落落長的程式碼。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"在程式碼中，我們使用了一些小撇步（不見得是必要的，但總之我是這樣寫了...）。比方說，我們把四個方向定義成左右一組、上下一組，這麼一來要存取"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"反方向"}]},{"type":"text","value":"的時候，只要透過 XOR 1 就可以了(比方說 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"dir^1"}]},{"type":"text","value":")。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXB = 400005;\nint r[MAXB], c[MAXB];\n\nconst vector<string> DSTR = {\">\", \"<\", \"v\", \"^\"};\nstring s[MAXB];\nint face[MAXB];\nint visit[MAXB];\nint link[MAXB][4];\nvector<pair<int, int>> rows[MAXB], cols[MAXB];\n\n// 定義四個方向。\nenum {\n  LEFT = 0,\n  RIGHT = 1,\n  UP = 2,\n  DOWN = 3\n};\n\ninline bool IsNeighbor(int x, int y) {\n  return abs(r[x]-r[y]) + abs(c[x]-c[y]) == 1;\n}\n\nvoid dfs(int x) {\n  visit[x] = 1;\n  for (int dir = 0; dir < 4; dir++) {\n    int y = link[x][dir];\n    if (IsNeighbor(x, y) && !visit[y]) {\n      face[y] = (dir^1);\n      s[y] = DSTR[dir] + \" \" + to_string(dir/2? c[y]: r[y]);\n      dfs(y);\n    }\n  }\n}\n\n// 紀錄優先順序 (得先有 y 才能有 x)。\nvector<int> deps[MAXB];\ninline void AddLink(int x, int y) {\n  if (x == -1 || y == -1) return;\n  deps[x].push_back(y);\n}\n\n// 紀錄解答用的。\nvector<int> solution;\nbool no_solution = false;\nvoid topological_sort(int x) {\n  visit[x] = 1;\n  for (auto y : deps[x]) {\n    if (visit[y] == 0)\n      topological_sort(y);\n    else if (visit[y] == 1)\n      no_solution = 1;\n  }\n  solution.push_back(x);\n  visit[x] = 2;\n}\n\nint main() {\n  int N, M, B;\n  cin >> N >> M >> B;\n  for (int i = 0; i < B; i++) {\n    cin >> r[i] >> c[i];\n    rows[r[i]].push_back({c[i], i});\n    cols[c[i]].push_back({r[i], i});\n  }\n  for (int i = 1; i < MAXB; i++) {\n    sort(rows[i].begin(), rows[i].end());\n    sort(cols[i].begin(), cols[i].end());\n  }\n\n  memset(link, -1, sizeof(link));\n  for (int i = 1; i < MAXB; i++) {\n    for (size_t j = 1; j < rows[i].size(); j++) {\n      int prev = rows[i][j-1].second;\n      int now = rows[i][j].second;\n      link[prev][RIGHT] = now;\n      link[now][LEFT] = prev;\n    }\n    for (size_t j = 1; j < cols[i].size(); j++) {\n      int prev = cols[i][j-1].second;\n      int now = cols[i][j].second;\n      link[prev][DOWN] = now;\n      link[now][UP] = prev;\n    }\n  }\n  dfs(0);\n  for (int x = 1; x < B; x++) {\n    AddLink(x, link[x][face[x]]);\n    AddLink(link[x][face[x]^1], x);\n  }\n  memset(visit, 0, sizeof(visit));\n  for (int x = 0; x < B; x++) {\n    if (!visit[x])\n      topological_sort(x);\n  }\n  if (no_solution) {\n    cout << \"impossible\" << endl;\n  } else {\n    cout << \"possible\" << '\\n';\n    for (auto x : solution)\n      if (x != 0)\n        cout << s[x] << '\\n';\n  }\n  return 0;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"關於競程日記"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"🍅 如果您想到更多有趣漂亮簡單乾淨的解法話歡迎留言給競程日記小編群！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"ℹ️ 這是一篇投稿給"},{"type":"element","tagName":"a","properties":{"href":"https://www.facebook.com/%E7%AB%B6%E7%A8%8B%E6%97%A5%E8%A8%98-1514973425463954/"},"children":[{"type":"text","value":"競程日記"}]},{"type":"text","value":"的文章，歡迎大家投稿、交流與分享程式解題競賽的點點滴滴！"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"Prolonged Password","category":"prob","path":"/problem/icpc/asia_singapore_2018/I","date":"2019-01-19","description":"給你一個初始字串 $S$，然後根據函數 $f$ 構造密碼 $P=f^K(S)$。函數 $f$ 的操作如下：對於 $S$ 的所有字元，把該字元同時換成對應的字串。同一個字元對應到的替換字串是固定的，如果看到 `a` 就換成 $T_a$、看到 `b` 就換成 $T_b$、依此類推。\n\n給你 $M$ 個詢問。每一個詢問都會讀取一個整數 $m_i$，並且要你回答出密碼 $P$ 的第 $m_i$ 個字元為何。\n","link":"https://open.kattis.com/problems/prolongedpassword","code":"ICPC-SINGAPORE-I","difficulty":6,"oj":"kattis","tags":["ICPC 2018 Asia Singapore Regional"]},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"簡化後題目敘述"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"第一列包含一個字串 $S$, ($1\\le |S|\\le 1000000$)。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"第二列包含 13 個字串 $T_a, T_b, \\ldots, T_m$。($2\\le |T_a|, |T_b|, \\ldots, |T_m| \\le 50$)"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"第三列包含 13 個字串 $T_n, T_o, \\ldots, T_z$。($2\\le |T_n|, |T_o|, \\ldots, |T_z| \\le 50$)"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"第四列包含一個整數 $K$ ($1\\le K\\le 10^{15}$)。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"第五列包含一個整數 $M$ ($1\\le M\\le 1000$)。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"第六列包含 $M$ 個整數，第 $i$ 個整數為 $m_i$，其中 $1\\le m_i\\le \\min(|f^K(S)|, 10^{15})$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸出說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"對於每一個詢問，單獨輸出所求字元於一列。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"abca\nbc cd da dd ee ff gg hh ii jj kk ll mm\nnn oo pp qq rr ss tt uu vv ww xx yy zz\n1\n2\n1 8\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"b\nc\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"ab\nba ab cc dd ee ff gg hh ii jj kk ll mm\nnn oo pp qq rr ss tt uu vv ww xx yy zz\n2\n2\n1 8\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"a\nb\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ 連結"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://open.kattis.com/problems/prolongedpassword"},"children":[{"type":"text","value":"Open Kattis - Prolonged Password"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"題目出處"}]},{"type":"text","value":"：ICPC 2018 Asia Singapore Regional"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我們可以把函數 $f$ 迭代的過程展開成樹狀圖。而依照順序遍歷葉節點的時候，就相當於把最終的密碼 $P$ 印出來。如果要取得第 $m_i$ 個字元，那麼我們要找的便是由左至右數來第 $m_i$ 個葉子。下圖是第一筆範例以字母 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"a"}]},{"type":"text","value":" 開頭展開三層的樣子。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"display","properties":{"binary-tree":"","complete":"","depth":"4","uihelper-content-map":"{\n        \"a\": {font: \"24pt monospace\", fontColor: \"red\"},\n        \"b\": {font: \"24pt monospace\", fontColor: \"blue\"},\n        \"c\": {font: \"24pt monospace\", fontColor: \"green\"},\n        \"d\": {font: \"24pt monospace\", fontColor: \"gold\"},\n        }","data":"{\n        value: [\"a\", \"b\", \"c\", \"c\", \"d\", \"d\", \"a\", \"d\", \"a\", \"d\", \"d\", \"d\", \"d\", \"b\", \"c\"]\n    }"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果我們從根節點（某個字元 $\\alpha$）開始，事先知道每一個子樹的大小，就可以在 $|T_\\alpha|$ 的時間內直接前往帶有第 $m_i$ 個葉子的子樹。因此，預處理以後我們可以在 $O(50\\times K)$ 的時間內走到我們想要的葉節點。可惜的是，$K$ 太大了，而且整棵樹的大小不見得存得下。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"好消息是，會詢問的數字頂多只有 $10^{15}$，我們可以把超過的部份完全忽略掉：也就是說，對於超過 $10^{15}$ 大小的子樹，我們不需要精確計算其大小，只要標記成「唉呀太大了」就可以了。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"此外，還有另一個方便實作的好消息：題目的條件保證了每一個 $T_\\alpha$ 長度至少有 2。這代表什麼呢？我們只要關心最靠近底層的 $\\log_2(10^{15})\\approx 50$ 層就行啦！如果整棵樹太高，一開始我們只要想辦法從樹根，每次挑選第一個子節點往下走，快速抵達最底下的 50 層就行了～"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"注意到字串僅包含小寫英文字母，從上面往下走得過程，至多 26 步就會產生一個循環。我們可以快速跳過若干循環節，到第 $50+O(1)$ 層停下來。然後從那個地方開始進行前述的「搜索」過程，而且一開始也只需要紀錄 50 層左右的子樹的大小。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"為了方便起見，我直接紀錄到 63 層，往下找循環的時候，也是直接跳到 100 層左右，然後再一個一個走下去。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\nstring S;\nstring T[26];\nLL K;\n\nLL len[26][64];\nconst LL LIMIT = (LL)1e15;\n\nvoid add(LL &x, LL v) {\n  // -1 代表超過長度。\n  if (x == -1 || v == -1) {\n    x = -1;\n  } else {\n    x += v;\n    if (x >= LIMIT)\n      x = -1;\n  }\n}\n\nvoid pre() {\n  for (int i = 0; i < 26; i++) {\n    len[i][0] = 1;\n    len[i][1] = T[i].size();\n  }\n  for (int t = 2; t < 64; t++)\n    for (int i = 0; i < 26; i++)\n      for (auto x : T[i])\n        add(len[i][t], len[x - 'a'][t - 1]);\n}\n\nchar ans;\n\n// 如果還不夠的話就回傳 false，如果找到了就回傳 true.\nbool ask(LL &m, char root, LL k) {\n  if (k == 0) {\n    --m;\n    ans = root;\n    return (m == 0);\n  }\n  if (k < 64 && len[root - 'a'][k] != -1 && len[root - 'a'][k] < m) {\n    m -= len[root - 'a'][k];\n    return false;\n  }\n  if (k <= 100) {\n    for (auto child : T[root - 'a']) {\n      if (ask(m, child, k - 1)) {\n        return true;\n      }\n    }\n  } else {\n    // 找出 cycle, 然後飛到第一個小於100層的地方。\n    int pos[26] = {};\n    int now = root - 'a';\n    int cnt = 1;\n    while (pos[now] == 0) {\n      pos[now] = cnt;\n      now = T[now][0] - 'a';\n      cnt++;\n    }\n    int cycle = cnt - pos[now];\n    k -= (cnt - 1);\n    k -= (k - 100) / cycle * cycle;\n    k -= cycle;\n    return ask(m, now + 'a', k);\n  }\n  return false;\n}\n\nvoid solve() {\n  LL m;\n  cin >> m;\n  for (size_t i = 0; i < S.size(); i++) {\n    if (ask(m, S[i], K))\n      break;\n  }\n  cout << ans << '\\n';\n}\n\nint main() {\n  cin >> S;\n  for (int i = 0; i < 26; i++)\n    cin >> T[i];\n  cin >> K;\n  // 預處理，計算不超過 64 層，以某字元為樹根的子樹大小。\n  pre();\n\n  int M;\n  cin >> M;\n  while (M--)\n    solve();\n  return 0;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"關於競程日記"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"🍅 如果您想到更多有趣漂亮簡單乾淨的解法話歡迎留言給競程日記小編群！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"ℹ️ 這是一篇投稿給"},{"type":"element","tagName":"a","properties":{"href":"https://www.facebook.com/%E7%AB%B6%E7%A8%8B%E6%97%A5%E8%A8%98-1514973425463954/"},"children":[{"type":"text","value":"競程日記"}]},{"type":"text","value":"的文章，歡迎大家投稿、交流與分享程式解題競賽的點點滴滴！"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"Conveyor Belts","category":"prob","path":"/problem/icpc/asia_singapore_2018/K","date":"2019-01-20","description":"有 $N$ 個貨品集散地，以及 $M$ 條連接機器與機器之間的輸送帶。每個輸送帶每分鐘可以運送 $1$ 個貨品。恰好有 $K$ 個生產貨品的機器正在運作當中，他們的位置剛好分別在第 $1, 2, \\ldots, K$ 個貨品集散地。他們每 $K$ 分鐘就會做好一份貨品：對任意非負整數 $x\\ge 0$，編號為 $j$ 的機器會恰好在第 $xK+j$ 分鐘產出一份貨品。\n\n貨品可以經過任意事先指定的路線被送往編號為 $N$ 的貨品集散地。兩個以上的貨物可以同時被輸送至任一個集散地，上頭的機器手臂會以可忽略（即時）的速度將貨物轉送至其他輸送帶上面。\n\n請問至多可以保留多少運作中的生產機器，才能夠保證貨物輸送順暢？\n","link":"https://open.kattis.com/problems/conveyorbelts","code":"ICPC-SINGAPORE-K","difficulty":5,"oj":"kattis","tags":["ICPC 2018 Asia Singapore Regional"]},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"簡化後題目敘述"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"輸入第一列包含三個整數 $N, K, M$ ($1\\le N, K\\le 300; 0\\le M\\le 1000$)，代表貨物集散地、生產機器、以及輸送帶的數量。\n接下來的 $M$ 列每一列有兩個正整數 $a, b$ ($1\\le a, b\\le N$)，代表有一條輸送帶可將貨物從編號 $a$ 的集散地送往編號為 $b$ 的集散地。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸出說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"請輸出最多可保留的生產機器數量。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"4 2 3\n1 3\n2 3\n3 4\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"2\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"5 2 4\n1 3\n3 4\n2 4\n4 5\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"1\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 3"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"5 2 6\n1 4\n2 3\n3 4\n4 5\n2 4\n3 3\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 3"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"2\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ 連結"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://open.kattis.com/problems/conveyorbelts"},"children":[{"type":"text","value":"Open Kattis - Conveyor Belts"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"題目出處"}]},{"type":"text","value":"：ICPC 2018 Asia Singapore Regional"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"注意到每固定 $K$ 分鐘就會有個循環，如果某條輸送帶在第 $x$ 分鐘是有東西的，那麼它在第 $x+K, x+2K, \\ldots$ 分鐘也會有東西。因此，我們可以把整張圖複製 $K$ 份，原本的圖上的點 $i$ 會變成 $i_0, i_1, \\ldots, i_{K-1}$，而原本圖上的邊 $(i, j)$ 會變成 $K$ 條邊：經過了這條輸送帶以後，時間會從模 $K$ 餘 $r$ 變成模 $K$ 餘 $(r+1)\\%K$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"剩下就交給 flow 啦～正確的找出每個貨品產生的起點 $i_i$，然後試圖找出一條增廣路徑到任何一個原本編號是 $N$ 的節點 $N_r$。最大流量就是能夠生產的貨品數。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"由於我們構造出來的圖上所有邊都是單位流量，因此使用 Dinitz 演算法時間複雜度會是 $O(\\text{邊數}\\cdot \\min\\left(\\sqrt{\\text{邊數}}, \\text{點數}^{2/3}\\right)) = O((MK)^{1.5}) \\approx 1.6\\times 10^8$。在以下的程式碼中，我稍微偷懶了一下直接用類似二分圖匹配的方法 DFS 找出增廣路徑（在沒找到增廣路徑時不更新現有 DFS 標記），似乎跑起來滿快的，不小心就變成當下最快的上傳紀錄了 (0.06s)。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Edge {\n  int to, cap, rev;\n  Edge(int _to, int _cap, int _rev): to(_to), cap(_cap), rev(_rev) {}\n};\n\nclass FlowNetwork {\n  public:\n    int n, sink;\n    vector<vector<Edge>> adj;\n    int mark;\n    vector<int> marks;\n    FlowNetwork(int _n, int _sink): n(_n), sink(_sink) {\n      adj.resize(n);\n      marks.resize(n, 0);\n      mark = 1;\n    }\n    void AddEdge(int x, int y, int c = 1) {\n      adj[x].emplace_back(y, c, adj[y].size());\n      adj[y].emplace_back(x, 0, adj[x].size()-1);\n    }\n    bool _DFS(int x) {\n      marks[x] = mark;\n      if (x == sink) return true;\n      for (auto& e: adj[x]) {\n        if (marks[e.to] != mark && e.cap > 0 && _DFS(e.to)) {\n          adj[e.to][e.rev].cap++;\n          e.cap--;\n          return true;\n        }\n      }\n      return false;\n    }\n    bool DFS(int s) {\n      if (_DFS(s)) {\n        mark++;\n        return true;\n      }\n      return false;\n    }\n};\n\nint main() {\n  int N, K, M;\n  cin >> N >> K >> M;\n  FlowNetwork g(N*K+1, N*K);\n  auto enc = [&](int i, int j) {\n    return (i-1)*K+j;\n  };\n  for (int j = 0; j < K; j++)\n    g.AddEdge(enc(N, j), g.sink, K);\n  while (M--) {\n    int x, y;\n    cin >> x >> y;\n    for (int j = 0; j < K; j++)\n      g.AddEdge(enc(x, j), enc(y, (j+1)%K));\n  }\n  int ans = 0;\n  for (int i = 1; i <= K; i++) {\n    if (g.DFS(enc(i, i%K)))\n      ++ans;\n  }\n  cout << ans << endl;\n  return 0;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"關於競程日記"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"🍅 如果您想到更多有趣漂亮簡單乾淨的解法話歡迎留言給競程日記小編群！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"ℹ️ 這是一篇投稿給"},{"type":"element","tagName":"a","properties":{"href":"https://www.facebook.com/%E7%AB%B6%E7%A8%8B%E6%97%A5%E8%A8%98-1514973425463954/"},"children":[{"type":"text","value":"競程日記"}]},{"type":"text","value":"的文章，歡迎大家投稿、交流與分享程式解題競賽的點點滴滴！"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"Wi Know","category":"prob","path":"/problem/icpc/asia_singapore_2018/F","date":"2019-01-15","description":"給你一個長度為 $N$ 的序列 $S_1, S_2, \\ldots, S_N$，請找出字典順序最小的 $(A, B)$ 配對，使得 $A\\neq B$ 而且這個序列包含至少一個子序列 $A, B, A, B$。\n","link":"https://open.kattis.com/problems/wiknow","code":"ICPC-SINGAPORE-F","difficulty":4,"oj":"kattis","tags":["ICPC 2018 Asia Singapore Regional"]},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"簡化後題目敘述"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"第一列包含一個正整數 $N$ ($1\\le N\\le 400000$)。\n第二列開始有 $N$ 列，每一列包含一個正整數 $S_i$ ($1\\le S_i\\le N$)。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸出說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"若存在答案，請輸出 $A, B$ 之值。若不存在形如 $A, B, A, B$ 的子序列，輸出 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"-1"}]},{"type":"text","value":"。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"8\n1\n3\n2\n4\n1\n5\n2\n4\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"1 2\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"8\n1\n2\n3\n4\n5\n6\n7\n1\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"-1\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 3"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"4\n2\n1\n2\n1\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 3"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"2 1\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ 連結"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://open.kattis.com/problems/wiknow"},"children":[{"type":"text","value":"Open Kattis - Wi Know"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"題目出處"}]},{"type":"text","value":"：ICPC 2018 Asia Singapore Regional"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我們可以先做出以下觀察：如果存在至少一組交錯的子序列 A, B, A, B，那麼 A 總可以是序列中第一次出現的那個 A、而 B 總可以挑選序列中最後一次出現的 B。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"於是，對於每一個 A，我們想知道 A 的右邊的第一個 B、還有跟 A 左邊出現最靠近的 B，滿足這個條件的 B 的最小值。對於一個特定數字 X，那麼我們可以把整個序列，依據所有 X 出現過的位置，切成許多區間。\n利用「掃描線」的概念，從右到左，維護目前跨過這條掃描線的區間們。\n假設現在掃描線所在的位置是一個 A 數字，那麼所有橫跨過這個區間、並且左界落在「第一個 A 的右邊」的那些區間編號最小者，就會是一個可能的答案。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如下圖黑色部份，是我們想查詢的區間。打圈代表我們想知道的左界的確落在範圍內。而打叉代表左界落在範圍外："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"mysvg","properties":{"width":400,"height":200,"viewbox":"0 0 400 200"},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"line","properties":{"x1":"200","x2":"200","y1":"0","y2":"200","stroke":"black","stroke-dasharray":"3"},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"text","properties":{"x":"200","y":"16"},"children":[{"type":"text","value":"A"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"text","properties":{"x":"140","y":"16"},"children":[{"type":"text","value":"A"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"text","properties":{"x":"100","y":"16"},"children":[{"type":"text","value":"A"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"line","properties":{"x1":"200","x2":"100","y1":"20","y2":"20","stroke-width":"4pt","stroke":"black"},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"text","properties":{"x":"110","y":"46","fill":"red"},"children":[{"type":"text","value":"B"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"text","properties":{"x":"70","y":"46","fill":"red"},"children":[{"type":"text","value":"B"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"text","properties":{"x":"150","y":"46","fill":"red"},"children":[{"type":"text","value":"B"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"text","properties":{"x":"230","y":"46","fill":"red"},"children":[{"type":"text","value":"B"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"line","properties":{"x1":"150","x2":"230","y1":"50","y2":"50","stroke-width":"4pt","stroke":"red"},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"circle","properties":{"cy":"50","cx":"350","r":"10","fill":"none","stroke-width":"4pt","stroke":"red"},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"text","properties":{"x":"170","y":"76","fill":"gold"},"children":[{"type":"text","value":"C"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"text","properties":{"x":"80","y":"76","fill":"gold"},"children":[{"type":"text","value":"C"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"text","properties":{"x":"260","y":"76","fill":"gold"},"children":[{"type":"text","value":"C"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"line","properties":{"x1":"170","x2":"260","y1":"80","y2":"80","stroke-width":"4pt","stroke":"gold"},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"circle","properties":{"cy":"80","cx":"350","r":"10","fill":"none","stroke-width":"4pt","stroke":"gold"},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"text","properties":{"x":"270","y":"106","fill":"green"},"children":[{"type":"text","value":"D"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"text","properties":{"x":"60","y":"106","fill":"green"},"children":[{"type":"text","value":"D"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"line","properties":{"x1":"270","x2":"60","y1":"110","y2":"110","stroke-width":"4pt","stroke":"green"},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"path","properties":{"d":"M 340,100 L 360,120 M 340,120 L 360,100","stroke-width":"4pt","stroke":"green"},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"text","properties":{"x":"120","y":"136","fill":"blue"},"children":[{"type":"text","value":"E"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"text","properties":{"x":"240","y":"136","fill":"blue"},"children":[{"type":"text","value":"E"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"line","properties":{"x1":"120","x2":"240","y1":"140","y2":"140","stroke-width":"4pt","stroke":"blue"},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"circle","properties":{"cy":"140","cx":"350","r":"10","fill":"none","stroke-width":"4pt","stroke":"blue"},"children":[]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"那麼我們只要找出與黑色區間相交的「最小編號」區間就可以了！實作上我們維護一個區間樹，當掃描線從右掃到左的時候，先將「離開的區間」刪掉，然後再依據當前區間 $[\\ell, r]$，查詢現在「左界 $>\\ell$」的區間編號最小值。然後再將當前區間左界加入區間樹。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"#include <bits/stdc++.h>\nusing namespace std;\n\n// 關於區間樹的操作：依序為插入、刪除、詢問。\nconst int LEAF_OFFSET = (1<<19);\nint tree[(1<<20)];\ninline int GetMinLabel(int l, int r) {\n  if (l == 0 || r == 0) return l+r;\n  return min(l, r);\n}\nvoid Insert(int x, int label) {\n  x += LEAF_OFFSET;\n  tree[x] = label;\n  for (x/=2; x; x/=2)\n    tree[x] = GetMinLabel(tree[x*2], tree[x*2+1]);\n}\nvoid Remove(int x) {\n  x += LEAF_OFFSET;\n  tree[x] = 0;\n  for (x/=2; x; x/=2)\n    tree[x] = GetMinLabel(tree[x*2], tree[x*2+1]);\n}\nint Query(int l) {\n  l += LEAF_OFFSET;\n  int ans = tree[l];\n  while (l) {\n    if (l%2==0)\n      ans = GetMinLabel(ans, tree[l+1]);\n    l/=2;\n  }\n  return ans;\n}\n\n\n// 紀錄輸入的序列。\nint S[400005];\nvector<int> positions[400005];\n\npair<int, int> best = {-1, -1};\nvoid UpdateSolution(int A, int B) {\n  if (best.first == -1 || best > make_pair(A, B)) {\n    best = {A, B};\n  }\n}\n\nvoid OutputAnswer() {\n  if (best.first == -1) cout << \"-1\" << endl;\n  else cout << best.first << \" \" << best.second << endl;\n}\n\nint main() {\n  int N;\n  cin >> N;\n  for (int i = 0; i < N; i++) {\n    cin >> S[i];\n    positions[S[i]].push_back(i);\n  }\n  for (int i = N-1; i >= 0; i--) {\n    int A = S[i];\n    positions[A].pop_back();\n    Remove(i);\n    if (!positions[A].empty()) {\n      int B = Query(positions[A][0]);\n      if (B > 0) UpdateSolution(A, B);\n      Insert(positions[A].back(), A);\n    }\n  }\n  OutputAnswer();\n  return 0;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"夢月說"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"花一分鐘想不出來，花三分鐘就想到了！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"關於競程日記"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"🍅 如果您想到更多有趣漂亮簡單乾淨的解法話歡迎留言給競程日記小編群！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"ℹ️ 這是一篇投稿給"},{"type":"element","tagName":"a","properties":{"href":"https://www.facebook.com/%E7%AB%B6%E7%A8%8B%E6%97%A5%E8%A8%98-1514973425463954/"},"children":[{"type":"text","value":"競程日記"}]},{"type":"text","value":"的文章，歡迎大家投稿、交流與分享程式解題競賽的點點滴滴！"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"Non-Prime Factors","category":"prob","path":"/problem/icpc/asia_singapore_2018/L","date":"2019-01-19","description":"給你 $Q$ 個正整數，對於每一個正整數 $n$，請你回答 $n$ 有多少個非質數的因數？\n","link":"https://open.kattis.com/problems/nonprimefactors","code":"ICPC-SINGAPORE-L","difficulty":2,"oj":"kattis","tags":["ICPC 2018 Asia Singapore Regional"]},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"簡化後題目敘述"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"第一列有一個正整數 $Q$ ($1\\le Q\\le 3\\cdot 10^6$)。接下來的 $Q$ 列每一列有一個正整數 $i$ ($2\\le i\\le 2\\cdot 10^6$)。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸出說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"對每個詢問輸出答案於一行。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"4\n100\n13\n12\n2018\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"7\n1\n4\n2\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ 連結"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://open.kattis.com/problems/nonprimefactors"},"children":[{"type":"text","value":"Open Kattis - Non-Prime Factors"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"題目出處"}]},{"type":"text","value":"：ICPC 2018 Asia Singapore Regional"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"計算總因數個數減去質因數個數就行啦。一般來說直接用篩法是 $O(N\\log\\log N)$ 時間"},{"type":"element","tagName":"footnote","properties":{"goto":"1","show":"備註1"},"children":[]},{"type":"text","value":"，所以已經很足夠了。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"在假設乘除法都是 $O(1)$ 的情形下（但可以證明 bit 數量不固定時，計算乘除必須要 $\\omega(1)$ 的時間，所以理論上乘除法不應該被視為常數。）下面程式碼範例使用的是線性時間的篩法 $O(N)$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"快速 I/O 感覺真的滿重要的。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 2000005;\nvector<int> primes;\nint almost_factors[N];\nint prime_factors[N];\nint min_power[N];\nint min_prime[N];\n\nchar s[32];\nvoid ReadInt(int &x) {\n  x = 0;\n  fgets(s, 32, stdin);\n  for (int i=0;s[i] >= '0';i++) {\n    x=x*10+s[i]-'0';\n  }\n}\n\nstring output;\nvoid WriteBuffer(int y) {\n  if (output.size()) output += '\\n';\n  output += to_string(y);\n}\n\nint main() {\n  for (int i = 2; i < N; i++) {\n    if (prime_factors[i] == 0) {\n      primes.push_back(i);\n      almost_factors[i] = 1;\n      prime_factors[i] = 1;\n      min_power[i] = 1;\n      min_prime[i] = i;\n    }\n    for (int j = 0; i * primes[j] < N; j++) {\n      int p = primes[j];\n      if (p != min_prime[i]) {\n        almost_factors[i * p] = almost_factors[i] * (min_power[i]+1);\n        prime_factors[i * p] = prime_factors[i] + 1;\n        min_power[i * p] = 1;\n        min_prime[i * p] = p;\n      } else {\n        almost_factors[i * p] = almost_factors[i];\n        prime_factors[i * p] = prime_factors[i];\n        min_power[i * p] = min_power[i] + 1;\n        min_prime[i * p] = min_prime[i];\n        break;\n      }\n    }\n  }\n\n  int Q, x;\n  //ios_base::sync_with_stdio(false);\n  //cin.tie(NULL);\n  //cin >> Q;\n  ReadInt(Q);\n  while (Q--) {\n    ReadInt(x);\n    WriteBuffer(almost_factors[x] * (min_power[x]+1) - prime_factors[x]);\n  }\n  puts(output.c_str());\n  return 0;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"備註 1"},{"type":"element","tagName":"footnote","properties":{"here":"1"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"關於篩法的時間複雜度之超單純證明，請容許我自肥一下，請參考以下連結："},{"type":"element","tagName":"a","properties":{"href":"https://tmt514.github.io/competitive-programming/2017/11/17/elementary-proof-on-analysis-of-eratosthenes-sieve.html"},"children":[{"type":"text","value":"https://tmt514.github.io/competitive-programming/2017/11/17/elementary-proof-on-analysis-of-eratosthenes-sieve.html"}]},{"type":"text","value":"。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"關於競程日記"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"🍅 如果您想到更多有趣漂亮簡單乾淨的解法話歡迎留言給競程日記小編群！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"ℹ️ 這是一篇投稿給"},{"type":"element","tagName":"a","properties":{"href":"https://www.facebook.com/%E7%AB%B6%E7%A8%8B%E6%97%A5%E8%A8%98-1514973425463954/"},"children":[{"type":"text","value":"競程日記"}]},{"type":"text","value":"的文章，歡迎大家投稿、交流與分享程式解題競賽的點點滴滴！"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"[ECNA2018B] Difference","category":"prob","path":"/problem/icpc/ecna2018/B","date":null,"description":"小差距序列(SDS) 是一個由正整數定義而成的序列。它的描述如下：首項 $A_1$ 為一個正整數 $r\\ge 1$。對於 $n>1$，定義 $A_n = A_{n-1}+d$，其中 $d$ 是最小的正整數，使得對於任意 $1\\le i<j<n$，$d\\neq A_j-A_i$。此外 $d$ 也不能等於任意一個當前數列的值。給定 $r$ 以及 $m$ 值($1\\le r \\le 100, 1\\le m\\le 200000000$)，請找出最小的 $n$ 使得要嘛 $m=A_n$，或者 $m$ 是兩個 $\\set{A_1, \\ldots, A_n}$ 的數字差。\n","link":"https://ecna18.kattis.com/problems/difference","code":"ECNA2018B","difficulty":null,"oj":"kattis","tags":null},"htmlAst":{"type":"root","children":[],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"Working Plan","category":"prob","path":"/problem/icpc/asia_seoul_2018/L","date":"2019-01-22","description":"ICPC manager 要展開一個為期 $n$ 天的企劃。總共有 $m$ 個員工，而第 $j$ 天需要恰好 $d_j$ 位員工出勤工作。此外，對於第 $i$ 位員工，他有希望的工作天數 $w_i$。\n\n為了讓企劃順利進行，官方規定：\n\n1. 每一位員工每一次都連續出勤**恰好** $w$ 天，而且\n2. 對於同一位員工，兩次連續出勤日之間，必須要至少間隔 $h$ 天。\n\nICPC manager 希望能夠做出一個排班計畫表，讓每個人的工作天數恰好是 $w_i$（$w_i$ 會是 $w$ 的倍數）、出勤人數恰好符合人力需求、而且也滿足上述兩項官方規定。\n\n請你寫一個程式找出一個可行的排班計畫。\n","link":"https://codeforces.com/gym/102070","code":"ICPC-2018-SEOUL-L","difficulty":3,"oj":"codeforces-gym","tags":["ICPC 2018 Asia Singapore Regional"]},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"簡化後題目敘述"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"第一列包含四個整數 $m, n, w, h$ ($1\\le m\\le 2000, 1\\le n\\le 2000, 1\\le w, h\\le n$)。第二列包含 $m$ 個整數，第 $i$ 個整數為 $w_i$（保證會是 $w$ 的倍數）。第三列包含 $n$ 個整數，第 $j$ 個整數為 $d_j$ ($0\\le d_j\\le m$)。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸出說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果存在一個可行的排班計畫，輸出 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"1"}]},{"type":"text","value":"，否則輸出 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"-1"}]},{"type":"text","value":"。若存在一組排班計畫，那請接著輸出 $m$ 列，第 $i$ 列包含嚴格遞增的 $w_i/w$ 個整數，表示第 $i$ 位員工被安排到這些日子開始他的 $w$ 天工作期。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"4 9 2 1\n4 4 6 2\n1 3 2 1 2 1 1 3 2\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"1\n1 8\n2 7\n2 5 8\n4\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ 連結"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://codeforces.com/gym/102070"},"children":[{"type":"text","value":"Codeforces Gym"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"題目出處"}]},{"type":"text","value":"：ICPC 2018 Asia Seoul Regional"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"注意到每一次工作都是連續恰好 $w$ 天，這會讓題目便得非常簡單：我們可以用 Greedy 從最早的時間刷過去。每一次找到一個新的、還沒有人做的工作時段，然後挑一個人做下去連續做 $w$ 天。要挑選誰呢？最直覺的辦法就是挑選目前剩餘工作量最大的那個人。我們可以用一個 priority queue 來維護這件事情。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如此一來時間複雜度便可能達到 $O(nm + \\frac{nm}{w}\\log m)$，感覺上再用力一點的話，可以把 priority queue 的部份壓掉，變成 $O(nm)$、甚至更好。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  int m, n, w, h;\n  cin >> m >> n >> w >> h;\n  vector<int> ws(m), d(n + 1);\n  for (int i = 0; i < m; i++) {\n    cin >> ws[i];\n    ws[i] /= w;\n  }\n  for (int i = 1; i <= n; i++)\n    cin >> d[i];\n  vector<int> jobs;\n  vector<vector<int>> schedule(m);\n  int bad = 0;\n  for (int i = 1; !bad && i <= n; i++) {\n    if (d[i] > 0 && i + w - 1 > n) {\n      bad = 1;\n      break;\n    }\n    while (d[i] > 0) {\n      jobs.push_back(i);\n      for (int j = 0; j < w; j++) {\n        if (--d[i + j] < 0)\n          bad = 1;\n      }\n    }\n  }\n\n  priority_queue<pair<int, int>> s;\n  for (int i = 0; i < m; i++)\n    s.push({ws[i] - schedule.size(), i});\n  vector<vector<pair<int, int>>> delay(n + 1);\n  int now = 0;\n\n  for (int t : jobs) {\n    while (now <= t) {\n      for (auto x : delay[now])\n        s.push(x);\n      now++;\n    }\n    if (s.empty()) {\n      bad = 1;\n      break;\n    }\n    auto [remain, i] = s.top();\n    s.pop();\n    schedule[i].push_back(t);\n    if (t + w + h <= n)\n      delay[t + w + h].push_back({remain - 1, i});\n  }\n  for (int i = 0; i < m; i++) {\n    if (schedule[i].size() != ws[i])\n      bad = 1;\n  }\n  if (bad) {\n    cout << \"-1\" << endl;\n  } else {\n    cout << \"1\";\n    for (int i = 0; i < m; i++) {\n      for (int j = 0; j < schedule[i].size(); j++) {\n        cout << (j == 0 ? '\\n' : ' ');\n        cout << schedule[i][j];\n      }\n    }\n    cout << '\\n';\n  }\n  return 0;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"關於競程日記"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"🍅 如果您想到更多有趣漂亮簡單乾淨的解法話歡迎留言給競程日記小編群！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"ℹ️ 這是一篇投稿給"},{"type":"element","tagName":"a","properties":{"href":"https://www.facebook.com/%E7%AB%B6%E7%A8%8B%E6%97%A5%E8%A8%98-1514973425463954/"},"children":[{"type":"text","value":"競程日記"}]},{"type":"text","value":"的文章，歡迎大家投稿、交流與分享程式解題競賽的點點滴滴！"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"Rectangular City","category":"prob","path":"/problem/icpc/asia_singapore_2018/G","date":"2019-01-17","description":"給你 $N, R, C, K$，請問有多少種長度為 $N$ 的矩形序列，其中每一個矩形的四個頂點座標範圍都是介於 $[0, 0]\\times [R, C]$ 之間的整數，而且這 $N$ 個矩形交集面積至少有 $K$ 這麼大。\n\n對於任兩個序列，只要存在其中一個矩形位置或大小不同，就視為不同的序列。輸出答案除以 $10^9+7$ 之值。\n","link":"https://open.kattis.com/problems/rectangularcity","code":"ICPC-SINGAPORE-G","difficulty":4,"oj":"kattis","tags":["ICPC 2018 Asia Singapore Regional","combinatorics"]},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"簡化後題目敘述"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"輸入僅有一列包含四個正整數 $N, R, C, K$。（$1\\le N\\le 10^6; 1\\le R, C\\le 5000; 1\\le K\\le R\\cdot C$）"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸出說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"輸出可能的矩形序列數量除以 $10^9+7$ 的餘數。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"2 2 3 4\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"7\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ 連結"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://asiasg18.kattis.com/problems/rectangularcity"},"children":[{"type":"text","value":"Open Kattis - Rectangular City"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"題目出處"}]},{"type":"text","value":"：ICPC 2018 Asia Singapore Regional"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"今天是個輕巧的組合數學題喔！記分板上看起來解出來的隊伍數量不多，很可能是因為跟題效應的關係，導致後來大家都把時間花在寫起來比較複雜的題目上了。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"（記分板排名比較沒那麼前面的部份也有隊伍答對這題。這種跡象出現的時候，通常代表這題會有程式碼較短的解法，或是題目出壞了。這取決於是哪裡辦的比賽...不說了先解題）"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我們可以先考慮所有矩形交集的位置。接著，不難發現我們可以把兩個座標軸拆開來。任何 X 座標上交集後長度為 $c$ 的區間們，與任何 Y 座標上交集後長度為 $r$ 的區間們，的任意組合，都可以產生出"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"不同的"}]},{"type":"text","value":"、而且交集面積恰好是 $c\\times r$ 的矩形序列。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我們只要枚舉 $r, c$，當 $rc\\ge K$ 的時候把兩邊方法數乘起來、加至總和即可。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"所以現在問題便轉化成一維上的問題了！而一維的問題也只需要枚舉。考慮 $N$ 個 $[0, R]$ 之間的區間，我們希望最終他們的交集長度恰好為 $r$，那我們可以枚舉交集的位置：可能是 $[0, r], [1, r+1], \\ldots, [R-r, R]$。對於位置 $[i, r+i]$，我們再次分離左右界：左界可以選擇 $\\set{0, 1, \\ldots, i}$ 任何一個、並且至少有一個要踩到 $i$。右界可以選擇 $\\set{r+i, r+i+1, \\ldots, R}$ 的任何一個，而且至少有一個要踩到 $r+i$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"因此，在限制交集範圍恰好是 $[i, r+i]$ 的情形下，左界的選法數有 $(i+1)^N-i^N$ 種。如法炮製得右界方法數有 $(R-r-i+1)^N-(R-r-i)^N$ 種。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n\nconst LL MOD = 1e9 + 7;\n\nLL bigmod(LL a, LL n) {\n  LL b = 1;\n  while (n) {\n    if (n % 2)\n      b = b * a % MOD;\n    a = a * a % MOD;\n    n /= 2;\n  }\n  return b;\n}\n\nLL npower[5005];\nLL X[5005], Y[5005];\n\nint main() {\n  int N, R, C, K;\n  cin >> N >> R >> C >> K;\n  for (int i = 1; i <= 5000; i++)\n    npower[i] = bigmod(i, N);\n  for (int r = 0; r <= R; r++) {\n    for (int i = 0; i <= R - r; i++) {\n      X[r] += (npower[i + 1] - npower[i]) *\n              (npower[R - r - i + 1] - npower[R - r - i]) % MOD;\n    }\n    X[r] = (X[r] % MOD + MOD) % MOD;\n  }\n  for (int c = 0; c <= C; c++) {\n    for (int i = 0; i <= C - c; i++) {\n      Y[c] += (npower[i + 1] - npower[i]) *\n              (npower[C - c - i + 1] - npower[C - c - i]) % MOD;\n    }\n    Y[c] = (Y[c] % MOD + MOD) % MOD;\n  }\n\n  LL ans = 0;\n  for (int r = 1; r <= R; r++)\n    for (int c = 1; c <= C; c++) {\n      if (r * c >= K) {\n        ans += X[r] * Y[c] % MOD;\n      }\n    }\n  cout << ans % MOD << endl;\n  return 0;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"題外話"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"同一場比賽的 Problem A 明明就比這題需要的知識點難一些，為什麼過山過海呀 =口="}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"關於競程日記"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"🍅 如果您想到更多有趣漂亮簡單乾淨的解法話歡迎留言給競程日記小編群！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"ℹ️ 這是一篇投稿給"},{"type":"element","tagName":"a","properties":{"href":"https://www.facebook.com/%E7%AB%B6%E7%A8%8B%E6%97%A5%E8%A8%98-1514973425463954/"},"children":[{"type":"text","value":"競程日記"}]},{"type":"text","value":"的文章，歡迎大家投稿、交流與分享程式解題競賽的點點滴滴！"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"[CF161E] Polycarpus the Safecracker","category":"prob","path":"/problem/cf/161/E","date":null,"description":"Polycarpus 有 $t$ 個保險箱，每一個保險箱的密碼都是一個上面填了 $0$ 到 $9$ 之間數碼的方陣。由於 Polycarpus 實在太喜歡質數了，他把密碼設定成每一列都是質數。令他感到驚奇的是，每一組他設定的密碼都是對稱矩陣。事隔多年， Polycarpus 只記得每組密碼的第一列的數字 $p_i$，請你幫他算算，有多少種可能的密碼？除了第一列以外，其他列允許有前導 $0$ 的出現。第一列數字 $10\\le p_i\\le 99999$，總共有 $1\\le t\\le 30$ 組詢問。 \n","link":"https://codeforces.com/problemset/problem/161/E","code":"CF161E","difficulty":null,"oj":"codeforces","tags":null},"htmlAst":{"type":"root","children":[],"data":{"quirksMode":false}}}}]}}}