{"data":{"markdownRemark":{"htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"在考慮枚舉所有可行解的同時，若變數與變數之間有高度的相關性，那麼枚舉的順序就會變得相當重要。若我們用了錯誤的順序進行枚舉，很可能會浪費許多時間考慮根本不符合題目規定的解。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"include-problem","properties":{"titlePrefix":"例題 1：","path":"/problem/cf/161/E"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"因為 $p_i\\le 99999$ 因此密碼鎖的大小至多只有 $5\\times 5$。再加上對稱的關係，因此彼此不相關的格子只有對角線右上方的這 15 格："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"/CF161E-f6172dc8bf334e699603ab7606576a42.png"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"但是，因為第一排已經固定了 $p_i$，所以剩下下面的 10 格。注意到，如果我們枚舉了標記數字 1 到 6 的地方，則每一排恰好空下一個對角線上的格子，而且彼此不相關。我們只要解決：有多少質數滿足 $\\overline{aXbcd}$ 的形式，其中 $a,b,c,d$ 已知。而這一步可以預處理後 $O(1)$ 查詢。因此利用枚舉法的計算量約在 $10^6$，相當合理。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"// by tmt514\n#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// cnt[第k個位數被丟掉了][其他數字是多少] = 有幾個質數。\nint cnt[5][100000];\n\nvoid pre_compute() {\n  // 先用篩法求質數。\n  vector<int> sieved(99999, 0);\n  for (int i = 2; i*i <= 99999; i++)\n    for (int j = i*i; j <= 99999; j += i)\n      sieved[j] = 1;\n  // 對於找到的每一個質數，我們考慮中間每一個位數被挖空以後，剩下的數字，把他加進去。\n  for (int p = 2; p <= 99999; p++)\n    if (sieved[p] == 0)\n      for (int ten = 1, k = 0; ten <= 10000; ten *= 10, k++)\n        cnt[k][ p/(ten*10)*ten + p%ten ]++;\n}\n\nint ans, n;\nint a[6][6];\nint get_count(int x) {\n  int prefix = 0;\n  for (int i = 0; i < n; i++)\n    if (i != x)\n      prefix = prefix*10 + a[x][i];\n  return cnt[n-1-x][prefix];\n}\nvoid dfs(int x, int y, int total) {\n  if (x == n) {\n    ans += total;\n    return;\n  }\n  if (y == n) {\n    dfs(x+1, 0, total * get_count(x));\n    return;\n  }\n\n  if (x >= y) {\n    a[x][y] = a[y][x];\n    dfs(x, y+1, total);\n  } else {\n    for (int i = 0; i <= 9; i++) {\n      a[x][y] = i;\n      dfs(x, y+1, total);\n    }\n  }\n}\n\nvoid solve() {\n  string s;\n  cin >> s;\n  n = s.size();\n  for (int i = 0; i < n; i++) a[0][i] = (s[i]-'0');\n  ans = 0;\n  dfs(1, 0, 1);\n  cout << ans << endl;\n}\n\nint main() {\n  int T;\n  pre_compute();\n  cin >> T;\n  while (T--) solve();\n  return 0;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"結論"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"先枚舉一部分的數值，並試圖留下一些完全不互相影響的待枚舉部分。如此一來，每一個獨立的部分可以各自用預處理的技巧快速找出答案。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"include-problem","properties":{"notyet":"","path":"/problem/cf/217/B"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]}],"data":{"quirksMode":false}},"frontmatter":{"date":"December 16, 2018","path":"/algo/enumeration-2","title":"枚舉法 2：利用相依性 Dependency","description":null}}},"pageContext":{}}