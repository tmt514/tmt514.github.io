{"data":{"markdownRemark":{"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"簡化後題目敘述"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"輸入可能包含多組測試資料。每一組測試資料第一列包含一個正整數 $n$，接下來有 $n$ 列分別包含兩個整數 $x_i, y_i$ （$-10^9\\le x_i, y_i\\le 10^9$）。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸出說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"4\n0 0\n0 2\n2 0\n2 2\n5\n0 0\n0 2\n2 0\n2 2\n1 1\n0\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"YES\nNO\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ 連結"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://open.kattis.com/problems/kingdomofkittens"},"children":[{"type":"text","value":"Open Kattis - Kingdom of Kittens"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"題目出處"}]},{"type":"text","value":"：ICPC 2018 Asia Hanoi Regional"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"唉。這種痛苦的計算幾何題好像似曾相識（遠目）"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這題的難點在於特別的 case 也太多了，尤其是，三角形可以有某個邊上面只包含一個點的情況。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"比我的作法簡單的方法應該有很多很多種。今天就獻醜了。如果有更好的解法歡迎提供！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我的作法是：先計算一個凸包（這個凸包上的點如果 $>6$ 個那就沒救了），然後找出哪些凸包上的邊「一定要出現在三角形裡面」。可能有 0~3 條。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"一些好用的測資"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"7\n2 0\n1 1\n0 2\n8 0\n9 1\n10 2\n5 3\n7\n0 0\n0 1\n0 2\n1 0\n2 0\n3 1\n4 3\n8\n0 0\n0 1\n0 2\n1 2\n2 2\n2 1\n2 0\n1 0\n5\n1 0\n2 0\n3 0\n1 6\n2 6\n7\n0 0\n0 0\n0 0\n0 0\n0 0\n0 0\n0 0\n6\n1 0\n2 0\n3 0\n2 6\n3 6\n4 6\n7\n1 0\n2 0\n3 0\n3 3\n0 1\n0 2\n0 3\n7\n0 2\n1 1\n2 0\n7 0\n8 1\n9 2\n5 -1\n7\n0 2\n1 1\n2 0\n3 0\n4 0\n5 1\n6 2\n7\n0 2\n1 0\n2 0\n3 0\n4 1\n5 2\n7 8\n7\n0 2\n1 0\n2 0\n3 0\n4 1\n5 2\n7 10\n7\n0 2\n1 0\n2 0\n3 0\n4 1\n5 2\n7 9\n8\n0 0\n0 1\n0 2\n1 0\n1 4\n2 0\n2 1\n2 2\n7\n0 0\n0 1\n0 2\n1 0\n2 0\n1 3\n2 3\n6\n0 0\n0 1\n5 0\n5 10\n1 9\n4 10\n6\n0 0\n0 1\n0 2\n6 0\n2 0\n5 0\n5\n0 0\n0 1\n0 2\n0 3\n0 4\n6\n0 0\n0 1\n1 0\n2 3\n3 2\n3 3\n4\n0 0\n0 2\n2 0\n1 1\n4\n0 0\n0 2\n2 0\n2 2\n5\n0 0\n0 2\n2 0\n2 2\n1 1\n0\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"答案應該要是"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"YES\nNO\nNO\nYES\nYES\nNO\nYES\nNO\nNO\nYES\nNO\nNO\nNO\nNO\nNO\nYES\nYES\nYES\nYES\nYES\nNO\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long double Double;\n\nclass Point {\n  public:\n    long long x, y;\n    \n    Point(long long _x=0, long long _y=0): x(_x), y(_y) {}\n    Point operator+(const Point &q) const {\n      return Point(x + q.x, y + q.y);\n    }\n    Point operator-(const Point &q) const {\n      return Point(x - q.x, y - q.y);\n    }\n    bool operator<(const Point &q) const {\n      if (x != q.x) return x < q.x;\n      return y < q.y;\n    }\n    bool operator==(const Point &q) const {\n      return x == q.x && y == q.y;\n    }\n    Double length() const {\n      return sqrtl(x*x+y*y);\n    }\n  friend istream& operator>>(istream& in, Point& p) {\n    in >> p.x >> p.y;\n    return in;\n  }\n    \n};\n\n\nlong long cross(const Point &p, const Point &q) {\n  return p.x * q.y - p.y * q.x;\n}\nlong long dot(const Point &p, const Point &q) {\n  return p.x * q.x + p.y * q.y;\n}\n\nDouble GetAngle(const Point &u, const Point &v) {\n  Double t = ((Double)dot(u, v) / u.length() / v.length());\n  return acosl(t);\n}\n\nbool CheckInvalid(const vector<Point> &angles) {\n  for (size_t i=0;i<angles.size();i++)\n    for(size_t j=i+1;j<angles.size();j++)\n      if(cross(angles[i], angles[j]) == 0)\n        return true;\n\n// 這邊判斷逆時針的三個方向是否真的可以湊成一個涵蓋凸包範圍的三角形。\n  if (angles.size() == 3) {\n    bool f0 = (cross(angles[0], angles[1]) < 0)^(cross(angles[0], angles[2]) < 0);\n    bool f1 = (cross(angles[1], angles[0]) < 0)^(cross(angles[1], angles[2]) < 0);\n    bool f2 = (cross(angles[2], angles[0]) < 0)^(cross(angles[2], angles[1]) < 0);\n    if (!f0 || !f1 || !f2)\n      return true;\n  }\n  return false;\n}\n\nvector<Point> p;\n\nbool IsRightTurn(int A, int B, int C) {\n  return cross(p[B]-p[A], p[C]-p[B]) <= 0;\n}\n\nbool solve() {\n  int N;\n  cin >> N;\n  if (N == 0) return false;\n\n  p.resize(N);\n  for (int i = 0; i < N; i++) cin >> p[i];\n  sort(p.begin(), p.end());\n  \n  N = unique(p.begin(), p.end()) - p.begin();\n  p.resize(N);\n\n  if (N <= 3) {\n    cout << \"YES\" << '\\n';\n    return true;\n  }\n\n  deque<int> cvx, cvx_upper;\n  for(int i=0;i<N;i++) {\n    while (cvx.size() >= 2 &&\n        IsRightTurn(cvx[cvx.size()-2], cvx[cvx.size()-1], i)) {\n      cvx.pop_back();\n    }\n    cvx.push_back(i);\n  }\n  for(int i=N-1;i>=0;i--) {\n    while (cvx_upper.size() >= 2 &&\n        IsRightTurn(cvx_upper[cvx_upper.size()-2], cvx_upper[cvx_upper.size()-1], i)) {\n      cvx_upper.pop_back();\n    }\n    cvx_upper.push_back(i);\n  }\n  for(size_t i=1;i+1<cvx_upper.size();i++) cvx.push_back(cvx_upper[i]);\n  \n  while (cvx.size() >= 3 &&\n      IsRightTurn(cvx[cvx.size()-1], cvx[0], cvx[1])) {\n    cvx.pop_front();\n  }\n\n  // 超過六條邊就一定是 NO 了。\n  if (cvx.size() > 6) {\n    cout << \"NO\" << endl;\n    return true;\n  }\n  \n\n  \n  // 所有點都要在凸包上，並紀錄哪些凸包上的邊有點。\n  vector<bool> has_edge(cvx.size(), false);\n  cvx.push_back(cvx[0]);\n  for (int i = 0; i < N; i++) {\n    int ok = false;\n    for (size_t j = 0; j+1 < cvx.size(); j++) {\n      if (cross(p[cvx[j]]-p[i], p[i]-p[cvx[j+1]]) == 0) {\n        if (cvx[j] != i && cvx[j+1] != i) {\n          has_edge[j] = true;\n        }\n        ok = true;\n      }\n    }\n    if (!ok) {\n      cout << \"NO\" << '\\n';\n      return true;\n    }\n  }\n  \n  // 如果是共線或三角形的情形，就一定是 YES 了。\n  if (has_edge.size() <= 3) {\n    cout << \"YES\" << endl;\n    return true;\n  }\n  \n\n  // 檢查必須擁有的邊是否都不平行。\n  int cnt = 0;\n  vector<Point> angles;\n  for (size_t i = 0; i+1 < cvx.size(); i++) {\n    if (has_edge[i]) {\n      angles.push_back(p[cvx[i+1]]-p[cvx[i]]);\n      ++cnt;\n    }\n  }\n  if (cnt > 3 || CheckInvalid(angles)) {\n    cout << \"NO\" << endl;\n    return true;\n  }\n\n  \n  // 少於五條邊不一定是 YES。\n  // 如果兩條邊固定了，看看是否還有兩個以上還沒蓋到的點。\n  vector<int> empty_point;\n  if(!has_edge[0] && !has_edge.back()) empty_point.push_back(0);\n  for (size_t i=1;i+1<cvx.size();i++) {\n    if(!has_edge[i] && !has_edge[i-1]) {\n      empty_point.push_back(i);\n    }\n  }\n\n  if (empty_point.empty()) {\n    cout << \"YES\" << endl;\n    return true;\n  }\n\n\n  if (cnt == 3 && !empty_point.empty()) {\n    cout << \"NO\" << endl;\n    return true;\n  }\n\n  // Case #9 有這個\n  if (has_edge.size() == 5 && cnt == 2) {\n    if (empty_point.size() == 2) {\n      if (empty_point[1] != empty_point[0]+1 &&\n          (empty_point[0] != 0 ||\n           empty_point[1] != (int)has_edge.size()-1)) {\n        cout << \"NO\" << endl;\n        return true;\n      }\n      if (empty_point[1] == (int)has_edge.size()-1 && empty_point[0] == 0)\n        swap(empty_point[0], empty_point[1]);\n      angles.push_back(p[cvx[empty_point[1]]]-p[cvx[empty_point[0]]]);\n      if (CheckInvalid(angles)) {\n        cout << \"NO\" << endl;\n        return true;\n      } else {\n        cout << \"YES\" << endl;\n        return true;\n      }\n    }\n  }\n\n\n  // 如果兩條邊固定了，取決於剩下那個點出現在那一邊。\n  if (cnt == 2 && empty_point.size() == 1 && has_edge.size() == 5) {\n    \n    int i = empty_point[0];\n    Point first = p[cvx[(i+2)%5]] - p[cvx[(i+1)%5]];\n    Point second = p[cvx[(i+4)%5]] - p[cvx[(i+3)%5]];\n    \n    if (cross(first, second) <= 0) {\n      cout << \"NO\" << endl;\n      return true;\n    }\n    \n  }\n\n\n\n  // 剩下的情況，少於五條邊一定是 YES。\n  if (has_edge.size() <= 5) {\n    cout << \"YES\" << endl;\n    return true;\n  }\n\n\n\n\n  // 只剩下兩種可能。\n  // 1. 考慮偶數位置的邊。\n  vector<Point> odds = { p[cvx[1]]-p[cvx[0]],\n    p[cvx[3]]-p[cvx[2]],\n    p[cvx[5]]-p[cvx[4]]};\n\n  if (CheckInvalid(odds) == false) {\n    bool alleven = (!has_edge[1] && !has_edge[3] && !has_edge[5]);\n    if (alleven) {\n      cout << \"YES\" << '\\n';\n      return true;\n    }\n  }\n  \n  \n  // 2. 考慮奇數位置的邊。\n  vector<Point> evens = { p[cvx[2]]-p[cvx[1]],\n    p[cvx[4]]-p[cvx[3]],\n    p[cvx[0]]-p[cvx[5]]};\n  \n  \n  if (CheckInvalid(evens) == false) {\n    bool allodd = (!has_edge[0] && !has_edge[2] && !has_edge[4]);\n    if (allodd) {\n      cout << \"YES\" << '\\n';\n      return true;\n    }\n  }\n  cout << \"NO\" << '\\n';\n  return true;\n}\n\nint main() {\n  while (solve());\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"關於競程日記"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"🍅 如果您想到更多有趣漂亮簡單乾淨的解法話歡迎留言給競程日記小編群！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"ℹ️ 這是一篇投稿給"},{"type":"element","tagName":"a","properties":{"href":"https://www.facebook.com/%E7%AB%B6%E7%A8%8B%E6%97%A5%E8%A8%98-1514973425463954/"},"children":[{"type":"text","value":"競程日記"}]},{"type":"text","value":"的文章，歡迎大家投稿、交流與分享程式解題競賽的點點滴滴！"}]}],"data":{"quirksMode":false}},"frontmatter":{"date":"January 11, 2019","path":"/problem/icpc/asia_hanoi_2018/K","title":"Kingdom of Kittens","description":"給定平面上 $n$ ($1\\le n\\le 10^5$) 個點，判斷是否存在一個三角形，使得所有點都在這個三角形的邊界或頂點上？\n","roadmap_label_h3":null,"backlink":"/icpcblog-weekly-2019"}}},"pageContext":{}}