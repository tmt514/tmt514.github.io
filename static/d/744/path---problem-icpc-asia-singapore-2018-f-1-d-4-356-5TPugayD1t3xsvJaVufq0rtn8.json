{"data":{"markdownRemark":{"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"簡化後題目敘述"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"第一列包含一個正整數 $N$ ($1\\le N\\le 400000$)。\n第二列開始有 $N$ 列，每一列包含一個正整數 $S_i$ ($1\\le S_i\\le N$)。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸出說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"若存在答案，請輸出 $A, B$ 之值。若不存在形如 $A, B, A, B$ 的子序列，輸出 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"-1"}]},{"type":"text","value":"。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"8\n1\n3\n2\n4\n1\n5\n2\n4\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"1 2\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"8\n1\n2\n3\n4\n5\n6\n7\n1\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"-1\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 3"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"4\n2\n1\n2\n1\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 3"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"2 1\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ 連結"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://open.kattis.com/problems/wiknow"},"children":[{"type":"text","value":"Open Kattis - Wi Know"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"題目出處"}]},{"type":"text","value":"：ICPC 2018 Asia Singapore Regional"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我們可以先做出以下觀察：如果存在至少一組交錯的子序列 A, B, A, B，那麼 A 總可以是序列中第一次出現的那個 A、而 B 總可以挑選序列中最後一次出現的 B。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"於是，對於每一個 A，我們想知道 A 的右邊的第一個 B、還有跟 A 左邊出現最靠近的 B，滿足這個條件的 B 的最小值。對於一個特定數字 X，那麼我們可以把整個序列，依據所有 X 出現過的位置，切成許多區間。\n利用「掃描線」的概念，從右到左，維護目前跨過這條掃描線的區間們。\n假設現在掃描線所在的位置是一個 A 數字，那麼所有橫跨過這個區間、並且左界落在「第一個 A 的右邊」的那些區間編號最小者，就會是一個可能的答案。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如下圖黑色部份："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"mysvg","properties":{"width":400,"height":200,"viewbox":"0 0 400 200"},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"line","properties":{"x1":"200","x2":"200","y1":"0","y2":"200","stroke":"black","strokeDasharray":"3"},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"text","properties":{"x":"200","y":"16"},"children":[{"type":"text","value":"A"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"text","properties":{"x":"140","y":"16"},"children":[{"type":"text","value":"A"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"text","properties":{"x":"100","y":"16"},"children":[{"type":"text","value":"A"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"line","properties":{"x1":"200","x2":"100","y1":"20","y2":"20","strokeWidth":"4pt","stroke":"black"},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"text","properties":{"x":"120","y":"46","fill":"red"},"children":[{"type":"text","value":"B"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"text","properties":{"x":"150","y":"46","fill":"red"},"children":[{"type":"text","value":"B"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"text","properties":{"x":"230","y":"46","fill":"red"},"children":[{"type":"text","value":"B"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"line","properties":{"x1":"150","x2":"230","y1":"50","y2":"50","strokeWidth":"4pt","stroke":"red"},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"circle","properties":{"cy":"50","cx":"350","r":"10","fill":"none","strokeWidth":"4pt","stroke":"red"},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"text","properties":{"x":"170","y":"76","fill":"gold"},"children":[{"type":"text","value":"C"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"text","properties":{"x":"260","y":"76","fill":"gold"},"children":[{"type":"text","value":"C"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"line","properties":{"x1":"170","x2":"260","y1":"80","y2":"80","strokeWidth":"4pt","stroke":"gold"},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"circle","properties":{"cy":"80","cx":"350","r":"10","fill":"none","strokeWidth":"4pt","stroke":"gold"},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"text","properties":{"x":"270","y":"106","fill":"green"},"children":[{"type":"text","value":"D"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"text","properties":{"x":"60","y":"106","fill":"green"},"children":[{"type":"text","value":"D"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"line","properties":{"x1":"270","x2":"60","y1":"110","y2":"110","strokeWidth":"4pt","stroke":"green"},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"path","properties":{"d":"M 340,100 L 360,120 M 340,120 L 360,100","strokeWidth":"4pt","stroke":"green"},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"text","properties":{"x":"120","y":"136","fill":"blue"},"children":[{"type":"text","value":"E"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"text","properties":{"x":"240","y":"136","fill":"blue"},"children":[{"type":"text","value":"E"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"line","properties":{"x1":"120","x2":"240","y1":"140","y2":"140","strokeWidth":"4pt","stroke":"blue"},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"circle","properties":{"cy":"140","cx":"350","r":"10","fill":"none","strokeWidth":"4pt","stroke":"blue"},"children":[]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"那麼我們只要找出與黑色區間相交的「最小編號」區間就可以了！實作上我們維護一個區間樹，當掃描線從右掃到左的時候，先將「離開的區間」刪掉，然後再依據當前區間 $[\\ell, r]$，查詢現在「左界 $>\\ell$」的區間編號最小值。然後再將當前區間左界加入區間樹。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"#include <bits/stdc++.h>\nusing namespace std;\n\n// 關於區間樹的操作：依序為插入、刪除、詢問。\nconst int LEAF_OFFSET = (1<<19);\nint tree[(1<<20)];\ninline int GetMinLabel(int l, int r) {\n  if (l == 0 || r == 0) return l+r;\n  return min(l, r);\n}\nvoid Insert(int x, int label) {\n  x += LEAF_OFFSET;\n  tree[x] = label;\n  for (x/=2; x; x/=2)\n    tree[x] = GetMinLabel(tree[x*2], tree[x*2+1]);\n}\nvoid Remove(int x) {\n  x += LEAF_OFFSET;\n  tree[x] = 0;\n  for (x/=2; x; x/=2)\n    tree[x] = GetMinLabel(tree[x*2], tree[x*2+1]);\n}\nint Query(int l) {\n  l += LEAF_OFFSET;\n  int ans = tree[l];\n  while (l) {\n    if (l%2==0)\n      ans = GetMinLabel(ans, tree[l+1]);\n    l/=2;\n  }\n  return ans;\n}\n\n\n// 紀錄輸入的序列。\nint S[400005];\nvector<int> positions[400005];\n\npair<int, int> best = {-1, -1};\nvoid UpdateSolution(int A, int B) {\n  if (best.first == -1 || best > make_pair(A, B)) {\n    best = {A, B};\n  }\n}\n\nvoid OutputAnswer() {\n  if (best.first == -1) cout << \"-1\" << endl;\n  else cout << best.first << \" \" << best.second << endl;\n}\n\nint main() {\n  int N;\n  cin >> N;\n  for (int i = 0; i < N; i++) {\n    cin >> S[i];\n    positions[S[i]].push_back(i);\n  }\n  for (int i = N-1; i >= 0; i--) {\n    int A = S[i];\n    positions[A].pop_back();\n    Remove(i);\n    if (!positions[A].empty()) {\n      int B = Query(positions[A][0]);\n      if (B > 0) UpdateSolution(A, B);\n      Insert(positions[A].back(), A);\n    }\n  }\n  OutputAnswer();\n  return 0;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"夢月說"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"花一分鐘想不出來，花三分鐘就想到了！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"關於競程日記"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"🍅 如果您想到更多有趣漂亮簡單乾淨的解法話歡迎留言給競程日記小編群！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"ℹ️ 這是一篇投稿給"},{"type":"element","tagName":"a","properties":{"href":"https://www.facebook.com/%E7%AB%B6%E7%A8%8B%E6%97%A5%E8%A8%98-1514973425463954/"},"children":[{"type":"text","value":"競程日記"}]},{"type":"text","value":"的文章，歡迎大家投稿、交流與分享程式解題競賽的點點滴滴！"}]}],"data":{"quirksMode":false}},"frontmatter":{"date":"January 15, 2019","path":"/problem/icpc/asia_singapore_2018/F","title":"Wi Know","description":"給你一個長度為 $N$ 的序列 $S_1, S_2, \\ldots, S_N$，請找出字典順序最小的 $(A, B)$ 配對，使得 $A\\neq B$ 而且這個序列包含至少一個子序列 $A, B, A, B$。\n","roadmap_label_h3":null,"backlink":"/icpcblog-weekly-2019"}}},"pageContext":{}}