{"data":{"markdownRemark":{"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"簡化後題目敘述"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"輸入的第一列包含兩個整數 $N, K$ ($1\\le N\\le 100000; 0\\le K \\le 100000$) 代表序列的長度與條件的數量。第二列包含 $N$ 個整數 $P_i$ ($-1\\le P_i\\le 1$)，若 $P_i=0$ 代表第 $i$ 個位置還沒有決定是 $-1$ 還是 $1$，否則的話 $P_i$ 的值已經固定了。接下來的 $K$ 列每一列包含三個整數 $A_i, B_i, C_i$ ($1\\le A_i \\le B_i\\le N; -N\\le C_i\\le N$)。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸出說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"若這樣的序列存在，輸出 $N$ 個以空白隔開的整數。否則輸出 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"Impossible"}]},{"type":"text","value":"。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"3 2\n0 0 0\n1 2 2\n2 3 -1\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"1 1 -1\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"3 2\n0 -1 0\n1 2 2\n2 3 -1\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"Impossible\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ 連結"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://codeforces.com/gym/102001/problem/H"},"children":[{"type":"text","value":"Codeforces Gym 102001 - H"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"通常要找出最小的字典順序的題目，絕對與 Greedy 演算法脫不了干係。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"從前面填過去"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這題一個直接的想法就是從最前面開始，依序在空格（$P_i=0$ 處）填上 $-1$，並看看是否違反任何一個條件。但直接做要花 $O(NK)$ 的時間，所以實際上"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"從後面改回來"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"另一個我覺得在演算法上面很實用的方法——拖延法（Lazy Evaluation，總是拖到最後一刻才作必要的改變），也可以用在這題當中。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我們先把所有能夠填數字的地方全部填上 $-1$，然後逐一檢視每個條件 $(A_i, B_i, C_i)$，如果這個條件沒有被滿足，那我們便貪心地從 $B_i$ 往回查看，把所有能改的 $-1$ 依序改成 $1$，直到條件被滿足為止。如果按照"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"右界"}]},{"type":"text","value":" $B_i$ 由小到大依序把條件加進去的話，每一次把 $-1$ 改成 $1$ 的過程，都保證會造福未來的條件，因此感情上我們可以得到字典順序最小的解。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"檢查一個條件需要計算一段連續和，如果不想花太多力氣的話，一個簡單的 "},{"type":"element","tagName":"a","properties":{"href":"https://zh.wikipedia.org/wiki/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84"},"children":[{"type":"text","value":"Fenwick Tree(BIT)"}]},{"type":"text","value":" 就可以達到目標。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我們注意到，當我們決定要把一個 $-1$ 改成 $1$ 的時候，這個數字就再也不會更改了。按照右界順序考慮條件還有第二個好處：可以把「仍然可改」的位置丟進一個"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"堆疊"}]},{"type":"text","value":"裡面，這個堆疊最上面的索引就恰好是距離當前右界最接近的一個。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"#include <iostream>\n#include <vector>\nusing namespace std;\n\nint input[100005];\nint now[100005];\nvector<pair<int, int>> hook[100005];\nvector<int> stack;\nint N, K;\n\n// 一個活生生、跳脫框架（好像不太應該）的 Fenwick Tree。\nint bit[100005];\n\n// 把 x 這格的值加上 v。\nvoid add(int x, int v) {\n  while (x <= N) {\n    bit[x] += v;\n    x += (x & -x);\n  }\n}\n\n// 計算序列前 x 項的總和。\nint ask(int x) {\n  int ret = 0;\n  while (x) {\n    ret += bit[x];\n    x -= (x & -x);\n  }\n  return ret;\n}\n\n// 計算序列從第 l 項到第 r 項的總和。\nint ask(int l, int r) { return ask(r) - ask(l - 1); }\n\nint main() {\n  cin >> N >> K;\n  for (int i = 1; i <= N; i++) cin >> input[i];\n  for (int i = 1; i <= N; i++) now[i] = (input[i] != 0 ? input[i] : -1);\n  for (int i = 1; i <= N; i++) add(i, now[i]);\n  // 把所有條件依照右界的順序\n  for (int i = 0; i < K; i++) {\n    int l, r, c;\n    cin >> l >> r >> c;\n    hook[r].push_back({l, c});\n  }\n  for (int i = 1; i <= N; i++) {\n    // 如果現在這格是空的，就把註標塞進堆疊裡備用。\n    if (input[i] == 0) stack.push_back(i);\n    \n    // 逐一掃過所有右界在 i 的條件，並試圖滿足他們。\n    for (auto [l, c] : hook[i]) {\n      int v = ask(l, i);\n      // 如果當前總和仍不達 c，就必須把最接近的 -1 改成 1。\n      while (v < c) {\n        if (stack.empty() || stack.back() < l) {\n          puts(\"Impossible\");\n          return 0;\n        }\n        v += 2;\n        now[stack.back()] = 1;\n        add(stack.back(), 2);\n        stack.pop_back();\n      }\n    }\n  }\n  for (int i = 1; i <= N; i++) {\n    cout << now[i] << ' ';\n  }\n  cout << endl;\n  return 0;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"備註"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"稍微多想一下下，這題其實可以做到 $O(N+K)$。不過以比賽而言，$O((N+K)\\log N)$ 很夠了。提示：可以先經過線性時間預處理，把已經固定數值的地方全部處理掉。因此題目可以轉化為在一個空的序列上指定 $\\pm 1$ 的數值。接下來，我們可以利用 Disjoint Set，維護已經被改成 $1$ 的所有位置（以區間的方式儲存，如果相鄰兩個位置都是 $1$，那麼這兩個位置同屬一個 Set。）"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"display","properties":{"array":"","uihelperContentMap":"{\n        \"1\":{fill: \"#FA8\", font: \"bold 24px Courier New\"},\n    }","data":"[\"-1\", \"1\", \"-1\", \"1\"]"},"children":[{"type":"text","value":"\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"因此計算連續和的任務就等價於紀錄當前區間「左方」的區間長度總和。這個「左方區間長度總和」的值，很幸運地不會頻繁地被更新（因為更新只會從已考慮過的位置最右邊開始，也就是當前的最右邊的區間。）"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"關於 Greedy 演算法的證明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這真的真的很恐怖。不要問。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Greedy 演算法是一類，通常直覺上很對，證明起來卻很崩潰的一類演算法（淚眼算法）。可以參考 "},{"type":"element","tagName":"a","properties":{"href":"https://cs.stackexchange.com/questions/59964/how-to-prove-greedy-algorithm-is-correct"},"children":[{"type":"text","value":"Stack Exchange"}]},{"type":"text","value":"、"},{"type":"element","tagName":"a","properties":{"href":"http://www.cs.cornell.edu/courses/cs482/2007su/exchange.pdf"},"children":[{"type":"text","value":"康乃爾大學講義"}]},{"type":"text","value":"、"},{"type":"element","tagName":"a","properties":{"href":"https://web.stanford.edu/class/archive/cs/cs161/cs161.1138/handouts/120%20Guide%20to%20Greedy%20Algorithms.pdf"},"children":[{"type":"text","value":"史丹佛大學講義"}]},{"type":"text","value":"對於證明貪婪演算法的正確性所下的註解。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"關於競程日記"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"🍅 如果您想到更多有趣漂亮簡單乾淨的解法話歡迎留言給競程日記小編群！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"ℹ️ 這是一篇投稿給"},{"type":"element","tagName":"a","properties":{"href":"https://www.facebook.com/%E7%AB%B6%E7%A8%8B%E6%97%A5%E8%A8%98-1514973425463954/"},"children":[{"type":"text","value":"競程日記"}]},{"type":"text","value":"的文章，歡迎大家投稿、交流與分享程式解題競賽的點點滴滴！"}]}],"data":{"quirksMode":false}},"frontmatter":{"date":"January 05, 2019","path":"/problem/icpc/asia_jakarta_2018/H","title":"Lexical Sign Sequence","description":"給你一個包含 $0, 1, -1$ 的序列 $P$，你的任務是要把所有 $0$ 換成 $\\pm 1$，並同時滿足以下 $K$ 個條件：每一個條件由三個整數 $A_i, B_i, C_i$ 描述之，表示從第 $A_i$ 個數加至第 $B_i$ 個數的總和，必須要 $\\ge C_i$。\n\n若有解，請輸出字典順序最小的序列。否則的話輸出 `Impossible`。\n","roadmap_label_h3":null,"backlink":"/icpcblog-weekly-2019"}}},"pageContext":{}}