{"data":{"markdownRemark":{"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"簡化後題目敘述"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"輸入包含多組測試資料，並以 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"0 0"}]},{"type":"text","value":" 作結束。每一筆測試資料包含 6 列："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"第一列有兩個正整數 $N, M$ （$1\\le M, N\\le 100$）"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"第二列有兩個正整數 $r_B, c_B$，表示英文字母 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"B"}]},{"type":"text","value":" 的位置。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"第三列有兩個正整數 $r_C, c_C$，表示英文字母 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"C"}]},{"type":"text","value":" 的位置。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"第四列有兩個正整數 $r_G, c_G$，表示英文字母 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"G"}]},{"type":"text","value":" 的位置。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"第五列有兩個正整數 $r_U, c_U$，表示英文字母 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"U"}]},{"type":"text","value":" 的位置。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"第六列為空白列。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"輸入保證 $1\\le r_B, r_C, r_G, r_U \\le N$ 且 $1\\le c_B, c_C, c_G, c_U\\le M$ 而且四個英文字母的位置不會重疊。\n所有輸入的 $N\\times M$ 加起來不會超過 $10^5$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"請注意：列的編號"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"從下往上"}]},{"type":"text","value":"編號為 1 到 $N$；行的編號"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"從左往右"}]},{"type":"text","value":"編號為 1 到 $M$。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸出說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"對於每一筆測試資料輸出 1 或 2 列。\n首先輸出是否存在滿足題目要求的路徑（"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"YES"}]},{"type":"text","value":" 或 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"NO"}]},{"type":"text","value":"）。如果答案是 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"YES"}]},{"type":"text","value":"，在第二列輸出任何一個滿足條件的最短路徑。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"3 3\n1 1\n3 3\n2 1\n2 2\n\n3 4\n1 1\n3 4\n2 1\n1 2\n\n2 2\n2 1\n2 2\n1 2\n1 1\n\n0 0\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"YES\nRRUULLD\nNO\nYES\nRD\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ 連結"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://open.kattis.com/problems/amazingadventures"},"children":[{"type":"text","value":"Open Kattis - Amazing Adventures"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這個題目很巧妙地利用了在圖上進行 DFS （或 BFS）遍歷的特性。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我們不妨假設整個圖 $G$ 是連通的，考慮從 $G$ 上面任何一個點出發先做一次 DFS。\n由於這個圖是無向圖，所有的邊會根據搜索的情形被分成兩種：在 DFS 樹上的邊（我們稱為 tree edge）、以及不在樹上的邊（此時稱為 back edge，因為發現時一定連到 DFS 樹上的祖先）。\n我們可以把所有的 back edge「掛在」比較深的點，這麼一來整張圖就會在搜索的過程看起來像是一棵樹（BFS也會有類似的效果）。\n對於這樣的樹來說，我們總可以從「葉子」的部份以 Greedy 的方法每次抓相連的兩條 sibling 邊（他們都是從同一個節點出發找到的），然後把它變成迴力標，然後把兩條邊拔掉。\n不難發現，這種拔法可以保證 (1) 拔完之後整個圖還是連通的、以及 (2) 剩下的圖用「數學歸納法」，保證可以拔出最大迴力標的數量。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"因此，根據以上的演算法，我們也在過程中證明了最大的迴力標數量總是 $\\lfloor |E|/2\\rfloor$ 組。而實作上也可以達到線性複雜度，很小品吧 😃"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"display","properties":{"graph":"","undirected":"","unweighted":"","data":"{\n    \"nodes\": [1, 2, 3, 4, 5],\n    \"edges\": [[1, 2], [1, 4], [2, 4], [2, 3], [3, 4], [2, 5], [3, 5]],\n  }","uihelperIdMap":"{\n        \"[1,2]\":{stroke: \"blue\", strokeWidth: \"5\"},\n        \"[1,4]\":{stroke: \"blue\", strokeWidth: \"5\"},\n        \"[2,4]\":{stroke: \"green\", strokeWidth: \"5\"},\n        \"[2,3]\":{stroke: \"green\", strokeWidth: \"5\"},\n        \"[3,4]\":{stroke: \"red\", strokeWidth: \"5\"},\n        \"[3,5]\":{stroke: \"red\", strokeWidth: \"5\"},\n    }"},"children":[{"type":"text","value":"\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"#include <iostream>\n#include <tuple>\n#include <vector>\nusing namespace std;\n\nint N, M;\nvector<int> a[100005];\nint x[100005], y[100005];\nint used[100005];\nvector<tuple<int, int, int>> ans;\n\nint neighbor(int eid, int u) { return x[eid] + y[eid] - u; }\n\n// 如果 dfs 回來以後還有一條邊沒有被配對，那就回傳這條邊，否則回傳 -1。\nint dfs(int u, int from=-1) {\n  int at_hand = -1;\n  // 依序考慮過所有的邊，但是因為 dfs 會經過同一個點很多次，\n  // 所以不妨用一個類似 stack 的方式實作，每走過一條邊就把這條邊去掉。\n  while (!a[u].empty()) {\n    int eid = a[u].back();\n    a[u].pop_back();\n    if (used[eid]) continue;\n    used[eid] = true;\n    int v = neighbor(eid, u);\n    int ret = dfs(v, eid);\n    if (ret == -1) continue;\n    if (at_hand == -1) {\n      at_hand = ret;\n    } else {\n      ans.emplace_back(v, u, neighbor(at_hand, u));\n      at_hand = -1;\n    }\n  }\n  if (at_hand != -1 && from != -1) {\n    ans.emplace_back(neighbor(at_hand, u), u, neighbor(from, u));\n    return -1;\n  } else if (from != -1) {\n    return from;\n  }\n  return -1;\n}\n\nint main() {\n  cin >> N >> M;\n  for (int i = 0; i < M; i++) {\n    cin >> x[i] >> y[i];\n    a[x[i]].push_back(i);\n    a[y[i]].push_back(i);\n  }\n  // 對於每個點進行 DFS，如果早就探索完了，那相鄰邊也都會被拔光，所以不用擔心重複搜索。\n  for (int i = 1; i <= N; i++) dfs(i);\n  \n  cout << ans.size() << endl;\n  // C++17 Structural Binding 好物，越來越像 python 了。\n  for (auto [u, v, w]: ans)\n    cout << u << \" \" << v << \" \" << w << '\\n';\n  return 0;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"備註 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"其實這題的重點在於把 Graph 透過搜索的過程拆成樹，然後在樹上面做迴力標的分組。大家可以試著用 BFS 寫看看～"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"備註 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"不好意思，今天操作型動畫來不及生出來...如果生出來的圖有點醜的話，大家可以多重新整理幾次喔～"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"關於競程日記"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"🍅 如果您想到更多有趣漂亮簡單乾淨的解法話歡迎留言給競程日記小編群！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"ℹ️ 這是一篇投稿給"},{"type":"element","tagName":"a","properties":{"href":"https://www.facebook.com/%E7%AB%B6%E7%A8%8B%E6%97%A5%E8%A8%98-1514973425463954/"},"children":[{"type":"text","value":"競程日記"}]},{"type":"text","value":"的文章，歡迎大家投稿、交流與分享程式解題競賽的點點滴滴！"}]}],"data":{"quirksMode":false}},"frontmatter":{"date":"January 08, 2019","path":"/problem/icpc/asia_hanoi_2018/A","title":"Amazing Adventures","description":"在一個有 $N$ 列、$M$ 行的方格上，有四個英文字母 `B`, `C`, `G`, `U`。請你找出最短的、從 `B` 經過 `C` 到 `G` 但是不包括 `U` 的路徑，使得每一個格子（包含起點與終點）都不能重複經過。輸出這個路徑。\n","roadmap_label_h3":null,"backlink":"/icpcblog-weekly-2019"}}},"pageContext":{}}