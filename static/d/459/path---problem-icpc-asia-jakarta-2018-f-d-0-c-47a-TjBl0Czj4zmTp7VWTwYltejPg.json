{"data":{"markdownRemark":{"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"題目敘述"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"輸入的第一列包含兩個正整數 $N, M$ （$1\\le N\\le 100000; 1\\le M\\le 10^9$）依序代表題目的數量與比賽的時間長度。第二列包含 $N$ 個整數 $A_i$（$1\\le A_i\\le 10^9$），第三列包含 $N$ 個整數 $B_i$（$1\\le B_i\\le 10^9$）。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸出說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果不存在任何方法使得 Ayu 最終題數嚴格大於 Budi 的題數，輸出 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"-1"}]},{"type":"text","value":"。否則的話輸出一個整數 $K$，然後在第二列輸出 $K$ 個嚴格遞增的數字：Ayu 只要在這些時間點戳破氣球，就可以贏過 Budi。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"4 30\n9 10 10 10\n4 10 5 10\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"2\n12 19\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"5 50\n10 10 10 10 10\n15 12 19 17 20\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"0\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 3"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"5 10\n15 10 5 5 5\n9 10 10 10 10\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 3"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"-1\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ 連結"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://codeforces.com/gym/102001/problem/F"},"children":[{"type":"text","value":"Codeforces Gym 102001 - F"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"俗話說得好："},{"type":"element","tagName":"s","properties":{},"children":[{"type":"text","value":"氣球恆久遠，一顆永流傳。"}]},{"type":"text","value":"如果 Ayu 在 Budi 解題目解到一半的時候戳破氣球嚇他，倒不如多等一下，在 Budi 即將解出來的那剎那"},{"type":"element","tagName":"s","properties":{},"children":[{"type":"text","value":"說時遲那時快"}]},{"type":"text","value":"再把氣球戳破，讓 Budi 重來感覺豈不是更好嗎！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"假設我們有個答案，那我們可以把 Budi 的解題心路歷程記錄下來，比方說："}]},{"type":"text","value":"\n$$\nB_1, B_2, \\red{B_3}, \\red{B_3}, B_3, \\red{B_4}, B_4, B_5, ...\n$$\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果今天 $B_3 < B_4$，那麼 Ayu 總是可以再多等一下，讓 Budi 重做 B"},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"4 總是比重做 B"}]},{"type":"text","value":"3 更划算！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果輸入的字串是 Lyndon word，那麼我們可以得到兩個觀察："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"last[]"}]},{"type":"text","value":" 陣列，從左到右一旦有數字變小，永遠是從 $-1$ 開始，不會從中間繼續。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Lyndon word 做出來的 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"last[]"}]},{"type":"text","value":" 陣列，最後一個 last 值永遠是 $-1$。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"所以 DFS 就很簡單啦：每次決定到底現在的 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"last[i]"}]},{"type":"text","value":" 要等於 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"last[i-1]+1"}]},{"type":"text","value":" 還是等於 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"-1"}]},{"type":"text","value":"。如果是前者，那麼只有一種選擇，如果是後者，那麼根據「分兩半字典序必須比較大」的原則，下一個值必須是從 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"last[i-1]+1"}]},{"type":"text","value":" 對應到的字元"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"的下一個"}]},{"type":"text","value":"往後開始跳。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"#include <iostream>\n#include <vector>\nusing namespace std;\n\nstring s;\nint N, M, K;\nint current[100005] = {-1};\nint a[10];\n\nstring get_string(int len) {\n  string ret = \"\";\n  for (int x = 0; x < len; x++)\n    ret += ('0' + a[current[x]]);\n  return ret;\n}\n\nvoid generate_lyndon_words(int now, int last) {\n  if (now && N%now == 0 && last == -1) {\n    s += get_string(now);\n  }\n\n  if (s.size() >= K+N-1) return;\n  if (now == N) return;\n\n  // 選擇延續 last。\n  if (now > 0) {\n    current[now] = current[last+1];\n    generate_lyndon_words(now+1, last+1);\n  }\n  // 選擇把 last 換成 -1，但是你的字典序要比原本的還要大。\n  for (int x = now? current[last+1]+1 : 0; x < M; x++) {\n    current[now] = x;\n    generate_lyndon_words(now+1, -1);\n  }\n}\n\nint main() {\n  cin >> N >> M >> K;\n  for (int i = 0; i < M; i++) cin >> a[i];\n  generate_lyndon_words(0, -1);\n  while (s.size() < K+N-1) s += s; // 某種邊界條件...\n  s = s.substr(0, K+N-1);\n  cout << s << endl;\n  return 0;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"關於競程日記"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"🍅 如果您想到更多有趣漂亮簡單乾淨的解法話歡迎留言給競程日記小編群！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"ℹ️ 這是一篇投稿給"},{"type":"element","tagName":"a","properties":{"href":"https://www.facebook.com/%E7%AB%B6%E7%A8%8B%E6%97%A5%E8%A8%98-1514973425463954/"},"children":[{"type":"text","value":"競程日記"}]},{"type":"text","value":"的文章，歡迎大家投稿、交流與分享程式解題競賽的點點滴滴！"}]}],"data":{"quirksMode":false}},"frontmatter":{"date":"January 03, 2019","path":"/problem/icpc/asia_jakarta_2018/F","title":"Popping Balloons","description":"Ayu 和 Budi 正在一場類似 ICPC 的比賽上面決鬥。這樣的比賽題目總共有 $N$ 題，然而，參賽者比須按照指定順序依序解題。\n\nAyu 熟知她自己與 Budi 解每一題的能力，因此，Ayu 能夠事先得知兩個陣列 A_{1, \\ldots, N} 以及 $B_{1, \\ldots, N}，其中 $A_i$ 與 $B_i$ 分別表示 Ayu 和 Budi 解出第 $i$ 題所需要的時間。\n\n故事是這樣的，Ayu 知道 Budi 對突然的巨大聲響相當敏感，比方說當氣球爆炸的時刻。一旦 Budi 受到驚嚇，他手邊的工作就會立即停擺，而且當下解的題目必須**重頭開始**解。如果在恰好要解出一題的當下被嚇到，Budi 也得從頭開始才行。\n\nAyu 想利用這點勝過 Budi，她唯一能夠利用的，就是自己解出題目的當下所獲得的氣球。你可以假設 Ayu 一旦解出題目就可以立即獲得氣球，也可以立即戳破氣球（如果 Budi 同時即將解完，可憐的 Budi 就得重頭開始）。請問 Ayu 是否有戳氣球的策略使得在時間 $M$ 結束的當下，Ayu 解出的題數**嚴格大於** Budi 的呢？\n","roadmap_label_h3":null,"backlink":"/icpcblog-weekly-2019"}}},"pageContext":{}}