{"data":{"pages":{"edges":[{"node":{"frontmatter":{"title":"關於競程日記 2019","category":"roadmap","path":"/icpcblog-weekly-2019","date":"2018-12-26","_PARENT":"5b35e544-8f78-5ac3-a045-f8cece05889c","description":null,"link":null,"code":null,"difficulty":null,"oj":null,"tags":null},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"每一週我們會決定一個題組，然後從當中盡量每天挑選一題撰寫題解，並且同步發布於"},{"type":"element","tagName":"a","properties":{"href":"https://www.facebook.com/TaiwanCompetitiveProgrammingBlog/"},"children":[{"type":"text","value":"競程日記FB專頁"}]},{"type":"text","value":"上面。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"(Jan.01 - Jan.07) ICPC 2018 Asia Jakarta Regional"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://codeforces.com/blog/entry/63220"},"children":[{"type":"text","value":"Codeforces 文章連結"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://codeforces.com/gym/102001"},"children":[{"type":"text","value":"Codefroces Gym 題目連結"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://competition.binus.ac.id/icpc2018/final.html"},"children":[{"type":"text","value":"Final Standings"}]},{"type":"text","value":" (點選上面題號可以看到題目 PDF)"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://github.com/jonathanirvings/icpc-jakarta-2018/"},"children":[{"type":"text","value":"測試資料與解答 GitHub @jonathanirvings"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"提供競程日記的參考題解："},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"problem-list-as-tags","properties":{"n":"12","pathPrefix":"/problem/icpc/asia_jakarta_2018"},"children":[]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"(Jan.08 - Jan.14) ICPC 2018 Asia Hanoi Regional"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://open.kattis.com/problem-sources/The%202018%20ICPC%20Asia%20Hanoi%20Regional%20Contest"},"children":[{"type":"text","value":"ProblemSet On Open Kattis"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://hanoi18.kattis.com/standings"},"children":[{"type":"text","value":"Final Standings"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"提供競程日記的參考題解："},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"problem-list-as-tags","properties":{"n":"12","pathPrefix":"/problem/icpc/asia_hanoi_2018"},"children":[]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"(Jan.15 - Jan.21) ICPC 2018 Asia Singapore Regional"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://open.kattis.com/problem-sources/2018%20ICPC%20Asia%20Singapore%20Regional"},"children":[{"type":"text","value":"ProblemSet On Open Kattis"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://asiasg18.kattis.com/standings"},"children":[{"type":"text","value":"Final Standings"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"提供競程日記的參考題解："},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"problem-list-as-tags","properties":{"n":"12","pathPrefix":"/problem/icpc/asia_singapore_2018"},"children":[]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"(TBD) ICPC 2018 Asia Seoul Regional"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"http://icpckorea.org/archives/1774"},"children":[{"type":"text","value":"Local Contest Page"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"http://icpckorea.org/2018/regional/problemset-2018.pdf"},"children":[{"type":"text","value":"Problem Set (PDF)"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"http://icpckorea.org/2018/regional/2018_seoul_testdata.zip"},"children":[{"type":"text","value":"TestData.zip"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"http://icpckorea.org/2018/regional/scoreboard"},"children":[{"type":"text","value":"Final Standing"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"提供競程日記的參考題解："},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"problem-list-as-tags","properties":{"n":"12","pathPrefix":"/problem/icpc/asia_seoul_2018"},"children":[]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"(TBD) ICPC 2018 Asia Nakhon Pathom Regional"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://www.ict.mahidol.ac.th/acmicpc/2018/"},"children":[{"type":"text","value":"Local Contest Page"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"(TBD) ICPC 2018 Yangon Regional"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"http://www.ucsy.edu.mm/ucsy/pages/aryangon2018.jsp"},"children":[{"type":"text","value":"Local Contest Page"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"http://www.ucsy.edu.mm/ucsy/pages/q-aryangon2018.pdf"},"children":[{"type":"text","value":"Problem Set (PDF)"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"(TBD) ICPC 2018 Yokohama Regional"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":""},"children":[{"type":"text","value":"Local Contest Page"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"http://storage.googleapis.com/icpcsec/2018-regional/problems_all.pdf"},"children":[{"type":"text","value":"Problem Set (PDF)"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"http://icpc.iisf.or.jp/past-icpc/regional2018/commentaries-2018.pdf"},"children":[{"type":"text","value":"Solution from Judge (投影片)"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"http://icpc.iisf.or.jp/past-icpc/regional2018/icpcdata2018.tar.gz"},"children":[{"type":"text","value":"Testdata"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"(TBD) ICPC 2018 Taipei Regional"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"台北站到目前為止還沒有釋出題本。"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"Leetcode 刷題指南 v0.1","category":"roadmap","path":"/leetcode-guide","date":"2018-12-21","_PARENT":"7f2afd93-1f83-5c39-b156-2babacdc8d3e","description":null,"link":null,"code":null,"difficulty":null,"oj":null,"tags":null},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這份指南把一些面試經典題型整理出來，給大家參考。\n每一個主題大約是 1 小時的閱讀份量與 3 小時的實作份量。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"一道題目如果給不出三種不盡相同的作法，代表你還沒有參透這個題目，或是這個題目太死板啦。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"卡恩 (2018.12)"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"鏈結串列 Linked Lists"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"mylink","properties":{"to":"/leetcode-guide/linked-lists"},"children":[{"type":"text","value":"鏈結串列的大致分類 Type of Linked Lists"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"練習題"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"陣列 Arrays"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"排序方法 Sorting Algorithms"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"單調性與兩個指標 Two Pointers"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"樹 Trees"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"堆疊與深度優先搜索 Stack and Depth First Search"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"佇列與廣度優先搜索 Queue and Breadth First Search"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"雜湊表 Hash Tables"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"優先序佇列與堆積 Priority Queues and Heaps"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"圖 Graphs"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"動態規劃：序列 Dynamic Programming on Sequences"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"動態規劃：字串 Dynamic Programming on Strings"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"機率與隨機數 Probabilities"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"搜尋樹 Search Trees"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"字母樹 Tries"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"計算幾何 Computational Geometry"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"數論 Number Theory"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"物件導向程式設計 OOP"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"熟悉你的程式語言：C++"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"熟悉你的程式語言：Python"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"熟悉你的程式語言：Javascript"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"演算法中的四種解題思維","category":"algo","path":"/algo/algorithmic-thinking","date":"2018-11-27","_PARENT":"4a56ef36-1df5-56f6-b0bf-74d9f0d9ee3f","description":null,"link":null,"code":null,"difficulty":null,"oj":null,"tags":null},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%80%9D%E7%BB%B4"},"children":[{"type":"text","value":"運算思維"}]},{"type":"text","value":"（Computational Thinking）在近年來逐漸被關注資訊教育的人們提出來討論。而運算思維包含了"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"問題解構"}]},{"type":"text","value":"（Decomposition）、"},{"type":"element","tagName":"a","properties":{"href":"http://terms.naer.edu.tw/detail/1603992/"},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"型樣辨識"}]}]},{"type":"text","value":"（Pattern Recognition）、"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"模型抽象化"}]},{"type":"text","value":"（Abstraction）以及"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"演算法設計"}]},{"type":"text","value":"（Algorithm Design）。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"對我來說，演算法設計的世界裡面，解題的過程也可以大致分類成以下四種思考方式。而這些思考方式構建了大家在演算法教科書中提及的各種解題方法（又稱為 "},{"type":"element","tagName":"a","properties":{"href":"https://en.wikipedia.org/wiki/Algorithmic_paradigm"},"children":[{"type":"text","value":"Algorithmic Paradigm"}]},{"type":"text","value":"），比方說動態規劃或是分而治之等。大致可以表示成以下的圖片："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{"className":["has-text-centered"]},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"img","properties":{"src":"/algthinking-3a46181cc32653fb172ffd3d39e23591.png","style":"max-width:700px"},"children":[]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"枚舉 Enumeration"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"程式解題與數學解題其中一個不同之處，在於我們擁有運算資源，可以把複雜的、難以公式化的數學結論，用跑程式的方式輕鬆驗證。枚舉（Enumeration）就是其中一種很「資訊科學」的解題方式：如果我能夠證明我的答案在某個特定的範圍中，那麼我只要逐一考慮過所有可能的答案即可。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"簡而言之，若一道題目滿足以下兩個性質："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"若給定一個解 X，我們可以有效率地檢驗 X 是否正確。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"把可能的解所在的範圍，縮小到足以負擔的數量級。\n那麼通常我們可以寫出好寫又有效率的程式。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"迭代 Iteration"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"迭代法，通常是用於我們可以逐漸找出答案的演算法。最常見的應用是漸進演算法、數值方法、人工智慧等。在競賽之中，我們也可以利用迭代的概念，有效率地得出我們想要的解。最直白的應用就是 for 迴圈。對，還有 while 迴圈。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"遞推 Induction"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"在驗證程式邏輯的正確性的時候，我們很常會使用數學歸納法：「如果小測資是對的，那麼根據我們解題的思路，也可以推得大測資是對的。」P老師也曾經說過：「歸納」、「遞迴」跟「分而治之」其實是一體三面，對於有效率地寫程式解決問題是相當重要的。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"轉化 Reduction"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"轉化跟歸納其實是兩個不同的方向：如果說歸納是以建構的方式，由小範圍的測資組合出大範圍測資的答案，那麼轉化有點像是平行地把一個問題轉變成另一個已知解法問題。轉化在解題思維中無所不在，畢竟大家在面對一道新的題目時，總是會習慣搜尋自己曾經解決過的類似題目、並且利用以前的經驗，把思路稍作修改從而獲得真正的解法。"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"測試文章","category":"algo","path":"/hello-world","date":"2018-11-09","_PARENT":"192a55e1-4ef0-5d9d-be9c-3ceb8fe80ce8","description":null,"link":null,"code":null,"difficulty":null,"oj":null,"tags":null},"htmlAst":{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"This is a test"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"$f(x) = x^2$"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"額外的測試嗎XD"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這樣就可以一邊寫文章一邊寫數學式子了！"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"$ax+by=\\frac{z^2}{y} what$"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"程式碼"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"test"}]}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"test123 \n"}]}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"#include <cstdio>\nusing namespace std;\n\nint main(void) {\n    // 中文也可以\n    printf(\"Hello! World!\\n\");\n    return 0;\n}\n"}]}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"My Algorithm Displayer"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"1. Static Data Display."}]},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"display","properties":{"array":"","data":"[1, 2, \"test123\\n456\"]"},"children":[]}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-html"]},"children":[{"type":"text","value":"<display array\n    data='[1, 2, \"test123\\n456\"]'></display>\n"}]}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"2. A simple looping algorithm."}]},{"type":"element","tagName":"algorithm","properties":{},"children":[{"type":"text","value":"\n    "},{"type":"element","tagName":"generator","properties":{},"children":[{"type":"element","tagName":"pre","properties":{},"children":[{"type":"text","value":"\n        function*(input, ui) {\n            var n = input.n;\n            var i;\n            var s = [];\n            for (i = 0; i < n; i++) {\n                s.push(i);\n                ui.setStyleOnce('arr', `${i}`, {fill: 'yellow'});\n                yield {arr: s};\n            }\n            return {arr: s};\n        }\n        "}]},{"type":"text","value":"\n    "}]},{"type":"text","value":"\n    "},{"type":"element","tagName":"inputdata","properties":{"data":"{\"n\": 10}"},"children":[]},{"type":"text","value":"\n    "},{"type":"element","tagName":"indirectdisplay","properties":{"array":"","n":"10","fixedwidth":"","highlightdiff":"","varname":"arr"},"children":[]},{"type":"text","value":"\n"}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-html"]},"children":[{"type":"text","value":"<algorithm>\n    <generator><pre>\n"}]}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-javascript"]},"children":[{"type":"text","value":"        function*(input, ui) {\n            var n = input.n;\n            var i;\n            var s = [];\n            for (i = 0; i < n; i++) {\n                s.push(i);\n                ui.setStyleOnce('arr', `${i}`, {fill: 'yellow'});\n                yield {arr: s};\n            }\n            return {arr: s};\n        }\n"}]}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-html"]},"children":[{"type":"text","value":"        </pre>\n    </generator>\n    <inputdata\n        data='{\"n\": 10}'\n    ></inputdata>\n    <indirectdisplay\n        array\n        n='10'\n        fixedwidth\n        highlightdiff\n        varname='arr'\n    ></indirectdisplay>\n</algorithm>\n"}]}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"3. A simple grid."}]},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"display","properties":{"grid":"","data":"[\"...#.#\",\"..###.\",\"#...#.\"]"},"children":[]}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-html"]},"children":[{"type":"text","value":"<display grid\n    data='[\"...#.#\",\"..###.\",\"#...#.\"]'\n    ></display>\n"}]}]},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"display","properties":{"grid":"","notext":"","uistore":"{\n        styleRules: {\n            ruleZZ: {\n                apply_to: 'node',\n                pure_predicate_fn: (nodeProps) => { return nodeProps.content === '#'; },\n                options: { fill: 'black' },\n            }\n        }\n    }","data":"[\"...#.#\",\"..###.\",\"#...#.\"]"},"children":[]}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-html"]},"children":[{"type":"text","value":"<display grid\n    notext\n    uistore=\"{\n        styleRules: {\n            ruleZZ: {\n                apply_to: 'node',\n                pure_predicate_fn: (nodeProps) => { return nodeProps.content === '#'; },\n                options: { fill: 'black' },\n            }\n        }\n    }\"\n    data='[\"...#.#\",\"..###.\",\"#...#.\"]'\n    ></display>\n"}]}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"4. Random walk on a grid."}]},{"type":"element","tagName":"algorithm","properties":{},"children":[{"type":"text","value":"\n    "},{"type":"element","tagName":"generator","properties":{},"children":[{"type":"element","tagName":"pre","properties":{},"children":[{"type":"text","value":"\n        function*(input, ui) {\n            var n = input.n;\n            var s = [];\n            var i, j;\n            var x = Math.floor(Math.random()*n);\n            var y = Math.floor(Math.random()*n);\n            for (i = 0; i < n; i++) {\n                var t = [];\n                for (j = 0; j < n; j++) {\n                    if (Math.floor(Math.random()*10) !== 0)\n                        t.push('.');\n                    else\n                        t.push('#');\n                }\n                s.push(t);\n            }\n            s[x][y] = '*';\n            ui.setStyle('arr', JSON.stringify([x, y]), {fill: '#FFEE33'});\n            ui.setStyleOnce('arr', JSON.stringify([x, y]), {fill: 'blue'});\n            yield { arr: s };\n            //\n            while (true) {\n                var d = Math.floor(Math.random()*4);\n                if (d === 0 && x+1 < n && s[x+1][y] === '.') {\n                    s[x][y] = '.'\n                    s[x+1][y] = '*'\n                    x += 1\n                } else if (d === 1 && x > 0 && s[x-1][y] === '.') {\n                    s[x][y] = '.'\n                    s[x-1][y] = '*'\n                    x -= 1\n                } else if (d === 2 && y+1 < n && s[x][y+1] === '.') {\n                    s[x][y] = '.'\n                    s[x][y+1] = '*'\n                    y += 1\n                } else if (d === 3 && y > 0 && s[x][y-1] === '.') {\n                    s[x][y] = '.'\n                    s[x][y-1] = '*'\n                    y -= 1\n                }\n                ui.setStyle('arr', JSON.stringify([x, y]), {fill: '#FFEE33'});\n                ui.setStyleOnce('arr', JSON.stringify([x, y]), {fill: 'blue'});\n                yield { arr: s };\n            }\n        }\n        "}]},{"type":"text","value":"\n    "}]},{"type":"text","value":"\n    "},{"type":"element","tagName":"inputdata","properties":{"data":"{\"n\": 10}"},"children":[]},{"type":"text","value":"\n    "},{"type":"element","tagName":"indirectdisplay","properties":{"grid":"","uistore":"{\n            styleRules: {\n                ruleZZ: {\n                    apply_to: 'node',\n                    pure_predicate_fn: (nodeProps) => { return nodeProps.content === '#'; },\n                    options: { fill: 'black', fontColor: 'white' },\n                }\n            }\n        }","varname":"arr"},"children":[]},{"type":"text","value":"\n"}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-javascript"]},"children":[{"type":"text","value":"function*(input, ui) {\n            var n = input.n;\n            var s = [];\n            var i, j;\n            var x = Math.floor(Math.random()*n);\n            var y = Math.floor(Math.random()*n);\n            for (i = 0; i < n; i++) {\n                var t = [];\n                for (j = 0; j < n; j++) {\n                    if (Math.floor(Math.random()*10) !== 0)\n                        t.push('.');\n                    else\n                        t.push('#');\n                }\n                s.push(t);\n            }\n            s[x][y] = '*';\n            ui.setStyle('arr', JSON.stringify([x, y]), {fill: '#FFEE33'});\n            ui.setStyleOnce('arr', JSON.stringify([x, y]), {fill: 'blue'});\n            yield { arr: s };\n            //\n            while (true) {\n                var d = Math.floor(Math.random()*4);\n                if (d === 0 && x+1 < n && s[x+1][y] === '.') {\n                    s[x][y] = '.'\n                    s[x+1][y] = '*'\n                    x += 1\n                } else if (d === 1 && x > 0 && s[x-1][y] === '.') {\n                    s[x][y] = '.'\n                    s[x-1][y] = '*'\n                    x -= 1\n                } else if (d === 2 && y+1 < n && s[x][y+1] === '.') {\n                    s[x][y] = '.'\n                    s[x][y+1] = '*'\n                    y += 1\n                } else if (d === 3 && y > 0 && s[x][y-1] === '.') {\n                    s[x][y] = '.'\n                    s[x][y-1] = '*'\n                    y -= 1\n                }\n                ui.setStyle('arr', JSON.stringify([x, y]), {fill: '#FFEE33'});\n                ui.setStyleOnce('arr', JSON.stringify([x, y]), {fill: 'blue'});\n                yield { arr: s };\n            }\n        }\n"}]}]}]}}},{"node":{"frontmatter":{"title":"枚舉法 2：利用相依性 Dependency [草稿]","category":"algo","path":"/algo/enumeration-2","date":"2018-12-16","_PARENT":"55979fb4-d07b-5c3d-b406-1411f1dfde6b","description":null,"link":null,"code":null,"difficulty":null,"oj":null,"tags":null},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"在考慮枚舉所有可行解的同時，若變數與變數之間有高度的相關性，那麼枚舉的順序就會變得相當重要。若我們用了錯誤的順序進行枚舉，很可能會浪費許多時間考慮根本不符合題目規定的解。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"include-problem","properties":{"titlePrefix":"例題 1：","path":"/problem/cf/161/E"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"因為 $p_i\\le 99999$ 因此密碼鎖的大小至多只有 $5\\times 5$。再加上對稱的關係，因此彼此不相關的格子只有對角線右上方的這 15 格："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"/CF161E-f6172dc8bf334e699603ab7606576a42.png"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"但是，因為第一排已經固定了 $p_i$，所以剩下下面的 10 格。注意到，如果我們枚舉了標記數字 1 到 6 的地方，則每一排恰好空下一個對角線上的格子，而且彼此不相關。我們只要解決：有多少質數滿足 $\\overline{aXbcd}$ 的形式，其中 $a,b,c,d$ 已知。而這一步可以預處理後 $O(1)$ 查詢。因此利用枚舉法的計算量約在 $10^6$，相當合理。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"// by tmt514\n#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// cnt[第k個位數被丟掉了][其他數字是多少] = 有幾個質數。\nint cnt[5][100000];\n\nvoid pre_compute() {\n  // 先用篩法求質數。\n  vector<int> sieved(99999, 0);\n  for (int i = 2; i*i <= 99999; i++)\n    for (int j = i*i; j <= 99999; j += i)\n      sieved[j] = 1;\n  // 對於找到的每一個質數，我們考慮中間每一個位數被挖空以後，剩下的數字，把他加進去。\n  for (int p = 2; p <= 99999; p++)\n    if (sieved[p] == 0)\n      for (int ten = 1, k = 0; ten <= 10000; ten *= 10, k++)\n        cnt[k][ p/(ten*10)*ten + p%ten ]++;\n}\n\nint ans, n;\nint a[6][6];\nint get_count(int x) {\n  int prefix = 0;\n  for (int i = 0; i < n; i++)\n    if (i != x)\n      prefix = prefix*10 + a[x][i];\n  return cnt[n-1-x][prefix];\n}\nvoid dfs(int x, int y, int total) {\n  if (x == n) {\n    ans += total;\n    return;\n  }\n  if (y == n) {\n    dfs(x+1, 0, total * get_count(x));\n    return;\n  }\n\n  if (x >= y) {\n    a[x][y] = a[y][x];\n    dfs(x, y+1, total);\n  } else {\n    for (int i = 0; i <= 9; i++) {\n      a[x][y] = i;\n      dfs(x, y+1, total);\n    }\n  }\n}\n\nvoid solve() {\n  string s;\n  cin >> s;\n  n = s.size();\n  for (int i = 0; i < n; i++) a[0][i] = (s[i]-'0');\n  ans = 0;\n  dfs(1, 0, 1);\n  cout << ans << endl;\n}\n\nint main() {\n  int T;\n  pre_compute();\n  cin >> T;\n  while (T--) solve();\n  return 0;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"結論"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"先枚舉一部分的數值，並試圖留下一些完全不互相影響的待枚舉部分。如此一來，每一個獨立的部分可以各自用預處理的技巧快速找出答案。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"include-problem","properties":{"titlePrefix":"例題 2：","path":"/problem/cf/217/B"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"在第一個例題中，我們試圖降低未枚舉的格子之間的依賴關係。而在第二個例題中，我們試圖找出下一個要枚舉的操作與目前已枚舉部分的關聯，是為增加依賴關係。兩種方法的目的都是為了保證枚舉所花的時間大致與枚舉出的結果總數成正比，減少浪費的時間。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"練習題"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"二分搜尋法的應用 1：答案仍在範圍裡","category":"algo","path":"/algo/binary-search-applications","date":"2018-11-14","_PARENT":"3d839906-7ed2-50ad-9428-1b2246a93759","description":null,"link":null,"code":null,"difficulty":null,"oj":null,"tags":null},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"前一篇文章 "},{"type":"element","tagName":"a","properties":{"href":"/algo/binary-search"},"children":[{"type":"text","value":"二分搜尋法的實作基礎"}]},{"type":"text","value":" 提及了關於二分搜的核心概念：每一次迭代都排除了一些不可能是答案的值。我們今天來看看二分搜尋法有哪些應用吧！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"勘根定理"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"對於一個連續函數 $f$，如果這個函數在 $[a, b]\\subseteq \\mathbb{R}$ 區間內有定義，而且 $f(a) < 0$、$f(b) > 0$，那麼"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"勘根定理"}]},{"type":"text","value":"告訴我們說，中間必定存在一個 $x\\in [a, b]$ 使得 $f(x)=0$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"上面這個定理只告訴我們存在"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"至少"}]},{"type":"text","value":"一個根，但其實它的證明就是利用二分搜尋法的概念！而且是反方向的概念："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"article","properties":{"className":["message","is-success"]},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{"className":["message-body"]},"children":[{"type":"text","value":"\n每一次迭代都保證了答案仍在剩下的值裡面。\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"考慮無窮序列 $\\{a_i\\}$ 以及 $\\{b_i\\}$。他們的定義如下：$a_0=a$ 且 $b_0=b$。接著我們依序定義，對所有正整數 $i$，令 $m_i = (a_{i-1}+b_{i-1})/2$，若 $f(m_i) = 0$，則我們找到了 $x=m_i$。否則的話，我們根據 $f(m_i)$ 之值定義新的一組 $(a_i, b_i)$："}]},{"type":"text","value":"\n$$\n(a_i, b_i) = \\begin{cases}\n(a_{i-1}, m_i) &\\text{ if } f(m_i) > 0,\\\\\n(m_i, b_{i-1}) &\\text{ if } f(m_i) < 0.\n\\end{cases}\n$$\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"二分在哪裡呢？我們可以發現每一次迭代，區間 $[a_i, b_i]$ 長度是前一次迭代的 $[a_{i-1}, b_{i-1}]$ 的一半！由於 $\\{a_i\\}$ 是遞增有上界、$\\{b_i\\}$ 遞減有下界、他們彼此之間距離又會趨近於 $0$，因此最終 $\\lim_{i\\to\\infty} a_i = x^* = \\lim_{i\\to\\infty} b_i$。由"},{"type":"element","tagName":"a","properties":{"href":"https://zh.wikipedia.org/wiki/%E5%A4%BE%E6%93%A0%E5%AE%9A%E7%90%86"},"children":[{"type":"text","value":"夾擠定理"}]},{"type":"text","value":"可得知 $f(x^*)=0$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"找出陣列中的極小點"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"給定一個陣列 $A[0..n-1]$，這個陣列的所有數字都不相同。假設這個陣列最左邊和最右邊的邊界都是無窮大，也就是 $A[-1]=A[n]=\\infty$。請找出任何一個"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"極小點"}]},{"type":"text","value":"的索引 $i$：滿足 $A[i-1] > A[i] < A[i+1]$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"找出任一個括弧組"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"給定一個僅包含小括弧 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"("}]},{"type":"text","value":" 或 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":")"}]},{"type":"text","value":" 的字串 $S$，已知字串左界是個左括弧 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"("}]},{"type":"text","value":"、右界是個右括弧 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":")"}]},{"type":"text","value":"。請設計一個演算法有效率地找出一個連續的一對括弧 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"()"}]},{"type":"text","value":" 子字串。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"參考資料"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"http://kc.kshs.kh.edu.tw/93kc/projectual/math9103/chp4-5/4-5-8.htm"},"children":[{"type":"text","value":"勘根定理 The location of roots theorem"}]}]},{"type":"text","value":"\n"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"枚舉法 1：試誤原則 Trial and Error","category":"algo","path":"/algo/enumeration-1","date":"2018-12-05","_PARENT":"9a9d9756-b822-5c33-9312-16d671c507ca","description":null,"link":null,"code":null,"difficulty":null,"oj":null,"tags":null},"htmlAst":{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"今天來聊聊四種解題方法之一：枚舉法。每一道題目都有一個解，當我們沒辦法立刻說出答案的時候，最原始的方法就是利用試誤(trial-error)的原則，考慮所有可能的答案，並一個一個判斷是否它滿足我們的需求。有時候這方法挺好用的。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"資訊與數學最大的不同是，我們可以利用有限的時間，讓電腦幫我們逐一檢驗可能的答案，進而省略一些繁雜的數學證明或更細緻的檢驗步驟。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"換句話說，如果我們能用"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"簡單的數學證明"}]},{"type":"text","value":"保證答案會出現在我們提出的許多數值之中，那麼就能夠證明演算法的正確性了。"}]},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"include-problem","properties":{"titlePrefix":"例題 1：","path":"/problem/isprime"},"children":[{"type":"text","value":"\n"}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"顯然，要「否定」$n$ 是否為質數這個敘述，只需要找出一個「反例」。而顯然這個反例 $x$ 會介於 $[2, n-1]$ 之間。逐一檢查 $2, 3, \\ldots, n-1$ 就可以知道答案是 Yes 還是 No 了。這個方法需要 $O(n)$ 次模運算。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"透過簡單觀察，我們發現：若 $n$ 是合數，可以表示成 $n=a\\times b$。那麼此時有 $\\min(a, b)\\le \\sqrt{n}$。也就是說，若存在反例，最小的反例一定會出現在 $[2, \\sqrt{n}]$ 之間。於是，我們就得到一個 $O(\\sqrt{n})$ 時間的演算法了。"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"bool isprime(int n) {\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0)\n            return false;\n    }\n    return true;\n}\n"}]}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"結論"}]},{"type":"element","tagName":"theorem","properties":{"c":"is-success"},"children":[{"type":"text","value":"\n本題透過枚舉「至少一個」 $n$ 可能的真因數，進而達到解題的目的。\n"}]},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"include-problem","properties":{"titlePrefix":"例題 2：","path":"/problem/leetcode/326"},"children":[]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"注意到 3 的次方其實數量不多，所以我們可以直接嘗試所有可能的次方數值，並且與 $x$ 進行比對。"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"bool isPowerOfThree(int n) {\n    for (long long i = 1; i <= n; i *= 3)\n        if (n == i)\n            return true;\n    return false;\n}\n"}]}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"結論"}]},{"type":"element","tagName":"theorem","properties":{"c":"is-success"},"children":[{"type":"text","value":"\n本題透過枚舉所有 3 的次方值，達到解題目的。\n"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"延伸思考"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這題其實不使用諸如 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"log()"}]},{"type":"text","value":" 函式的浮點數計算也可以做得到 $O(1)$ 時間唷，你能想得到嗎？"}]},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"include-problem","properties":{"titlePrefix":"例題 3：","path":"/problem/cf/233/B"},"children":[{"type":"text","value":"\n"}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"對於一個一元二次方程我們可以利用已知的公式 $x=\\frac{-b\\pm\\sqrt{b^2-4ac}}{2a}$ 來求出方程的根，但是 $s(x)$ 是一個與 $x$ 有關的函數，所以無法直接從公式下手。枚舉 $x$ 的範圍可以粗估是 $1\\le x\\le \\sqrt{n} \\approx 10^9$，但一個一個檢查會花太多時間。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"注意到 $s(x)$ 是 $x$ 的各位數字和，這個值的範圍相較於 $n$ 小了不少。可以估計的是當 $x\\le 10^{9}$ 時，有 $1\\le s(x)\\le 81$。因此若我們先"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"逐一枚舉 $s(x)$ 的值"}]},{"type":"text","value":"，就可以把題目當成一般的一元二次方程來解了！找到解以後，再驗證其各位數字和是否就是我們枚舉的值，就可以了。"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"#include <iostream>\n#include <cmath>\nusing namespace std;\n\n// 計算各位數字和。\nint s(long long x) {\n    int t=0;\n    while(x>0) { t+=x%10; x/=10; }\n    return t;\n}\n\n// 對於枚舉的 s(x) 值 t，找出合法的解，由於解會是一正一負，我們只回傳正的那個。\nlong long getsol(int t, long long n) {\n    long long r = t*t+n*4, v = 0;\n    v = sqrt(r);\n    while(v*v<r) v++; while(v*v>r) v--;\n    if(v*v!=r) return -1;\n    v-=t; if(v%2 || v<0) return -1;\n    v/=2;\n    return v;\n}\n\nint main(void) {\n    long long n, x, t, ans=-1;\n    cin >> n;\n    for (t = 1; t <= 81; t++) {\n        x = getsol(t, n);\n        if(x<0) continue;\n        if(s(x)==t && ( ans==-1 || ans > x)) ans = x;\n    }\n    cout << ans << endl;\n    return 0;\n}\n"}]}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"結論"}]},{"type":"element","tagName":"theorem","properties":{"c":"is-success"},"children":[{"type":"text","value":"\n本題透過觀察並枚舉 $s(x)$ 的值，來縮小可能的答案範圍。\n"}]},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"練習題"}]},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"include-problem","properties":{"path":"/problem/ural/1854","inline":""},"children":[]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"include-problem","properties":{"path":"/problem/cf/911/C","inline":""},"children":[]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"include-problem","properties":{"path":"/problem/cf/241/C","inline":""},"children":[]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"include-problem","properties":{"path":"/problem/icpc/ecna2018/B","inline":""},"children":[]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]}]}}},{"node":{"frontmatter":{"title":"最小費用流的最短路徑增廣法 [草稿]","category":"algo","path":"/algo/min-cost-max-flow-successive-shortest-path","date":"2018-11-22","_PARENT":"f87bfdb6-508e-52a6-b79f-a0ef73b2a3c3","description":null,"link":null,"code":null,"difficulty":null,"oj":null,"tags":null},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"讓我們首先"},{"type":"element","tagName":"a","properties":{"href":"/algo/min-cost-max-flow"},"children":[{"type":"text","value":"回顧"}]},{"type":"text","value":"一下最小費用循環的線性規劃主模型（Primal Problem）、以及其對偶模型（Dual Problem）。令 $f(u, v)$ 為線性規劃模型的變數、$y(u, v)$ 以及 $d(v)$ 為其對偶模型的變數名。我們定義以下三種條件："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"P 條件：$f$ 滿足線性規劃模型的條件，即 $f$ 是一個合法的網路流。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"D 條件：$y, d$ 滿足對偶模型的條件，即 $y(u, v)-d(u)+d(v) \\le cost(u, v)$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"CS 條件：$f, y, d$ 滿足"},{"type":"element","tagName":"a","properties":{"href":"http://terms.naer.edu.tw/detail/559045/"},"children":[{"type":"text","value":"互補差餘"}]},{"type":"text","value":"條件，即"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n$$\n\\begin{cases}\nf(u, v) > 0 & \\implies y(u, v) = d(u) + cost(u, v) - d(v)\\\\\nf(u, v) < cap(u, v) & \\implies y(u, v) = 0\n\\end{cases}\n$$\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"由線性規劃的各種性質我們可以知道，只要 $f, y, d$ 這三組變數同時滿足 P條件、D條件以及 CS條件的話，保證 $f, y, d$ 分別是主模型和對偶模型的最佳解。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"theorem","properties":{"title":"最小費用流的最佳條件定理"},"children":[{"type":"text","value":"設 $f$ 是一個圖 $G$ 上面的網路流。若存在剩餘網路 $G_f$ 上面的距離函數 $d^*$ （即，滿足 $\\forall (u, v)\\in G_f, \\ d^*(u) + cost(u, v) \\ge d^*(v)$），那麼 $f$ 是主模型的最佳解。\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"證明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我們只需要證明「存在滿足條件的 $d^*$ 函數」等價於「存在滿足 D 條件和 CS 條件的 $y, d$」即可。"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"二分搜尋法的實作基礎","category":"algo","path":"/algo/binary-search","date":"2018-11-13","_PARENT":"9c22712b-826d-5476-b761-6245a830bbcc","description":null,"link":null,"code":null,"difficulty":null,"oj":null,"tags":null},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"前幾天有位朋友跟我反應，二分搜尋法好難寫啊。有的時候寫下去，甚至無法確定這樣寫會不會對，只能祈禱線上提交的時候會順利拿到 "},{"type":"element","tagName":"span","properties":{"style":"color:green"},"children":[{"type":"element","tagName":"b","properties":{},"children":[{"type":"text","value":"Accepted"}]}]},{"type":"text","value":"。這樣的想法是很危險的！你不應該仰賴評測系統給你的反饋，才能知道自己是不是對的。至少在上傳之前，思考一下正確性，讓自己更安心。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"先說結論"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"在繼續介紹各種二分搜的方法與證明之前，我想要先下個結論：每個人都應該要有一套屬於自己的二分搜尋法。而且 "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"只用"}]},{"type":"text","value":" 這套屬於自己的二分搜尋法。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"二分搜的概念"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"假想你有一個只有 0 和 1 兩種數字的陣列，然後所有的 0 都排在 1 的前面。 "}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"display","properties":{"array":"","fixedwidth":"","data":"[0, 0, 0, 0, 1, 1, 1, 1, 1, 1]"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"要如何找出第一個 1 的位置呢？想法很單純，我們戳一個中間的格子，如果這個格子是 0，代表「所有這個格子之前（包含這個格子）都不是答案」。如果這個格子是 1，則代表「所有這個格子之後（"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"不"}]},{"type":"text","value":"包含這個格子）也不是答案」。於是我們得到一個演算法："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"1. 戳一個中間的格子 X\n2. 如果 X = 1，那麼把這個格子右邊的所有格子丟掉\n3. 如果 X = 0，那麼把這個格子本身與其左邊所有格子丟掉\n4. 重複以上操作\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這個演算法什麼時候會停？它不會停，因為從上面的演算法描述，我們並沒有叫他停下來。那什麼時候應該要停下來？顯然每一次操作的過程中，左邊丟掉的格子們都是 0、右邊丟掉的格子們都是 1。我們可以把這個觀察寫成重要的"},{"type":"element","tagName":"a","properties":{"href":"https://en.wikipedia.org/wiki/Loop_invariant"},"children":[{"type":"text","value":"迴圈不變量"}]},{"type":"text","value":"。在迴圈結束後，如果只剩下一個格子，而這個格子是 1，那麼根據演算法來說我們永遠不會把這個格子丟掉。而根據迴圈不變量，我們就保證了這格就是我們要的第一個 1。反之，如果這個格子裡面的數字是 0，那麼根據演算法，下一步這格就會被丟掉，而我們也可以推斷出「這陣列不存在 1」。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"二分搜的實作"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"但是實際寫成程式碼就很怪了啊。到底我們要怎麼表示目前的邊界（或是紀錄被丟掉的格子）呢？因為剩餘的格子們是連續的一段，我們可以利用兩個變數 $\\ell$ 和 $r$ 來表示這個區間 $[\\ell, r]$。有些人喜歡半開半閉區間 $[\\ell, r)$，也就是說當我們存入兩個變數 $\\ell$ 和 $r$ 的時候，實際有效的陣列範圍是 $[\\ell, r-1]$。那樣寫沒什麼壞處，而且也巧妙地利用了當 $l+r$ 是奇數時 $(l+r)/2$ 向下取整的特性，讓中間值 $m$ 可以留在 $[\\ell, r-1]$ 這個區間裡面。不過我自己的習慣是使用閉區間。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"我自己的習慣"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我的寫法是閉區間的寫法，而且總是維護當前找到的"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"答案候選"}]},{"type":"text","value":"。引入一個變數 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"ans"}]},{"type":"text","value":"，一開始把它標記為「不存在」，如果我找到一個滿足條件的格子（比方說，這個格子必須是 1）那麼在找到的當下，我會更新 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"ans"}]},{"type":"text","value":" 的值。讓變數 $\\ell, r$ 永遠只用來表達邊界，不要賦予他們過多的意義。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"int lower_bound(int array[], auto predicate_fn) {\n    int l, r, ans = -1;\n    while(l <= r) {\n        int m = (l + r) / 2;\n        if (predicate_fn(array[m]) == true) {\n            // 如果滿足條件，就把右邊丟掉，並且把當前資料加入可能的答案裡。\n            ans = m;\n            r = m - 1;\n        } else {\n            // 如果不滿足條件，就把左邊丟掉。\n            l = m + 1;\n        }\n    }\n    return ans;\n}\n"}]}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"A+B Problem","category":"cp","path":"/cp/a-plus-b","date":"2018-11-14","_PARENT":"82b59ce0-6f12-5e4f-8918-3c55f9d738e6","description":"給定兩個整數 $A$ 以及 $B$，請輸出 $A+B$ 之值。\n","link":"https://oj.icpc.tw/problem/1","code":null,"difficulty":null,"oj":null,"tags":null},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"題目敘述"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ連結"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://oj.icpc.tw/problem/1"},"children":[{"type":"text","value":"競程日記 Problem 1. A+B Problem"}]}]},{"type":"text","value":"\n"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"判斷質數","category":"prob","path":"/problem/isprime","date":null,"_PARENT":"360b3e2f-13a8-57d2-9e82-34cfa2090568","description":"若一個正整數恰有兩個正因數，那我們稱它是一個質數。給定正整數 $n$，請判斷 $n$ 是否為質數。\n","link":null,"code":"ISPRIME","difficulty":null,"oj":null,"tags":null},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"最小費用流 Min-Cost Max-Flow","category":"algo","path":"/algo/min-cost-max-flow","date":"2018-11-16","_PARENT":"efd6f89a-55c8-547e-9aae-3885ac0ebc91","description":null,"link":null,"code":null,"difficulty":null,"oj":null,"tags":null},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這篇文章是線性規劃章節的延伸，但目前還沒有寫線性規劃相關文章。還請大家先行理解"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"線性規劃"}]},{"type":"text","value":"與"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"對偶性質"}]},{"type":"text","value":"XD"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"最小費用流 Min-Cost Max-Flow"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{"className":["message","is-info"]},"children":[{"type":"element","tagName":"div","properties":{"className":["message-body"]},"children":[{"type":"text","value":"\n給定一個圖 $G=(V, E, cap: E\\to \\mathbb{R}_{\\ge 0}, cost: E\\to \\mathbb{R})$，每一條邊都有一個流量上限 $cap$ 和單位流量花費 $cost$。試問，從 $s$ 到 $t$ 的所有最大流之中，最小的花費為何？\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這個問題由於有 $s$ 和 $t$ 兩個特殊點，實際處理起來可能稍微麻煩些，所以我們先把它轉化成最小費用循環問題（Min-Cost Circulation）。轉化方法很簡單，其實只是加一條額外的邊 $t\\to s$，容量為無窮大、單位流費用為一個負很大的數字 $-\\mathit{big}$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"最小費用循環 Min-Cost Circulation"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{"className":["message","is-info"]},"children":[{"type":"element","tagName":"div","properties":{"className":["message-body"]},"children":[{"type":"text","value":"\n給定一個圖 $G=(V, E, cap: E\\to \\mathbb{R}_{\\ge 0}, cost: E\\to \\mathbb{R})$，每一條邊都有一個流量上限 $cap$ 和單位流量花費 $cost$。找一個 Circulation（沒有起點和終點的網路流） 使得總花費最小。\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果所有的花費都是正的，顯然一個空的流（總花費是 0）是最佳解。如果我們把這個問題的條件寫成線性規劃的形式，令 $f(u, v)$ 表示該條邊上面的流量，那麼它會長得像這樣："}]},{"type":"text","value":"\n$$\n\\begin{align*}\n\\text{minimize}\\ \\ & \\sum f(u, v) \\cdot cost(u, v)\\\\\n\\text{subject to}\\ \\ & {\\color{green}{\\forall (u, v),\\ \\ f(u, v) \\le cap(u, v)}} & {\\color{green}{\\text{ (容量限制)}}}\\\\\n& {\\color{brown}{\\forall v\\in V, \\ \\ \\sum_u f(u, v) - \\sum_u f(v, u) = 0}} & {\\color{brown}{\\text{ (流量守恆)}}}\\\\\n\\text{variables}\\ \\ & f(u, v) \\ge 0\n\\end{align*}\\\\\n$$\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果我們試圖找出他的對偶問題，那麼每一個條件會變成對偶問題的變數、而每一個變數也會對應到對偶問題的一個條件：對於每一個容量限制，我們用 $y(u, v)$ 作為容量限制條件的對應變數、令 $d(v)$ 作為流量守恆條件的對應變數。"}]},{"type":"text","value":"\n$$\n\\begin{align*}\n\\text{maximize}\\ \\ & \\sum {\\color{green}{y(u, v)}} \\cdot cap(u, v)\\\\\n\\text{subject to}\\ \\ & \\forall (u, v), \\ \\ {\\color{green}{y(u, v)}} - {\\color{brown}{d(u)}} + {\\color{brown}{d(v)}} \\le cost(u, v)\\\\\n\\text{variables}\\ \\ & {\\color{green}{y(u, v)}} \\le 0\n\\end{align*}\\\\\n$$\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"由於 ${\\color{green}{y(u, v)}}$ 值永遠非正的，而每一個值又只會出現在恰好一個對偶條件裡面，外加上 $cap(u, v) \\ge 0$。我們可以知道，當 ${\\color{brown}{d(v)}}$ 的所有值固定以後，永遠可以找到一組 ${\\color{green}{y(u, v)}}$ 滿足對偶條件：只要令"}]},{"type":"text","value":"\n$$\n{\\color{green}{y(u, v)}} = \\min\\{0, {\\color{brown}{d(u)}} + cost(u, v) - {\\color{brown}{d(v)}}\\}\n$$\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"就可以了。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"正確地寫下最小費用循環的線性規劃模型以後，我們就可以利用線性規劃的最佳解性質，幫助我們判斷找到的網路流是不是最佳解。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"最佳解的性質"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"線性規劃的對偶觀念中，最重要的三件事情「弱對偶性」、「強對偶性」以及「"},{"type":"element","tagName":"a","properties":{"href":"http://terms.naer.edu.tw/detail/559045/"},"children":[{"type":"text","value":"互補差餘"}]},{"type":"text","value":"」（這詞﹍）。假設我們今天已經找到了圖 $G$ 上面的網路流 $f$，我們要怎麼檢驗或確認這個 $f$ 是最佳解呢？"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{"className":["message","is-warning"]},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{"className":["message-header"]},"children":[{"type":"text","value":"\n弱對偶性（Weak Duality）\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{"className":["message-body"]},"children":[{"type":"text","value":"\n若 $f$ 是最小費用流線性規劃的一個可行解，且 $y, d$ 是滿足對偶條件的對偶問題可行解。那麼必定有\n$$\n\\sum f(u, v)\\cdot cost(u, v) \\ge \\sum y(u, v)\\cdot cap(u, v)。\n$$\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"弱對偶性（Weak Duality）告訴我們，如果存在一組對偶可行解 $y(u, v)$、$d(v)$ 滿足 $\\sum f(u, v)\\cdot cost(u, v) = \\sum y(u, v)\\cdot cap(u, v)$，那麼 $f, y, d$ 同時都是最佳解。如果我們的演算法可以正確地輸出 $f, y, d$，那麼從這個輸出就可以得知正確性。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"最小費用流的演算法"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"基於以上論述，綜觀歷來的最小費用流解法們，可以大致分成兩個門派："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"消圈演算法（Cycle-Cancellation Algorithms）"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"主要的概念是在每一次迭代的過程中，永遠保證 $f$ 是一個可行解（feasible solution，也就是一個合法的網路流），在對偶空間中試圖搜尋滿足條件的 $d$ 值。如果找不到滿足條件的 $d$ 值，代表剩餘網路 $G_f$ 上不存在距離函數（有負圈！），也因為有負圈，我們可以在這個負圈上推一個流，讓其中一條邊流滿。這個動作可以讓負圈消失、也因為找到這個負圈，推流後可以讓整體費用下降。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"最短路徑增廣法（Successive-Shortest-Path Algorithms）"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"主要的概念是在每一次迭代的過程中，永遠保證 $d$ 是一組滿足對偶條件的距離函數，並且我們維護一個假想流 $f$（pseudo flow：只滿足"},{"type":"element","tagName":"span","properties":{"style":"color:green"},"children":[{"type":"text","value":"容量限制"}]},{"type":"text","value":"但可能無法"},{"type":"element","tagName":"span","properties":{"style":"color:brown"},"children":[{"type":"text","value":"流量守恆"}]},{"type":"text","value":"）。然後試圖更新這個假想流，一旦更新後滿足了流量守恆，我們就得到解了（因為隨時保證 $d$ 以及從 $d$ 推導出的 $y$ 永遠是合法的對偶問題可行解）。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我們會在未來的文章介紹這兩種演算法的細節與簡單版的實作。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"習題"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"我們用加了一條邊（$cap=\\infty, cost=-big$）的方法把「Min-Cost Max-Flow」轉化成「Min-Cost Circulation」。如果我們今天不要求「最大流」，只要找一個流，讓總花費最小，應該要如何進行轉化呢？"}]},{"type":"text","value":"\n"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"[CF161E] Polycarpus the Safecracker","category":"prob","path":"/problem/cf/161/E","date":null,"_PARENT":"9e7b2aaf-410e-5f8c-8a83-3b2a59a94ace","description":"Polycarpus 有 $t$ 個保險箱，每一個保險箱的密碼都是一個上面填了 $0$ 到 $9$ 之間數碼的方陣。由於 Polycarpus 實在太喜歡質數了，他把密碼設定成每一列都是質數。令他感到驚奇的是，每一組他設定的密碼都是對稱矩陣。事隔多年， Polycarpus 只記得每組密碼的第一列的數字 $p_i$，請你幫他算算，有多少種可能的密碼？除了第一列以外，其他列允許有前導 $0$ 的出現。第一列數字 $10\\le p_i\\le 99999$，總共有 $1\\le t\\le 30$ 組詢問。 \n","link":"https://codeforces.com/problemset/problem/161/E","code":"CF161E","difficulty":null,"oj":"codeforces","tags":null},"htmlAst":{"type":"root","children":[],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"Orthogonal Vectors","category":"prob","path":"/problem/orthogonal-vectors","date":null,"_PARENT":"21cce14b-c4a8-5af8-b969-25eebb87b521","description":"Given two sets $A, B\\subseteq \\set{0, 1}^d$, where $|A|=|B|=N$ and $d=\\Theta(\\log N)$. Then there exists $a\\in A$ and $b\\in B$ so that $\\langle a, b\\rangle = 0$.\n","link":null,"code":"OV","difficulty":null,"oj":null,"tags":null},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"[CF217B] Blackboard Fibonacci","category":"prob","path":"/problem/cf/217/B","date":null,"_PARENT":"986fc26d-251a-5587-a10c-a0fee14e0931","description":"費氏數列的定義為 $f_0=0, f_1=1, f_n=f_{n-2}+f_{n-1}$。Bajtek 發明了一種在黑板上計算費氏數列的方法：首先在黑板寫下數字 $0$，然後在它下面緊接著寫下數字 $1$。接著，每一次他進行下列其中之一的操作：\n\n* 操作 `T`：把上面的數字擦去，並換成兩個數字的總和。\n* 操作 `B`：把下面的數字擦去，並換成兩個數字的總和。\n\n如果一切順利，進行了 $n$ 次操作而且從 `T` 開始，將兩種操作交錯進行，那麼最後寫到黑板的數字就會是 $f_{n+1}$。\n\n問題是，Bajtek 在進行操作的時候，常常不小心重複了同一種操作許多次。例如，如果 $n=6$，原本應該要進行的操作順序是 `TBTBTB`，但如果 Bajtek 進行的操作是 `TTTBBT`，那麼會得到 $10$ 這個數字。我們定義「出錯的次數」為序列中該次操作與前一次操作相同的次數。即 `TT` 或 `BB` 出現的總次數。\n\n現在，已知 Bajtek 經過了恰好 $n$ 次操作後計算出了 $r$ 這個數字。請找出「出錯的次數」最少的操作序列，或者輸出無解。$(1\\le n, r\\le 10^6)$\n","link":"https://codeforces.com/problemset/problem/217/B","code":"CF217B","difficulty":null,"oj":"codeforces","tags":null},"htmlAst":{"type":"root","children":[],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"[CF233B] Non-square Equation","category":"prob","path":"/problem/cf/233/B","date":null,"_PARENT":"60a88f0e-01ab-54aa-a487-aa67d8d005b7","description":"對於正整數 $x$，我們定義 $s(x)$ 為其十進制表示法的各位數字和。現在給定 $n$ $(1\\le n\\le 10^{18})$，請你找出滿足下列方程 $$x^2+s(x)\\cdot x = n$$ 的最小正整數解 $x$ 或指出解不存在。\n","link":"https://codeforces.com/problemset/problem/233/B","code":"CF233B","difficulty":null,"oj":"codeforces","tags":null},"htmlAst":{"type":"root","children":[],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"[CF911C] Three Garlands","category":"prob","path":"/problem/cf/911/C","date":null,"_PARENT":"b20e3ef4-86e1-515a-88e2-0762b43603ec","description":"Mishka 買了三個聖誕樹的裝飾燈品，第 $i$ 個燈從開啟的那一剎那每間隔 $k_i$ 秒就會亮燈一下 $(1\\le k_i\\le 1500)$。Mishka 想知道是否存在三個開啟燈泡的時間 $x_1, x_2, x_3$，使得三個燈都打開以後，每一秒鐘都至少有一個燈泡亮著？\n","link":"https://codeforces.com/problemset/problem/911/C","code":"CF911C","difficulty":null,"oj":"codeforces","tags":null},"htmlAst":{"type":"root","children":[],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"[CF233B] Non-square Equation","category":"prob","path":"/problem/cf/241/C","date":null,"_PARENT":"84e22adf-2ef9-5f8c-b91a-a2165911c298","description":"有一個長 $10^5$ 公分、高 $100$ 公分的木頭箱子，箱子下方與上方各有一些水平擺放的鏡子、以及箱子左右兩端分別有一個可以讓光線進入的小孔，分別在高度 $h_l$ 以及 $h_r$ 公分處。下面的圖表示了箱子的情形：\n\n![](https://codeforces.com/predownloaded/58/b3/58b3e544e19da6e84c3667e027ccef48dd955657.png)\n\n在遊戲中，你必須要從左方的小孔中發射一束雷射光，然後讓這束光從右方小孔鑽出。每一面鏡子都有一個分數 ，若射中該面鏡子，則得到對應之分數。為了增加遊戲的趣味性，規定**雷射光只能打到每一面鏡子至多一次**。請找出最高的可能得分。鏡子數 $0\\le n\\le 100$。保證輸入的鏡子位置彼此不會重疊。\n","link":"https://codeforces.com/problemset/problem/241/C","code":"CF241C","difficulty":null,"oj":"codeforces","tags":null},"htmlAst":{"type":"root","children":[],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"鏈結串列 Linked Lists","category":"guide","path":"/leetcode-guide/linked-lists","date":"2018-12-21","_PARENT":"4a72e81b-fc86-52f9-bf04-419a324c9c5a","description":null,"link":null,"code":null,"difficulty":null,"oj":null,"tags":null},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Linked list 是一種資料結構，它利用了指標，讓在記憶體內距離很遠的資料也可以連結起來。根據每一個節點可以連結到的其他節點，大致可以分成以下兩種類型："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Singly Linked List"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"display","properties":{"linkedList":"","data":"[\"value: 1\", \"value: 2\", \"value: 3\"]"},"children":[{"type":"text","value":"\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"typedef struct Node {\n    int value;\n    Node* next;\n};\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Doubly Linked List"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"display","properties":{"linkedList":"","double":"","data":"[\"node 1\", \"node 2\", \"node 3\", \"node 4\", \"node 5\"]"},"children":[{"type":"text","value":"\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"typedef struct Node {\n    Node* prev;\n    int value;\n    Node* next;\n};\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"每一個 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"struct"}]},{"type":"text","value":" 在記憶體中會是連續的一塊空間。一般來說，我們會額外儲存一個指標 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"head"}]},{"type":"text","value":" 指向這個鍊結串列的開頭（不然就沒辦法存取了）。進行大部分的操作都是從這個 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"head"}]},{"type":"text","value":" 開始。"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"[LC326] Power of Three","category":"prob","path":"/problem/leetcode/326","date":null,"_PARENT":"e74bc4dd-45a4-545e-8b25-d5461fafc9cc","description":"給定一個整數 $x$，若這個整數是 3 的次方則回傳 `true`，否則回傳 `false`。\n","link":"https://leetcode.com/problems/power-of-three/","code":"LC326","difficulty":null,"oj":"leetcode","tags":null},"htmlAst":{"type":"root","children":[],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"強指數時間假說 Strong Exponential Time Hypothesis","category":"algo complexity","path":"/algo/strong-exponential-time-hypothesis","date":"2018-12-04","_PARENT":"3c12ca69-a148-5b10-96be-f391c6f9781f","description":null,"link":null,"code":null,"difficulty":null,"oj":null,"tags":null},"htmlAst":{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"關於 P vs NP 這個計算機學界最重要的問題之一，至今仍是懸而未解。1990年代，大量 NP-Complete 的證明興起，也讓研究計算理論領域的人們對於 NP-完備的概念有著比較深刻的理解。對於一個問題，究竟是多項式時間可解、或是它比任何一個 NP-Complete 的問題還要難，往往也有跡可循。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"許多演算法的分支：近似演算法（Approximation Algorithms）、指數時間演算法（Exponential Time Algorithms）等，利用搜索與剪枝、貪婪法、模擬退火等各種技巧，無所不用其極，都是因應傳統演算法所需要耗費的時間或空間嚴重不足而產生的。而 NP-Complete 是一個很好的 \"hint\"：在這個大多數的人們相信著 P $\\neq$ NP 的世界裡，要找出又快又最好的解往往是不可能的事情。一旦我們能夠證明一個問題是 NP-Hard 的，那麼在現實生活中，如果要有效率的解決這個問題，恐怕只能仰賴搜索或近似解了。"}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"$k$-CNF-SAT"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"先跟大家介紹一個 NP-Complete 當中的指標性問題："}]},{"type":"element","tagName":"theorem","properties":{"title":"$k$-CNF-SAT 問題","c":"is-info"},"children":[{"type":"text","value":"\n**輸入**：給定 $n$ 個變數 $x_1, x_2, \\ldots, x_n$ 以及一個 k-CNF $\\Phi$。其中 $\\Phi = C_1\\land C_2\\land \\cdots \\land C_m$，$m=O(n)$。每一個 clause 可以被許多 literals 描述 $C_i = (\\ell_{i1}\\lor \\ell_{i2}\\lor \\cdots \\lor \\ell_{ik})$，其中每一個 literal 就是任何一個變數 $x$ 或其 negation $\\lnot x$。\n  \n**問題**：是否存在一個合法的賦值方式，使得 $\\Phi$ 為真？\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"目前世界上最快的精確演算法（Exact Algorithm），在最壞情形下得跑 $2^{(1-o(1/k))n}$ 時間。也就是說，當 $k$ 真的超大的時候，這些演算法在最壞情形下都得花到扎扎實實 $2^n$ 的時間。於是乎，大家逐漸提出了以下的想法："}]},{"type":"element","tagName":"theorem","properties":{"title":"強指數時間假說 Strong Exponential Time Hypothesis (SETH)"},"children":[{"type":"text","value":"\n對於任意的常數 $\\epsilon > 0$，任何精確演算法皆無法在 $2^{(1-\\epsilon)n}$ 時間內同時對任意 $k$ 解決 $k$-CNF-SAT 問題。\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這個想法看起來很直覺，但是目前也還沒有人能夠真的證明或否定它。有趣的事情是，這個假說提供了厲害的基礎，如果這個假說是對的，那麼有很多演算法就會變成了「理論上最優」的演算法了！"}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"證明 NP-完備性的一貫方法"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果要證明一個題目 $X$ 是 NP-完備（NP-Complete）的，那麼我們需要從一個 NP-完備問題 $Y$ 出發，然後試圖將它的輸入在多項式時間內轉化成 $X$。然後斷定結論說「如果我們能在多項式時間內解決 $X$，那麼我們就可以在多項式時間內解決 $Y$。但是因為 $Y$ 是 NP-完備的，可以在多項式時間內解決 $Y$ 就代表可以在多項式時間內解決所有 NP 裡面的問題，於是 NP $=$ P。」"}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"P 的細分"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"很久很久以前大家就知道洋蔥定理 "},{"type":"element","tagName":"a","properties":{"href":"https://en.wikipedia.org/wiki/Time_hierarchy_theorem"},"children":[{"type":"text","value":"Time Hierarchy Theorem"}]},{"type":"text","value":" 了（我一直很喜歡隨機客老師稱呼這個定理的說法）。簡而言之，洋蔥定理描述的事情是：在所有 P 裡面的問題，不存在常數 $c$ 使得所有的問題都能在 $n^c$ 的時間被解掉。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"但這些定理所描述的一些 hardness problems 或反例與現實世界中的問題相距甚遠。2005 年由 Ryan Williams 提出了以下的「正交向量問題」，建立了指數時間演算法與多項式時間演算法之間的關聯。有趣的是，這個正交向量問題能夠轉化(reduce)成更多大家熟知的題目，包含最長共同部分子序列(LCS)等問題。也就是說，這一連串的轉化得到以下結論：如果存在更有效率的某某多項式演算法，就能夠推翻強指數時間假說。"}]},{"type":"comment","value":"\n2001 年的 Impagliazzo, Paturi & Zane 提出了重要的引理。然後在 \n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我們先來看看正交向量問題吧："}]},{"type":"element","tagName":"theorem","properties":{"title":"正交向量問題 Orthogonal Vector Problem (OV)","c":"is-info"},"children":[{"type":"text","value":"\n**輸入**: 給定 $d$ 維布林空間中的兩個向量集合 $A, B\\subset \\{0, 1\\}^d$，而集合大小 $|A|=|B|=N$。我們不妨假設 $d=\\Theta(\\log N)$。\n  \n**問題**: 是否存在 $a\\in A, b\\in B$ 使得 $\\langle a, b\\rangle = 0$？\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"看起來樸實無華的問題，如果要跟時下最夯的 Document Similarity 扯上邊好像也是可以齁（我就不多言了。）重點是，我們可以把 CNF-SAT 問題轉化成 Orthogonal Vector 問題，進而得到以下定理："}]},{"type":"element","tagName":"theorem","properties":{"title":"定理：$\\textsf{CNF-SAT}\\le_p \\textsf{OV}$"},"children":[{"type":"text","value":"\n若存在一個常數 $\\epsilon>0$ 以及一個演算法能在 $N^{2-\\epsilon}$ 時間內解決正交向量問題，那麼就存在一個常數 $\\epsilon' > 0$，以及一個演算法能在 $2^{(1-\\epsilon')n}$ 時間內解出 CNF-SAT 問題。\n"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"證明"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"不妨假設在 CNF-SAT 問題裡面的 $n$ 是偶數。我們把變數分成兩群：\n$S_1=\\set{x_1, x_2, \\ldots, x_{n/2}}$ 以及 $S_2 = \\set{x_{n/2+1}, \\ldots, x_{n-1}, x_n}$。枚舉這兩群變數所有可能的賦值情形，分別有 $2^{n/2}$ 種。（這個概念有點像是拆兩半的枚舉。）"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"讓我們來考慮 $S_1$：對於第 $i$ 種賦值情形，我們可以拿它來對照所有的 $m$ 個 clause，然後用這個資訊構造出一個長度為 $m$ 的 0-1 字串 $a_1a_2\\cdots a_m\\in\\set{0,1}^m$：考慮第 $j$ 個子句 $C_j$，如果目前對於 $x_1, \\ldots, x_{n/2}$ 的賦值能保證 $C_j$ 為真，我們就令 $a_j=0$，否則令 $a_j=1$。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"同理而言，我們也能夠針對後半段 $S_2$ 所有可能的變數賦值，構造出集合 $B$：若 $C_j$ 能被後半段的賦值給滿足，那麼就讓 $b_j=0$，否則令 $b_j=1$。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"行文至此，我們可以想像一下，如果我們拿構造出來的 $a_1a_2\\cdots a_m$ 與 $b_1b_2\\cdots b_m$ 計算其內積，得到的值代表什麼意思？如果內積的值為 $0$，則代表對於所有 $j$，要嘛 $a_j=0$ 要嘛 $b_j=0$，這代表我們找出來的 $S_1$ 賦值與 $S_2$ 賦值剛好可以滿足所有的子句！也就是說存在一個 $\\Phi=\\mathsf{true}$ 的一個解，若且唯若存在一組 $a\\in A, b\\in B$ 使得 $\\langle a, b\\rangle = 0$。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"現在讓我們來檢視集合大小，也就是 $n, m, N, d$ 之間的關係。集合 $A$ 與 $B$ 分別對應到 $S_1$ 與 $S_2$ 的賦值方式，所以 $N=|A|=|B|=2^{n/2}$。每一個構造出來的字串長度為 $m=O(n)$，因此 $d=m=n=\\Theta(\\log N)$ 滿足題目要求。所以囉，如果有一個 $N^{2-\\epsilon}$ 時間複雜度的方法可以解 OV，那麼就有一個 $\\left(2^{n/2}\\right)^{2-\\epsilon} = 2^{(1-\\epsilon/2)n}$ 時間複雜度的方法可以解 CNF-SAT 問題，與強指數時間假說(SETH)矛盾。"}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"參考資料"}]},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://en.wikipedia.org/wiki/Exponential_time_hypothesis"},"children":[{"type":"text","value":"維基百科: Exponential Time Hypothesis"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://people.csail.mit.edu/rrw/2-csp-final.pdf"},"children":[{"type":"text","value":"Ryan Williams, A new algorithm for optimal constraint satisfaction and its implications, 2005."}]}]},{"type":"text","value":"\n"}]}]}}},{"node":{"frontmatter":{"title":"[TIOJ 1010] Prefix and Postfix","category":"my-problem","path":"/cp/tioj/1010","date":"2018-11-22","_PARENT":"9838c9ad-c2e8-5e05-b7f6-53ba22d75d58","description":"我們說字串 $A$ 是字串 $B$ 的Prefix（前綴字串），若且唯若字串 $B$ 的前 $len(A)$ 個字母與 $A$ 完全相同，其中 $len(A)$ 指的是字串 $A$ 的長度。例如： “Exam” 和 “Example”都是 “Example” 的 Prefix，但是 “Ample”和 “Exapple” 都不是 “Example” 的 Prefix。同樣的，當 $B$ 的後 $len(A)$ 個字母與 $A$ 完全相同的時候，我們稱 $A$ 是 $B$ 的 Suffix (後綴字串)。給定兩個字串 $P$, $Q$，請你找出最長的字串 $S$ 使得 $S$ 是 $P$ 的 Prefix，同時也是 $Q$ 的 Suffix。\n","link":"https://tioj.ck.tp.edu.tw/problems/1010","code":null,"difficulty":1,"oj":"TIOJ","tags":null},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"題目敘述"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"兩個字串 $P$, $Q$ 各佔一行，只包含小寫英文字母，長度皆不超過 1000 字元。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸出說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"輸出最長的字串 $S$ 的長度 $len(S)$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Sample Input"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"example\nexam\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Sample Output"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"4\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"出處"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"95建中資訊培訓模擬試題一（Prob 2）"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ連結"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://tioj.ck.tp.edu.tw/problems/1010"},"children":[{"type":"text","value":"TIOJ 1010 - Prefix and Postfix"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"題解"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"注意到輸入的字串長度不超過 1000 個字元，所以我們只要逐一枚舉所有第一個字串的 prefix，看看它是不是第二個字串的 suffix 就好了～"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"要取出子字串，可以利用 C++ 的 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"<string>"}]},{"type":"text","value":" 函式庫。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"/* by tmt514 */\n#include <algorithm>\n#include <string>\n#include <iostream>\nusing namespace std;\n\nint main() {\n    string P, Q;\n    cin >> P >> Q;\n    int ans = min(P.size(), Q.size());\n    while (ans > 0 && (P.substr(0, ans) != Q.substr(Q.size()-ans)))\n        --ans;\n    cout << ans << endl;\n    return 0;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"關於這題"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這題顯然是個字串匹配的問題，而且是 KMP 演算法的直接應用。但是根據輸入規模，找出能夠通過測試的最單純演算法，才是取得先機的關鍵。"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"[TIOJ 1009] In No Time!","category":"my-problem","path":"/cp/tioj/1009","date":"2018-11-21","_PARENT":"39582c96-0d5c-518d-8d7f-b5a38f189009","description":"考試時間所剩不多，你能夠把握剩下時間完成所有題目嗎？ 給你現在時間以及考試終止時間，請你判斷還剩下多少時間可以做題目。\n","link":"https://tioj.ck.tp.edu.tw/problems/1009","code":null,"difficulty":1,"oj":"TIOJ","tags":null},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"題目敘述"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"輸入有兩行，第一行表示現在時間，第二行表示考試終止時間。時間的格式為 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"HH:MM:SS"}]},{"type":"text","value":" (時：分：秒)，終止時間永遠比現在時間晚，但兩者時間差不會超過一天(24小時)。(請注意：兩者的時間點不一定都在同一日。)"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸出說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"請輸出距離考試結束還有多久時間，以 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"HH:MM:SS"}]},{"type":"text","value":" 表示。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Sample Input"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"14:00:00\n10:00:00\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Sample Output"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"20:00:00\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"出處"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"95建中資訊培訓模擬試題一（Prob 1）"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ連結"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://tioj.ck.tp.edu.tw/problems/1009"},"children":[{"type":"text","value":"TIOJ 1009 - In No Time!"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"題解"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這題基本上就是考驗大家怎麼把輸入讀進來，如果是傳統的 C 語言的話，由於有格式化輸入 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"scanf"}]},{"type":"text","value":" 世界會變得比較輕鬆些。如果把所有時間都轉換成秒來計算的話，會比較簡單。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"/* by tmt514 */\n#include <cstdio>\n\nint read_input() {\n    // 讀取輸入並且轉換成秒數。\n    int h, m, s;\n    scanf(\"%d:%d:%d\", &h, &m, &s);\n    return (h*60+m)*60+s;\n}\n\nvoid output(int sec) {\n    printf(\"%02d:%02d:%02d\\n\", sec/3600, sec/60%60, sec%60);\n}\n\nint main() {\n    int A = read_input();\n    int B = read_input();\n    if (A >= B) {\n        // 隔天了。\n        B += 86400;\n    }\n    output(B-A);\n    return 0;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"後記"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這個時間序應該是高三上學期的時候，當時高二進了選訓營，學了很多很多東西。\n高三校內初選以後，在彭天健老師和林淑玲老師的協助下，參與了資訊校隊培訓的工作。\n剛好那個時候，北大的 OJ 有釋出版可以玩。我就下載了一套拿來架在自己家裡的主機裡面，並嘗試放了一些題目，邀請大家一起來寫。印象中當年校內預賽的題目是彭天健老師出的，在第一場練習賽之前就先放了預賽題目（TIOJ 1003~1008）讓大家練習。而這題 TIOJ 1009 應該就是正式放上的第一題了吧哈哈～"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"更早之前應該還有出過一套資訊社高二選幹部的演算法考試。那時候還沒有 OJ 可以用，克難地跟 ianchou 用 PHP 架了簡單的評分系統（從現在看起來應該到處都是漏洞哈哈）。可惜我現在一時之間找不到資料。以後有機會再補上當年那套題目吧～"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"[TIOJ 1011] Edit Distance In Numbers","category":"my-problem","path":"/cp/tioj/1011","date":"2018-11-23","_PARENT":"0d9a2cdc-4430-5ce8-8ffa-60d7ce91d55a","description":"對於字串來說，Edit Distance是一個著名的DP問題。現在我們把這個問題弄得簡單一點，例如：把字串換成數字。對於一個數字$A$，我們想要藉由某些操作換成數字$B$。而對於整數$K$的一個合法的操作包括以下三種情形：\n\n* 乘以 $2$ 加 $1$，即 $K=2K+1$\n* 乘以 $2$，即 $K=2K$\n* 除以 $2$，即 $K=\\lfloor K/2\\rfloor$\n\n給定整數 $A$ 和 $B$，請你求出最小的操作次數 $N$使得從 $A$ 開始操作 $N$ 次可以換成 $B$。\n","link":"https://tioj.ck.tp.edu.tw/problems/1011","code":null,"difficulty":1,"oj":"TIOJ","tags":null},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"題目敘述"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"包含兩個數字 $A, B$ ($0 \\leq A, B \\leq 2^{31}$)。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸出說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"請輸出最小操作次數 $N$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Sample Input"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"17\n15\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Sample Output"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"7\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"出處"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"95建中資訊培訓模擬試題一（Prob 3）"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ連結"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://tioj.ck.tp.edu.tw/problems/1011"},"children":[{"type":"text","value":"TIOJ 1011 - Edit Distance In Numbers"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"題解"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"把輸入的數字表示成二進位以後，所有的操作都會變成在當前的二進位字串後面加上一位數、或刪除一位數。考慮 $A$ 和 $B$ 的二進位值之後，他們的最長共同前綴（Longest Common Prefix）$S$，而最佳解就會是一路把 $A$ 除到變成 $S$，然後再一路加上末尾的位元變成 $B$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"要把數字轉換成二進位的字串、再找出他們的最長共同前綴是一件好像有點麻煩的事情（雖然也不是太麻煩）。我們可以把「加上末尾的位元變成 $B$」的步驟反過來，變成從 $B$ 開始逐一刪除末尾的 0。這樣可以得到一個單純的演算法，重複比較 $A$ 和 $B$ 誰比較大，比較大的數字除以 2，直到相同為止。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"/* by tmt514 */\n#include <iostream>\nusing namespace std;\n\nint main() {\n    int A, B, ans = 0;\n    cin >> A >> B;\n    while (A != B) {\n        (A > B? A : B) /= 2;\n        ++ans;\n    }\n    cout << ans << endl;\n    return 0;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"關於這題"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這題的概念是二進位思考，如果把輸入的數字用不同的表示方法（比方說二進位）表示出來，那麼看似麻煩的操作就會變得很直觀。"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"[TIOJ 1012] Rails","category":"my-problem","path":"/cp/tioj/1012","date":"2018-11-25","_PARENT":"af6dddda-da3c-59a0-8740-3b9e6f2e1a95","description":"在一個叫「堆疊市」的城市中有一個著名的火車站。由於地形限制以及經費關係，火車站及唯一的鐵路的樣子如下圖：\n\n![](https://tioj.ck.tp.edu.tw/pimgs/1012_1.jpg)\n\n現在火車從A方向來，預定從B方向離開。火車共有N節車廂，並且各車廂依次以1到N來編號。你可以假設各車廂在進站之前可以單獨與其他車廂分離，也可以單獨離開車站到往B方向的鐵軌或是車站北方的「維修鐵路」上。維修鐵路是一小段至多只能容納M節車廂的鐵軌，可以從車站依照順序將車廂移至維修鐵路，或者將車廂從維修鐵路（如果有的話）駛進車站，但是在把車廂從A開進車站的時候，維修鐵路不能有任何車廂。你可以假設在任何時間火車站都可以容納所有的車廂。但是一旦一節車廂進站後，就不能再回到A方向的鐵軌上了，並且一旦離開車站往B方向後，也不能再回到車站。\n\n現在你的任務是寫一個程式，判斷火車能否以一特定的排列方式在B方向的鐵軌上。\n","link":"https://tioj.ck.tp.edu.tw/problems/1012","code":null,"difficulty":1,"oj":"TIOJ","tags":null},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"題目敘述"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"第一行有兩個正整數 $N, M$。($1\\le N\\le 1000, 0\\le M\\le 9$)"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"第二行有 $N$ 個正整數，為 $1, 2, \\ldots, N$ 的一個排列。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸出說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"若能在 B 鐵軌上排出特定排列，請輸出 yes，否則請輸出 no。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Sample Input"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"5 1\n3 2 5 1 4\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Sample Output"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"yes\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"出處"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"95建中資訊培訓模擬試題一（Prob 4）"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ連結"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://tioj.ck.tp.edu.tw/problems/1012"},"children":[{"type":"text","value":"TIOJ 1012 - Rails"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"題解"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這題有個決定性的觀察：基本上，當一節火車從 A 進入車站時，他所排列的位置必須在所有已經進入車站的車廂最上面。也就是說，無論哪些車廂已經被送到鐵軌 B 處，從上到下的順序永遠是遞減的（與進入車站的順序相反），剛好是一個堆疊的樣子。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"於是這讓我們能用基於貪婪法的模擬來解題：如果要駛出的車廂出現在目前堆疊頂端 $M+1$ 節車廂裡面，那我們就直接把他開走。如果想要的車廂還沒有進到車站，就不斷放車廂進來，直到該節車廂一進站立馬停下來。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"/* by tmt514 */\n#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n    int N, M, x, now = 0;\n    vector<int> station;\n    cin >> N >> M;\n    for (int i = 0; i < N; i++) {\n        cin >> x;\n        // 不斷把新的車廂放進來，直到目標車廂出現為止。\n        while (now < x) station.push_back(++now);\n        // 計算目標車廂的位置。\n        auto it = find(station.begin(), station.end(), x);\n        int dist = station.end() - it;\n\n        if (dist > M+1) {\n            // 距離過遠代表得放超過 M 個車廂到上面，做不到。\n            cout << \"no\" << endl;\n            return 0;\n        } else {\n            // 否則就模擬把這節車廂開走。\n            station.erase(it);\n        }\n    }\n    cout << \"yes\" << endl;\n    return 0;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"關於這題"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這一題的原始構想是來自於 "},{"type":"element","tagName":"a","properties":{"href":"https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=455"},"children":[{"type":"text","value":"[UVa 514] Rails"}]},{"type":"text","value":"，只不過加上了一條維修鐵路，所以變得有一點不太相同，但解法還是差不多。"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"[TIOJ 1013] Fire in the forest","category":"my-problem","path":"/cp/tioj/1013","date":"2018-12-01","_PARENT":"c77056bb-0038-57fc-81b5-f6a00f3fe273","description":"中秋節的時候有人在森林中烤肉，一不小心就釀成了火災，火勢非常猛烈，如果某個區域原本沒有著火，但是相鄰的區域著火了，那麼下一分鐘這個區域也會被火勢波及。你很不幸的身處於著火的森林中，不過好加在你隨身帶了筆記型電腦，而且你恰好有這個森林地圖的資料。由廣播得知，火勢於第 $1$ 分鐘發生於起火點 $F$，而現在已經是第 $T$ 分鐘了。你的位置在 $S$ 處，標記 $E$ 的位置代表安全的避難所，並且有直升機場可以搭乘直升機避難。地圖上標著 `*` 的地方代表不可通行的區域，`.` 則是代表可以通過的區域。時間緊迫！你得趕緊找安全的逃生路線！\n\n座標化的森林的地圖是一個長 $17$ 單位、寬 $10$ 單位的一片土地，詳細狀況如下：\n\n```\n*****************\n*...*.......**..*\n**..*....*.*.*..*\n*......*.**.**.**\n*..**...**..**.**\n**.....**..*.*..*\n*....*..........*\n*.....****.*...**\n****.*.*........*\n*****************\n```\n\n左上角的位置為 $(0,0)$，右下角的位置為 $(9,16)$。你每分鐘可以從一個區域移動至相鄰的區域(在這裡所有的相鄰都不包含對角線方向)。現在給定 $F,T$ 之值以及 $S,E$ 的位置，請你求出從 $S$ 到 $E$ 的最短時間。\n","link":"https://tioj.ck.tp.edu.tw/problems/1013","code":null,"difficulty":2,"oj":"TIOJ","tags":null},"htmlAst":{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"題目敘述"}]},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"第一行有兩個正整數 $FX$, $FY$，代表起火點F的座標。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"第二行有一個正整數 $T (1\\le T\\le 1000)$，代表已經歷時間。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"第三行有四個正整數 $SX$, $SY$, $EX$, $EY$，代表你所在的位置以及安全避難所的位置。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"你可以假設 $F,S,E$ 皆位於可通行處。且避難所不會著火，$F,S,E$ 互不重疊。"}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸出說明"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"若可以安全逃離，請輸出從 $S$ 到 $E$ 的最短時間。若你發現身陷火場，或者你根本無法到達避難所的時候，請輸出 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"Help!"}]},{"type":"text","value":"。"}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Sample Input"}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"1 1 \n3 \n4 1 3 3 \n"}]}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Sample Output"}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"9\n"}]}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"出處"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"95建中資訊培訓模擬試題一（Prob 5）"}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ連結"}]},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://tioj.ck.tp.edu.tw/problems/1013"},"children":[{"type":"text","value":"TIOJ 1013 - Fire in the forest"}]}]},{"type":"text","value":"\n"}]},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"題解"}]},{"type":"element","tagName":"algorithm","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"generator","properties":{},"children":[{"type":"element","tagName":"pre","properties":{},"children":[{"type":"text","value":"\nfunction*(input, ui) {\n    var forest = [\n        \"*****************\",\n        \"*...*.......**..*\",\n        \"**..*....*.*.*..*\",\n        \"*......*.**.**.**\",\n        \"*..**...**..**.**\",\n        \"**.....**..*.*..*\",\n        \"*....*..........*\",\n        \"*.....****.*...**\",\n        \"****.*.*........*\",\n        \"*****************\",\n    ];\n    forest = forest.map((e) => e.split(\"\"));\n    var fx = input.fx;\n    var fy = input.fy;\n    var T = input.T;\n    var sx = input.sx;\n    var sy = input.sy;\n    var ex = input.ex;\n    var ey = input.ey;\n    forest[fx][fy] = 'F';\n    forest[ex][ey] = 'E';\n    yield {forest: forest};\n    var t, i, j, f;\n    var d = [[0, 1], [1, 0], [0, -1], [-1, 0]];\n    for (t = 0; t < 24; t++) {\n        var newforest = JSON.parse(JSON.stringify(forest));\n        for (i = 0; i < forest.length; i++) {\n            for (j = 0; j < forest[0].length; j++) {\n                if (forest[i][j] === 'F') {\n                    for (f = 0; f < 4; f++) {\n                        var ni = i+d[f][0];\n                        var nj = j+d[f][1];\n                        if (forest[ni][nj] === '.') {\n                           newforest[ni][nj] = 'F';\n                           ui.setStyleOnce('forest', JSON.stringify([ni, nj]), {fill: 'yellow'}); \n                        }\n                    }\n                }\n            }\n        }\n        console.log(newforest);\n        forest = newforest;\n        yield {forest: forest};\n    }\n    return {forest: forest};\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"inputdata","properties":{"data":"{\"fx\":1, \"fy\":1, \"T\": 3,\n    \"sx\":4, \"sy\": 1, \"ex\": 3, \"ey\": 3}"},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"indirectdisplay","properties":{"grid":"","uihelperNodeStyle":"{stroke: \"none\"}","uihelperContentMap":"{\n        F:{fill: \"#FA8\", font: \"bold 24px Courier New\"},\n        \"*\":{fill: \"#555\"}\n    }","varname":"forest"},"children":[]},{"type":"text","value":"\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"可以利用 BFS 來模擬森林中的火勢蔓延的狀況。用 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"onFire"}]},{"type":"text","value":" 陣列記錄下每個格點第一次著火的時間。然後根據這個表格在 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"onEscape"}]},{"type":"text","value":" 陣列記錄下從 $S$ 出發不踩過火到該點的所有時間。在這裡分享一些有趣的實作小細節："}]},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"使用方向陣列："},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"dx[]"}]},{"type":"text","value":" 和 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"dy[]"}]},{"type":"text","value":" 分別儲存四個方向所需要的位移數值。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"在把座標放進 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"queue"}]},{"type":"text","value":" 的時候，依序放入 $x$ 和 $y$ 座標。取出時也按照這個順序取，就不需要寫麻煩的 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"pair<int, int>"}]},{"type":"text","value":" 了。"}]},{"type":"text","value":"\n"}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"/* by tmt514 */\n#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nvector<string> forest = {\n  \"*****************\",\n  \"*...*.......**..*\",\n  \"**..*....*.*.*..*\",\n  \"*......*.**.**.**\",\n  \"*..**...**..**.**\",\n  \"**.....**..*.*..*\",\n  \"*....*..........*\",\n  \"*.....****.*...**\",\n  \"****.*.*........*\",\n  \"*****************\",\n};\n\nconst int dx[4] = {0, 1, 0, -1};\nconst int dy[4] = {1, 0, -1, 0};\nint onFire[10][17];\nint onEscape[10][17];\n\nvoid bfs(int mark[10][17], int hasFire[10][17], int sx, int sy, int T) {\n  queue<int> q;\n  // 如果一開始就著火了，就應該直接死掉。\n  if (hasFire && hasFire[sx][sy] <= T) return;\n  mark[sx][sy] = T;\n  q.push(sx);\n  q.push(sy);\n  while (!q.empty()) {\n    int x = q.front(); q.pop();\n    int y = q.front(); q.pop();\n    int t = mark[x][y];\n    // 依序考慮四個方向是否可通行，如果可通行的話加到佇列裡面。\n    for (int dir = 0; dir < 4; dir++) {\n      int nx = x + dx[dir];\n      int ny = y + dy[dir];\n      if (forest[nx][ny] == '.' && \n          mark[nx][ny] == 0 &&\n          (!hasFire || hasFire[nx][ny] == 0 || hasFire[nx][ny] > t+1)) {\n        mark[nx][ny] = t+1;\n        q.push(nx);\n        q.push(ny);\n      }\n    }\n  }\n}\n\nint main() {\n  int fx, fy, sx, sy, ex, ey, T;\n  cin >> fx >> fy >> T;\n  cin >> sx >> sy >> ex >> ey;\n  // 由於火勢不會燒到避難處，所以一開始要取巧把這格改掉。\n  forest[ex][ey] = 'E';\n  bfs(onFire, NULL, fx, fy, 1);\n  // 然後把它改回變成可以通行。\n  forest[ex][ey] = '.';\n  bfs(onEscape, onFire, sx, sy, T);\n  if (onEscape[ex][ey] > 0) {\n    cout << onEscape[ex][ey]-T << endl;\n  } else {\n    cout << \"Help!\" << endl;\n  }\n  return 0;\n}\n"}]}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"關於這題"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"很久很久以前的北市賽（在還沒有使用 CMS 系統和使用隨身碟/磁碟輸入以前），評分的時候都是手動輸入測試資料的。當時出的模擬練習，就有點想要效法這樣的出題風格，所以森林的地圖就變成這樣 hard-code 的風格了。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"註：以前是紙本題目，所以連地圖也要在比賽進行時手刻上去 QAQ"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"其他推薦題解"}]},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://blog.ototot.tk/2017/01/tioj-1013-fire-in-forest.html"},"children":[{"type":"text","value":"oToToT 的 code 收藏區：TIOJ 1013"}]}]},{"type":"text","value":"\n"}]}]}}},{"node":{"frontmatter":{"title":"[TIOJ 1014] 打地鼠","category":"my-problem","path":"/cp/tioj/1014","date":"2018-12-05","_PARENT":"2c5736c7-325e-57f3-a04e-fa4b44051a5b","description":"隨著時間的腳步前進，打地鼠遊戲也不斷的翻新，最新一代的打地鼠遊戲不只測試你的反應能力，同時也考驗著你的體力和智力。地鼠基地是一個長型的基座，基座上每隔一公尺就會有一個地鼠洞，由左至右編號為 $1,2,\\ldots,n$。玩家站在這個基地的最左邊，與第一個地鼠洞相距 $1$ 公尺；拿著一根鎚子，準備開始這個遊戲。編號為 $i$ 的地鼠洞每 $T_i$ 秒地鼠會出現一次。被打的地鼠不再出現，只要將所有地鼠打完，就結束遊戲，並且紀錄從開始到結束遊戲的秒數，越快越好。現在問題來了，負責製造這個地鼠基地的遊戲廠商想要知道結束遊戲所需的最少秒數，於是拜託你幫忙寫個程式來解決它。\n\n假定玩家們的體力很好，隨時以每秒 $1$ 公尺的速度移動，並且不受移動方向改變的影響，打地鼠所花的時間也可以忽略不計。\n","link":"https://tioj.ck.tp.edu.tw/problems/1014","code":null,"difficulty":3,"oj":"TIOJ","tags":null},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"題目敘述"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"第一行有一個數字 $n$，代表地鼠洞的數量 $(1\\le n\\le 16)$。第二行有 $n$ 個數字。所有數字皆不大於 $100,000,000$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸出說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"請輸出結束遊戲所需的最少秒數 $S$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Sample Input"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"3\n3 2 5\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Sample Output"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"5\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"出處"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"95建中資訊培訓模擬試題一（Prob 6）"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ連結"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://tioj.ck.tp.edu.tw/problems/1014"},"children":[{"type":"text","value":"TIOJ 1014 - 打地鼠"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"題解"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這個題目是動態規劃，我們定義狀態 $\\dp(S, i)$ 表示玩家已經打掉集合 $S\\subseteq [n]$ 的地鼠，而且目前玩家所在位置是 $i$ 所需的最少秒數。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"/* by tmt514 */\n#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nvector<string> forest = {\n  \"*****************\",\n  \"*...*.......**..*\",\n  \"**..*....*.*.*..*\",\n  \"*......*.**.**.**\",\n  \"*..**...**..**.**\",\n  \"**.....**..*.*..*\",\n  \"*....*..........*\",\n  \"*.....****.*...**\",\n  \"****.*.*........*\",\n  \"*****************\",\n};\n\nconst int dx[4] = {0, 1, 0, -1};\nconst int dy[4] = {1, 0, -1, 0};\nint onFire[10][17];\nint onEscape[10][17];\n\nvoid bfs(int mark[10][17], int hasFire[10][17], int sx, int sy, int T) {\n  queue<int> q;\n  // 如果一開始就著火了，就應該直接死掉。\n  if (hasFire && hasFire[sx][sy] <= T) return;\n  mark[sx][sy] = T;\n  q.push(sx);\n  q.push(sy);\n  while (!q.empty()) {\n    int x = q.front(); q.pop();\n    int y = q.front(); q.pop();\n    int t = mark[x][y];\n    // 依序考慮四個方向是否可通行，如果可通行的話加到佇列裡面。\n    for (int dir = 0; dir < 4; dir++) {\n      int nx = x + dx[dir];\n      int ny = y + dy[dir];\n      if (forest[nx][ny] == '.' && \n          mark[nx][ny] == 0 &&\n          (!hasFire || hasFire[nx][ny] == 0 || hasFire[nx][ny] > t+1)) {\n        mark[nx][ny] = t+1;\n        q.push(nx);\n        q.push(ny);\n      }\n    }\n  }\n}\n\nint main() {\n  int fx, fy, sx, sy, ex, ey, T;\n  cin >> fx >> fy >> T;\n  cin >> sx >> sy >> ex >> ey;\n  // 由於火勢不會燒到避難處，所以一開始要取巧把這格改掉。\n  forest[ex][ey] = 'E';\n  bfs(onFire, NULL, fx, fy, 1);\n  // 然後把它改回變成可以通行。\n  forest[ex][ey] = '.';\n  bfs(onEscape, onFire, sx, sy, T);\n  if (onEscape[ex][ey] > 0) {\n    cout << onEscape[ex][ey]-T << endl;\n  } else {\n    cout << \"Help!\" << endl;\n  }\n  return 0;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"關於這題"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"第一次嘗試出的位元壓縮 DP，相當地有趣呢。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"其他推薦題解"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://polarischiba.blogspot.com/2018/02/tioj-1014.html"},"children":[{"type":"text","value":"PolarisChiba 的 code 收藏區：[TIOJ] 1014打地鼠"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"http://snowyojworld.blogspot.com/2014/10/tioj-1014.html"},"children":[{"type":"text","value":"藍雪的Online Judge日誌：TIOJ 1014 . 打地鼠"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"http://colistar.blogspot.com/2009/10/tioj-1014.html"},"children":[{"type":"text","value":"A Coding E. Coli：TIOJ 1014 打地鼠"}]}]},{"type":"text","value":"\n"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"[URAL1854] Negotiations with Parthians","category":"prob","path":"/problem/ural/1854","date":null,"_PARENT":"2a91e8fd-4d01-5c41-8a51-1d86c9237447","description":"古希臘以及古羅馬人不喜歡偶數。現在 Andrian 有 $n$ $(1\\le n\\le 10^{18}-1)$ 隻羊(奇數隻)要獻給神明，為了公平，每一位神明都要得到數量相同的羊。為了更吉利，Andrian 決定將羊群獻給奇數位神明、並且這個數量也要有奇數個正因數。請問 Andrian 至多可以將羊獻給多少位神明呢？\n","link":"http://acm.timus.ru/problem.aspx?space=1&num=1854","code":"URAL1854","difficulty":null,"oj":"ural","tags":null},"htmlAst":{"type":"root","children":[],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"Bipartite Battle","category":"prob","path":"/problem/icpc/asia_hanoi_2018/B","date":"2019-01-09","_PARENT":"24f4030b-6ab0-557e-bb6f-fa7d36ec3e72","description":"Socket 和 Bash 在玩一個叫做「Bipartite Battle」的遊戲。這個遊戲的進行方式如下：\n\n* Socket 在桌上先畫出 $N$ 組二部圖（bipartite graph）。第 $i$ 組二部圖的兩個部份，分別包含 $a_i$ 個點與 $b_i$ 個點。\n* 接下來，由 Bash 和 Socket 輪流進行。每一個回合，玩家必須選擇 $N$ 個之中的其中一個非空的圖、並且要嘛刪掉一條邊，要嘛去掉一個點。去掉點的當下，所有連著該點的邊也全部都會被去除。\n* 沒辦法進行操作的人就輸了（也就是說當所有圖的邊跟點都被刪掉以後，下一個人就輸了）。\n* Bash 是先手。\n\n當然，Socket 想要畫一些二部圖使得他能夠總是獲勝。請問 Socket 有多少種畫圖的方法？（請輸出答案除以 $10^9+7$ 的餘數。）\n","link":"https://open.kattis.com/problems/amazingadventures","code":"ICPC-HANOI-2018-B","difficulty":6,"oj":"kattis","tags":["ICPC 2018 Asia Hanoi Regional","game"]},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"簡化後題目敘述"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"第一列有一個正整數 $N$ ($1\\le N\\le 10^5$)。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"接下來的 $N$ 列每一列有兩個整數 $a_i, b_i$ ($1\\le a_i, b_i\\le 10^9$)。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸出說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"輸出 Socket 能夠獲勝的二部圖畫法，除以 $10^9+7$ 的餘數。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"1\n1 1\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"1\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"1\n1 2\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"0\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ 連結"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://open.kattis.com/problems/bipartitebattle"},"children":[{"type":"text","value":"Open Kattis - Bipartite Battle"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這是一道還算經典且有趣的題目～"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"看到「兩人、對稱式、資訊全揭露、博弈問題」"},{"type":"element","tagName":"footnote","properties":{"goto":"1","show":"備註1"},"children":[]},{"type":"text","value":"，想到的關鍵字大概就是拈遊戲（Nim Game）與 "},{"type":"element","tagName":"a","properties":{"href":"https://zh.wikipedia.org/wiki/%E5%B0%BC%E5%A7%86%E6%95%B0"},"children":[{"type":"text","value":"SG值（Sprague-Grundy Value）"}]},{"type":"text","value":"了！\n但這題的數字範圍實在是大到非常誇張，因此可以大膽猜測應該是結論題吧哇哈哈哈。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"很用力地嘗試了一些比較小的二分圖以後，首先映入眼簾的是相當不尋常的單一性：所有 $a_i+b_i=n$ 個點的樹的 SG值都相同！而且根據 $n$ 的值，這些 SG 值是交錯進行的："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"display","properties":{"array":"","minWidth":"40","fixedwidthRatios":"[2]","data":"[\"n\", 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]"},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"display","properties":{"array":"","fixedwidthRatios":"[2]","minWidth":"40","data":"[\"SG值\", 1, 2, 1, 2, 1, 2, 1, 2, 1, 2]"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"為什麼我們注意到樹呢？因為手動計算的時候，前幾小的非樹連通圖只有 cycle 而已啊，其他都是樹。我們多嘗試了一些，發現任何 $a_i+b_i=n$ 個點且恰好有 $m$ 條邊的二部圖，其 SG 值也總是相等的！於是我們可以整理出以下表格。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"display","properties":{"grid":"","uihelperContentMap":"{\n        \"0\": {fill: \"#FE8\"}\n    }","font":"12pt Roboto","data":"[[\"n\\\\m\", 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10],\n            [1,    1, \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n            [2,  \"0\",  2, \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n            [3,    1,  3,  1, \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n            [4,  \"0\",  2,\"0\",  2,\"0\", \"\", \"\", \"\", \"\", \"\", \"\"],\n            [5,    1,  3,  1,  3,  1,  3,  1, \"\", \"\", \"\", \"\"],\n            [6,  \"0\",  2,\"0\",  2,\"0\",  2,\"0\",  2,\"0\",  2, \"\"],\n            [7,    1,  3,  1,  3,  1,  3,  1,  3,  1,  3,  1]]"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"從表格看起來應該就很明顯了吧！只有在總點數 $\\sum(a_i+b_i)$ 是偶數、而且總邊數也是偶數的時候，Socket（後手）才會獲勝。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"事後諸葛"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"令 $sg(n, m)$ 表示任何一個 $n$ 個點 $m$ 條邊的二部圖的 SG 值，根據以上規律，不難發現 $sg(n, m) = (n\\bmod 2) + 2(m\\bmod 2)$。\n我們可以利用（萬用的）數學歸納法來證明任何 $n$ 個點、且 $m$ 條邊的二部圖其 SG 值都相等，而且等於該值。首先，根據 SG 值的原則："}]},{"type":"text","value":"\n$$\nsg(當前狀態) = \\mathrm{mex}\\{ sg(任何下一個狀態) \\}\n$$\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"（其中 "},{"type":"element","tagName":"a","properties":{"href":"https://en.wikipedia.org/wiki/Mex_(mathematics)"},"children":[{"type":"text","value":"mex (minimum excluded value)"}]},{"type":"text","value":" 的意思是所有非負整數中"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"沒有"}]},{"type":"text","value":"出現在集合內的最小值。）"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"現在讓我們來考慮數學歸納法的邊界條件 base case："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"當 $m=0$ 的時候，雙方都只有唯一一種方法（每次刪掉一個點），所以\n$sg(n, 0) = \\begin{cases}\n0 & \\text{當$n$是偶數，}\\\\\n1 & \\text{當$n$是奇數。}\n\\end{cases}$"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"當 $m>0$ 的時候，考慮 $n$ 個點的圖 $G$。我們可以根據歸納假設，對於所有 $m'< m$ 或 $n' < n$ 的 $sg(n', m')$ 值都已經是正確的了。\n此時玩家有兩種選擇："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"(A) 刪除一條邊、或 "}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"(B) 刪除一個點。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"情形 (A) 很單純，因為我們可以知道此時 SG 值會變成 $sg(n, m-1)$。\n情形 (B) 就有點複雜：刪掉的點 $v$ 它的度數 $\\deg(v)$ 也必須考慮進來，變成 $sg(n-1, m-\\deg(v))$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"接著我們可以按情形討論 mex 的值："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"如果 $n$ 是偶數、且 $m$ 是偶數：那麼情形 (A) 會給你新的 SG 值 $=2$，情形 (B) 會給你 $1$ 或 $3$（來自前一排），無論如何都不會拿到 $0$，因此可以斷定此時 SG 值 $= 0$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"如果 $n$ 是偶數、且 $m$ 是奇數：那麼情形 (A) 會給你新的 SG 值 $=0$、且存在一個奇數度數的點（因為總邊數是奇數、且 $G$ 是二部圖），此時情形 (B) 會給你 $1$，無論如何都不會拿到 $2$，因此可以斷定此時 SG 值 $= 2$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"如果 $n$ 是奇數、且 $m$ 是偶數：那麼情形 (A) 會給你新的 SG 值 $=3$、情形 (B) 會給你 $0$ 或 $2$（來自前一排），無論如何都不會拿到 $1$，因此可以斷定此時 SG 值 $= 1$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果 $n$ 是奇數、且 $m$ 是奇數：那麼情形 (A) 會給你新的 SG 值 $=1$、且"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"存在一個奇數度數的點（因為總邊數是奇數、且 $G$ 是二部圖），此時情形 (B) 會給你 $0$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"存在一個偶數度數的點（因為總邊數是奇數、且 $G$ 是二部圖，其中一邊一定有偶數個點，每一個點不可能 degree 都為奇數！），此時情形 (B) 會給你 $2$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"綜合以上：無論如何都不會拿到 $3$，因此可以斷定此時 SG 值 $= 3$。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"計算二部圖的數量"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我們先隨便 hold 住一條邊 $e$。然後對於任何生出來的二部圖 $G$，放上這條邊 $G+e$、或不放上這條邊 $G$，它們邊數的奇偶性顯然不同。\n於是我們可以得到一個「一對一關係」：從「所有擁有奇數條邊的圖」對應至「所有擁有偶數條邊的圖」。這說明了兩種圖的數量是相等的～"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"總共有多少種可能的圖呢？對於每一條潛在的邊，可以選、或不選，因此總共的圖的數量是 $2^{\\sum_{i} a_ib_i}$。\n也就是說，當總點數是偶數時，Socket 能夠獲勝的圖的數量恰好有 $2^{\\left(\\sum_{i} a_ib_i\\right) - 1}$ 個！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"#include <bits/stdc++.h>\nusing namespace std;\n\n\ntypedef long long LL;\n\nLL bigmod(LL a, LL n, LL mod) {\n  if (n == 0) return 1%mod;\n  if (n == 1) return a%mod;\n  LL r = bigmod(a*a%mod, n/2, mod);\n  if (n%2) r = r*a%mod;\n  return r;\n}\n\nint main() {\n  const LL mod = 1e9+7;\n  LL ret = 1;\n  int N, total = 0;\n  cin >> N;\n  for (int i = 0; i < N; i++) {\n    LL ai, bi;\n    cin >> ai >> bi;\n    total ^= ((ai%2) ^ (bi%2));\n    ret = ret * bigmod(2, ai*bi-(i==0), mod) % mod;\n  }\n  if (total) cout << 0 << endl;\n  else cout << ret << endl;\n  return 0;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"備註 1"},{"type":"element","tagName":"footnote","properties":{"here":"1"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"英文是 Two players symmetric impartial game。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"備註 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這題有一隊台大的隊伍在現場賽拿到首殺！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"關於競程日記"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"🍅 如果您想到更多有趣漂亮簡單乾淨的解法話歡迎留言給競程日記小編群！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"ℹ️ 這是一篇投稿給"},{"type":"element","tagName":"a","properties":{"href":"https://www.facebook.com/%E7%AB%B6%E7%A8%8B%E6%97%A5%E8%A8%98-1514973425463954/"},"children":[{"type":"text","value":"競程日記"}]},{"type":"text","value":"的文章，歡迎大家投稿、交流與分享程式解題競賽的點點滴滴！"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"Insider's Identity","category":"prob","path":"/problem/icpc/asia_hanoi_2018/I","date":"2019-01-14","_PARENT":"8a4f1202-636c-53f1-8886-08d1aa76858a","description":"在一個遙遠的星球上，一個情報單位打算派遣一些間諜到地球上進行偵查任務。\n為了確保偵查任務能夠在極為機密的情形下進行，情報單位打算指派每一個間諜一個秘密 ID。\n\n每一個 ID 由一個長度為 $n$ 的 01-字串 (binary string) 組成。\n為了避免敵人的滲透，情報單位選擇了一個由 `1` 和 `*` 組成的模版 $P$，如果這個模版能夠成功與 ID 進行配對，那麼就可以判斷這個 ID 為真。\n\n對於一個字串 $S=s_1s_2\\cdots s_n$ 以及一個模版 $P=p_1\\cdots p_m$ 成功配對的定義如下：\n\n* 若 $m = n$，而且對所有 $i$，要嘛 $s_i=$`1` 或 $p_i=$`*`。\n* 若 $m < n$，而且在 $S$ 內部存在一個長度為 $m$ 的子字串成功與 $P$ 配對。\n\n請幫助情報單位計算總共有多少 ID 可以使用。\n","link":"https://open.kattis.com/problems/insidersidentity","code":"ICPC-HANOI-2018-I","difficulty":6,"oj":"kattis","tags":["ICPC 2018 Asia Hanoi Regional"]},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"簡化後題目敘述"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"輸入的第一列包含一個正整數 $n$ $(1\\le n\\le 50)$ 表示 ID 的長度。\n第二列有一個由 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"1"}]},{"type":"text","value":" 和 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"*"}]},{"type":"text","value":" 組成的模版字串 $P$ $(1\\le |P|\\le 30)$，"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸出說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"輸出一個正整數表示長度為 $n$ 且滿足條件 $P$ 的字串數量。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"10 \n1\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"1023\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"3\n1*1\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"2\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ 連結"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://open.kattis.com/problems/insidersidentity"},"children":[{"type":"text","value":"Open Kattis - Insider's Indentity"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"題目出處"}]},{"type":"text","value":"：ICPC 2018 Asia Hanoi Regional"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這題一臉就是動態規劃囉。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"首先，我們可以注意到由於輸入模版的 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"*"}]},{"type":"text","value":" 不超過 15 個，因此全部把他們枚舉出來數量大概不會太多。\n考慮一個字串集合 $\\mathcal{S}$，我們想要知道有多少字串，使得至少有一個子字串出現在 $\\mathcal{S}$ 中，這是一個『試著不要重複計數』的技術問題。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"定義 $\\dp(i, \\mathit{suffix})$ 表示長度為 $i$ 的字串、其後綴字串為 $\\mathit{suffix}$、而且 $\\mathit{suffix}$ 是所有該字串後綴字串之中，出現在 $\\mathrm{prefix}(\\mathcal{S})$ 集合裡面"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"最長"}]},{"type":"text","value":"的那一個。其中 $\\mathrm{prefix}(\\mathcal{S})$ 是所有 $\\mathcal{S}$ 前綴字串所形成的集合。於是，對於每一個 $\\dp(i, \\mathit{suffix})$ 我們可以考慮把該狀態"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"推"}]},{"type":"text","value":"(push)到下一個狀態去"},{"type":"element","tagName":"footnote","properties":{"goto":"1","show":"備註1"},"children":[]},{"type":"text","value":"："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"$\\dp(i+1, \\delta(\\mathit{suffix} + \\texttt{\"0\"})) {\\texttt{ += }} \\dp(i, \\mathit{suffix})$"},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"\n$\\dp(i+1, \\delta(\\mathit{suffix} + \\texttt{\"1\"})) {\\texttt{ += }} \\dp(i, \\mathit{suffix})$"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"而事實上，$\\mathit{suffix} + \\texttt{\"0\"}$ 很可能不復存在於前綴集合 $\\mathrm{prefix}(\\mathcal{S})$ 了。\n因此我們需要一個轉移函數 $\\delta$，它可以幫我們不斷把字串的頭去掉，直到剩下來的字串出現在前綴集合，而此時我們不難證明這個剩下來的字串會是整個長度為 $i+1$ 字串中，最長出現在前綴集合的後綴字串（好拗口|||）"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"最後，如果 $\\mathit{suffix} + \\texttt{\"0\"}$ (或 $\\mathit{suffix} + \\texttt{\"1\"}$) 真的出現在 $\\mathcal{S}$ 裡面了，那麼代表所有落到 $\\dp(i+1, \\mathit{suffix} + \\texttt{\"0\"})$ 的字串都滿足題目要求，我們就直接把這個數量（乘上後面隨意補滿的 01-字串方法數）加到答案裡面，而不用轉移它了。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"為了加快查找的速度，我們可以一開始就把用得到的所有"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"狀態"}]},{"type":"text","value":"與"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"狀態轉移"}]},{"type":"text","value":"儲存下來，並且直接給他們一個編號。如此一來，實際計算動態規劃的轉移部分，可以完全使用陣列處理，提升了不少效率。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"由於每一個 suffix 都是長度不超過 30 的二元字串，我們可以用 $\\left(2^{\\text{suffix 長度}} + \\mathit{suffix}\\right)$ 這個整數來儲存。而轉移、匹配都可以用位元運算來處理。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n\n\nint main() {\n  int n;\n  string S;\n  cin >> n >> S;\n\n  // 枚舉所有可能的前綴集合。\n  vector<int> state_space;\n  function<void(int, int)> dfs = [&](int now, int i) {\n    state_space.push_back(now + (1<<i));\n    if (i + 1 < S.size()) {\n      if (S[i] == '*') dfs(now*2, i+1);\n      dfs(now*2+1, i+1);\n    }\n  };\n  dfs(0, 0);\n  sort(state_space.begin(), state_space.end());\n  state_space.resize(unique(state_space.begin(), state_space.end()) - state_space.begin());\n\n\n  // 產生不同長度的模版，用來比對。\n  vector<int> patterns = {0};\n  for (int i = 0, p = 0; i < (int)S.size(); i++) {\n    p = p * 2 + (S[i] == '1');\n    patterns.push_back(p);\n  }\n  \n  // 計算下一個狀態轉移。\n  const int DONE = -1;\n  auto GetNextValidState = [&](int state) -> int {\n    int len = 31 - __builtin_clz(state);\n    for (int i = len; i >= 0; i--) {\n      if ((state&patterns[i]) == patterns[i]) {\n        if (i == S.size()) {\n          // 如果已匹配整個字串，就可以停下來了。\n          return DONE;\n        } else {\n          // 取得離散化後的狀態編號。\n          int nxt = (1<<i) + (state & ((1<<i)-1));\n          return lower_bound(state_space.begin(), state_space.end(), nxt) - state_space.begin();\n        }\n      }\n    }\n    return 1;\n  };\n\n  // 對所有狀態，列出下一個狀態的編號。\n  vector<int> add0(state_space.size()), add1(state_space.size());\n  for (int i = 0; i < state_space.size(); i++) {\n    int state = state_space[i];\n    add0[i] = GetNextValidState(state*2);\n    add1[i] = GetNextValidState(state*2+1);\n  }\n  \n  // 開始跑動態規劃。\n  LL ans = 0;\n  vector<LL> dp(state_space.size(), 0);\n  dp[0] = 1;\n\n  for (int i = 1; i <= n; i++) {\n    vector<LL> dp_next(state_space.size(), 0);\n    for (int j = 0; j < state_space.size(); j++) {\n      if (add0[j] == DONE)\n        ans += dp[j] * (1LL<<(n-i));\n      else\n        dp_next[add0[j]] += dp[j];\n      if (add1[j] == DONE)\n        ans += dp[j] * (1LL<<(n-i));\n      else\n        dp_next[add1[j]] += dp[j];\n    }\n    dp.swap(dp_next);\n  }\n  cout << ans << endl;\n  return 0;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"關於競程日記"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"🍅 如果您想到更多有趣漂亮簡單乾淨的解法話歡迎留言給競程日記小編群！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"ℹ️ 這是一篇投稿給"},{"type":"element","tagName":"a","properties":{"href":"https://www.facebook.com/%E7%AB%B6%E7%A8%8B%E6%97%A5%E8%A8%98-1514973425463954/"},"children":[{"type":"text","value":"競程日記"}]},{"type":"text","value":"的文章，歡迎大家投稿、交流與分享程式解題競賽的點點滴滴！"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"最小費用流的消圈演算法","category":"algo","path":"/algo/min-cost-max-flow-cycle-cancellation","date":"2018-11-20","_PARENT":"9f394bd1-5ad6-544c-9714-9f4d7851f260","description":null,"link":null,"code":null,"difficulty":null,"oj":null,"tags":null},"htmlAst":{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"剩餘網路 Residual Networks"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"要討論網路流，就必須要討論剩餘網路（residual networks）。如果我們在圖 $G$ 上面有一個流 $f$，那我們可以定義一個剩餘網路 $G_f$，代表有哪些地方還有空間推進更多的網路流。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"最小費用流在剩餘網路上會長什麼樣子呢？很幸運地，Klein 在 1967 年為我們證明了以下定理："}]},{"type":"element","tagName":"theorem","properties":{"title":"負圈定理"},"children":[{"type":"text","value":"\n$f$ 是最佳解若且唯若 $G_f$ 上面定義 cost 為權重時，不存在一個負圈。\n"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"證明"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"\"$\\Rightarrow$\":"},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"\n如果 $G_f$ 上面存在一個負圈，那麼沿著這個負圈增廣，會得到總花費更小的解，與 $f$ 最佳解的假設矛盾。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"\"$\\Leftarrow$\":"},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"\n如果 $f$ 不是最佳解，那我們考慮真正的最佳解 $f^\\star$。考慮兩個解的差異 $f'=f^\\star - f$，不難推敲得知 $f'$ 的所有邊都會出現在 $G_f$ 上面。由於 $f'$ 是一個可行流，我們可以將 $f'$ 拆成許多圈的疊加。但是因為 $cost(f')$ 帶來的總花費是負的（因為 $cost(f') = cost(f^\\star) - cost(f) < 0$），所以至少有一個圈帶來的花費也是負的。得證。"}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"消圈演算法 Cycle Cancellation Algorithms"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這個演算法是由 Klein [1967] 從 Ford-Fulkerson 網路流演算法得來的想法，以迭代的方式不斷地更新當前找到的解，直到滿足最佳解條件為止。"},{"type":"element","tagName":"sup","properties":{"id":"fnref-2"},"children":[{"type":"element","tagName":"a","properties":{"href":"#fn-2","className":["footnote-ref"]},"children":[{"type":"text","value":"2"}]}]}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"f = 空的網路流\nwhile 剩餘網路 G_f 上面存在負圈:\n    令 C 為任何一個負圈\n    令 Δ 為這個負圈上能推的最大流量\n    更新 f = f + CΔ\n"}]}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"時間複雜度"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如同 Ford-Fulkerson 演算法一般，在所有 cost 和 capacity 都是整數的時候，每一次消圈，只能夠保證總花費至少降低了 1 單位。顯然最小的總花費值比 $-mCU$ 來得大，所以我們可以得知迭代消圈的次數至多為 $O(mCU)$。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"而找負圈的演算法則可以使用 Bellman-Ford 演算法，所需時間為 $O(nm)$。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"因此整體的時間複雜度是 $O(nm^2CU)$，由於 $C$ 和 $U$ 僅是數值，相對於輸入規模而言是指數級別的，在數值較大時效率不甚理想。"}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"更快的消圈算法"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"從計算最大網路流的演算法當中，當我們每次找出剩餘網路圖上最寬的增廣路徑時，這條增廣路徑至少可以推進 ${\\mathbf{MaxFlow}}(G_f)/m$ 的流量。這麼一來，在所有容量限制都是整數的情況下，增廣的次數上界可以從原本 Ford-Fulkerson 演算法的 ${\\mathbf{MaxFlow}}(G)$ 降低至 $O(m\\log_2 {\\mathbf{MaxFlow}}(G))$。這個值以輸入的資料量而言，就是多項式了。"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"最負圈 Most Negative Cycle"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"消圈算法是否也有同樣的特性呢？答案是有的，我們可以用一模一樣的方式證明，如果每一次我們找出那個「最負的負圈」，那麼總 cost 會向目標邁進至少 $O(1/m)$ 的比例。採用了這個方法的話，我們就可以讓消圈次數限制在 $O(m\\log_2|{\\mathbf{MinCost}}(G)|)$，是為多項式。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"但是，找出「最負的負圈」對於輸入是任意圖的情形下，是 NP-Hard 的。目前我們仍不知道有沒有有效率的多項式演算法來找出它。於是 Goldberg 跟 Tarjan 於 1989 年發現，每一次不見得要找「最負的負圈」，只要「足夠負」就可以有一樣的效果！他們利用了 Karp 在 1978 年提出的「最小均值圈」演算法，每一次找出「平均花費最負的圈」進行增廣，就可以達到一樣的效果啦。"}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"最小均值圈"}]},{"type":"element","tagName":"theorem","properties":{"title":"最小均值圈 [Karp 1978]"},"children":[{"type":"text","value":"\n設 $G$ 為有向有權圖。定義 $\\hat{G}$ 為 $G$ 外加上一點 $s$ 並從 $s$ 到每一點分別加上一條權重為 0 的邊。令 $d_k(v)$ 為從 $s$ 出發經過恰好 $k$ 條邊抵達點 $v$ 的最小總權重和。則最小均值圈的平均值 $\\lambda^*$ 滿足\n$$\n\\lambda^* = \\min_v \\max_{1\\le k \\le n-1} \\frac{d_n(v) - d_k(v)}{n-k}\n$$\n"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Karp 的證明"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"首先我們先證明，如果 $\\lambda^*=0$，那麼上面這個式子右半邊的值恰好會是 $0$："}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果 $\\lambda^*=0$，那麼這個圖一定不存在負圈。既然不存在負圈，我們就可以定義最短路徑（可以參考 Edmonds-Karp）。定義 $\\mathrm{dist}(s, v)$ 為 $s$ 到 $v$ 的最短路徑長度。顯然對於所有點 $v$ 和正整數 $k$，$d_n(v) \\ge d_k(v)$。此外必定存在某個 $k$ 使得 $d_k(v) = \\mathrm{dist}(s, v)$。因此，對所有 $v$ 來說，$\\max_{1\\le k \\le n-1} \\frac{d_n(v) - d_k(v)}{n-k} \\ge 0$。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"得知右半邊的式子永遠非負以後，剩下的任務就是要證明真的存在一組 $v, k$ 使得 $d_n(v) = d_k(v)$。令 $C$ 為總和是 $0$ 的圈，由於 $\\lambda^*=0$，在這個圈上任何兩點之間的最短路徑，必定等於這個圈上從一點走到另一點的距離（如果更短的話就有負圈啦）。考慮 $s$ 到這個 $C$ 上面任一點 $x$ 的最短路徑，這條路徑必定用掉不超過 $n-1$ 條邊。然後我們從 $x$ 開始沿著這個圈 $C$ 走，直到補足 $n$ 條邊為止。假設最後停在 $y$ 這個點。那麼，我們要說的是 $d_n(y) = \\mathrm{dist}(s, y)$，因為："}]},{"type":"text","value":"$$\n\\begin{align*}\n\\mathrm{dist}(s, y) & \\le d_n(y) \\\\\n& \\le \\mathrm{dist}(s, x) + \\mathrm{dist}(x, y) \\\\\n& \\le \\mathrm{dist}(s, y) + \\mathrm{dist}(y, x) + \\mathrm{dist}(x, y) \\\\\n& \\le \\mathrm{dist}(s, y) + 0\n\\end{align*}\n$$"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"所以，$y$ 這個點達到了最小值 $0$。於是當 $\\lambda^*=0$ 時等式成立。\n要怎利用這個證明推導出對所有的 $\\lambda^*$ 都正確呢？注意到我們可以同時對所有的邊「平移」（同時加上一個常數 $c$）而這件事情會使得所有圈的平均值都一起「平移」$c$，同時也讓式子右邊「平移」了 $c$。因此對於任意 $\\lambda^*$ 我們只要平移它到 $0$，再運用上述的證明，再平移回來，就行啦！證明完畢。"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"關於演算法"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"最直接的方法就是直接用 $O(mn)$ 動態規劃計算出所有 $d_k(v)$ 的值，其他演算法我們可以改天聊。至於要找出實際的圈，我們可以先從上面的計算找出得到最佳值的 $v, k$，然後找出從 $s$ 到 $v$ 走恰好 $n$ 步的最小路徑，這個路徑上的任何一個 cycle 都是最小均值圈"},{"type":"element","tagName":"sup","properties":{"id":"fnref-4"},"children":[{"type":"element","tagName":"a","properties":{"href":"#fn-4","className":["footnote-ref"]},"children":[{"type":"text","value":"4"}]}]},{"type":"text","value":"。"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"應用到消圈算法"}]},{"type":"element","tagName":"theorem","properties":{"title":"最小均值消圈定理 [Goldberg-Tarjan 1989]"},"children":[{"type":"text","value":"\n如果每次從剩餘網路中增廣最小均值圈，那麼保證消圈的迭代次數不超過 $O(\\min\\{mn\\log(nC), m^2n\\log n\\})$ 次。\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"證明的步驟簡述如下。完整的證明可以在這份 Note "},{"type":"element","tagName":"sup","properties":{"id":"fnref-7"},"children":[{"type":"element","tagName":"a","properties":{"href":"#fn-7","className":["footnote-ref"]},"children":[{"type":"text","value":"7"}]}]},{"type":"text","value":" 找到。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"概念1"}]},{"type":"text","value":": 如果 $G_f$ 上面有負圈，那麼對於 $G_f$ 上面的最小均值圈，其平均也是負的。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"概念2"}]},{"type":"text","value":": 我們定義 $\\mu(f)$ 表示為將 $G_f$ 的最小均值圈變成非負的最小平移常數。（也就是說，最小均值圈的平均值為 $-\\mu(f)$）"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"概念3"}]},{"type":"text","value":": 對於任何勢能函數（或距離函數）$d$，我們定義等效邊權 $cost^d(u, v) = cost(u, v) + d(u) - d(v)$。不難發現，對於任何一個圖上的圈來說，其邊權的和總是等於等效邊權的和。也就是說，這樣的轉換並不會影響最小均值圈的數值。但可以藉此調整一些邊的權重。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"概念4"}]},{"type":"text","value":": 我們定義 $-\\epsilon(f)$ 表示對於任意函數 $d$ 定義出的等效邊權中，最小權重最大者。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"概念5"}]},{"type":"text","value":": 注意到，如果這個圖的最小均值圈是 $-\\mu(f)$ 的話，無論我們怎麼調整函數 $d$，調整後最小的那條邊一定小於平均。因此有 $-\\epsilon(f) \\le -\\mu(f)$。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"概念6"}]},{"type":"text","value":": 相反地，若考慮平移後的圖 $G_f+\\mu(f)$，我們可以在上面定義一個距離函數 $d$，使得對所有 $(u, v)\\in G_f$ 我們都有 $d(u) + cost(u, v) \\ge d(v)$。也就是等效邊權 $cost^d(u, v)\\ge 0$。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"概念7"}]},{"type":"text","value":": 把上面這個做出來的 $d$ 再減去 $\\mu(f)$，得到一個勢能函數（或距離函數），其等效邊權 $cost^{d-\\mu(f)}(u, v) \\ge -\\mu(f)$。於是我們有 $-\\epsilon(f) \\ge -\\mu(f)$。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"概念8"}]},{"type":"text","value":": 綜合概念 5 與 7 我們可以得到 $\\mu(f)=\\epsilon(f)$。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"概念9"}]},{"type":"text","value":": 現在固定一個 $f$，以及一個可以得出最佳等效距離的函數 $d$。假設在 $G_f$ 上面消完一個最小均值圈以後，得到的新的流是 $f'$。我們想要說兩件事情："}]},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"$\\epsilon(f') \\le \\epsilon(f)$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"如果消的圈上存在一條正的等效邊，那麼 $\\epsilon(f') \\le \\left(1-\\frac{1}{n}\\right)\\epsilon(f)$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"假設我們增廣後仍暫時使用同樣的 $d$ 函數。那麼連續 $m$ 次增廣之內，一定會消到一個圈使得某條以 $d$ 為基準的等效邊是非負的，於是 2. 成立。"}]},{"type":"text","value":"\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"概念10"}]},{"type":"text","value":": 因此，一開始 $\\epsilon(f_{始})\\le C$，經過 $mn\\ln {nC}$ 次增廣以後 $\\epsilon(f_{終}) < \\left(1-\\frac{1}{n}\\right)^{n\\ln {nC}} C \\le \\frac{1}{n}$。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"概念11"}]},{"type":"text","value":": 如果所有容量和花費都是整數，那麼當最小均值圈 $> -\\frac{1}{n}$ 的時候，就代表它 $\\ge 0$。此時消圈算法就會停止。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"除了 "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"概念9"}]},{"type":"text","value":" 的 1. 和 2. 需要額外證明以外，上面的論述基本上就是全部的證明了。耶！搞定！"}]},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"結論"}]},{"type":"text","value":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"type":"element","tagName":"table","properties":{},"children":[{"type":"element","tagName":"thead","properties":{},"children":[{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"th","properties":{},"children":[{"type":"text","value":"演算法"}]},{"type":"element","tagName":"th","properties":{},"children":[{"type":"text","value":"消圈的次數"}]},{"type":"element","tagName":"th","properties":{},"children":[{"type":"text","value":"每一次消圈的時間"}]},{"type":"element","tagName":"th","properties":{},"children":[{"type":"text","value":"Weakly-Polynomial Worst-Case Complexity"}]},{"type":"element","tagName":"th","properties":{},"children":[{"type":"text","value":"Strongly-Polynomial Worst-Case Complexity"}]}]}]},{"type":"element","tagName":"tbody","properties":{},"children":[{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"element","tagName":"nobr","properties":{},"children":[{"type":"text","value":"Goldberg and Tarjan [1989]"}]},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"每次消最小均值圈"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(nm \\log (nC))$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(nm)$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(n^2m^2\\log (nC))$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(n^2m^3)$"}]}]},{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"element","tagName":"nobr","properties":{},"children":[{"type":"text","value":"Goldberg and Tarjan [1989]"}]},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"每次找所有簡化邊權重為負的圈"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(nm \\log (nC))$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(\\log n)$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(nm\\log n\\log (nC))$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(nm^2\\log^2n)$"}]}]},{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"element","tagName":"nobr","properties":{},"children":[{"type":"text","value":"Barahona and Tardos [1989]"}]},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"每次找一票點不重複的負圈然後增廣"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(m \\log (nCU))$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(nm+n^2\\log n)$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O((nm^2+mn^2\\log n)\\log(nCU)$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"N/A"}]}]},{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"element","tagName":"nobr","properties":{},"children":[{"type":"text","value":"Rock [1991]"}]},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"每次找剩餘流量足夠大的負圈"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(m \\log U)$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(nm)$ 或 $O(m+n\\log n)$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(nm^2\\log U)$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"N/A"}]}]},{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"element","tagName":"nobr","properties":{},"children":[{"type":"text","value":"Wallacher [1991]"}]},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"每次找最負比重負圈"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(m \\log (nCU))$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(n^3\\log^2 n)$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(n^3m\\log^2 n\\log(nCU))$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"N/A"}]}]},{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"element","tagName":"nobr","properties":{},"children":[{"type":"text","value":"Shigeno, Iwata and McCormick [1996]"}]},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"最負圈鬆弛演算法"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(nm \\log (nC))$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(nm+n^2\\log n)$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(n^2m^2\\log (nC)$ $+$ $n^3m\\log n\\log (nC))$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(n^2m^3\\log n$ $+$ $n^3m^2\\log n)$"}]}]},{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"element","tagName":"nobr","properties":{},"children":[{"type":"text","value":"Shigeno, Iwata and McCormick"},{"type":"element","tagName":"sup","properties":{"id":"fnref-3"},"children":[{"type":"element","tagName":"a","properties":{"href":"#fn-3","className":["footnote-ref"]},"children":[{"type":"text","value":"3"}]}]},{"type":"text","value":" [1996]"}]},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"最負圈縮放代價演算法"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(nm \\log C)$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(\\log n)$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(nm\\log C \\log n)$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"N/A"}]}]},{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"element","tagName":"nobr","properties":{},"children":[{"type":"text","value":"Sokkalingam, Ahuja and Orlin [1997]"}]},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"每次找剩餘流量足夠大的負圈"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(m \\log C)$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(m+n\\log n)$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(m^2\\log C$ $+$ $nm\\log C\\log n)$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(m^3\\log n$ $+$ $nm^2\\log^2 n)$"}]}]}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"small","properties":{},"children":[{"type":"text","value":"資料來源： Sokkalingam, Ahuja, Orlin, "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"New Polynomial-Time Cycle-Cancelling Algorithms for Minimum Cost Flows"}]},{"type":"text","value":", 1997. "},{"type":"element","tagName":"sup","properties":{"id":"fnref-1"},"children":[{"type":"element","tagName":"a","properties":{"href":"#fn-1","className":["footnote-ref"]},"children":[{"type":"text","value":"1"}]}]}]}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"參考資料"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{"className":["footnotes"]},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{"id":"fn-1"},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://pdfs.semanticscholar.org/f799/350ee4b93f02e672157d54ee06849edb7355.pdf"},"children":[{"type":"text","value":"Sokkalingam, Ahuja, Orlin, "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"New Polynomial-Time Cycle-Cancelling Algorithms for Minimum Cost Flows"}]},{"type":"text","value":", 1997."}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"a","properties":{"href":"#fnref-1","className":["footnote-backref"]},"children":[{"type":"text","value":"↩"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{"id":"fn-2"},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://www2.cs.duke.edu/courses/fall15/cps232/scribe_notes/lec05.pdf"},"children":[{"type":"text","value":"Duke University COMPSCI532 Fall 2015 Scribe Notes"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"a","properties":{"href":"#fnref-2","className":["footnote-backref"]},"children":[{"type":"text","value":"↩"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{"id":"fn-3"},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://www.jstor.org/stable/3690424?seq=1"},"children":[{"type":"text","value":"Shigeno, Iwata and McCormick, "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"Relaxed Most Negative Cycle and Most Positive Cut Canceling Algorithms for Minimum Cost Flow"}]},{"type":"text","value":", Mathematics of Operations Research 2000"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"a","properties":{"href":"#fnref-3","className":["footnote-backref"]},"children":[{"type":"text","value":"↩"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{"id":"fn-4"},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"http://www.cs.colostate.edu/~rmm/minCycleMean.pdf"},"children":[{"type":"text","value":"Colorado State University 最小均值圈講義"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"a","properties":{"href":"#fnref-4","className":["footnote-backref"]},"children":[{"type":"text","value":"↩"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{"id":"fn-5"},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"http://www.columbia.edu/~cs2035/courses/ieor6614.S16/mmc.pdf"},"children":[{"type":"text","value":"Columbia University 最小均值圈投影片"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"a","properties":{"href":"#fnref-5","className":["footnote-backref"]},"children":[{"type":"text","value":"↩"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{"id":"fn-6"},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://people.orie.cornell.edu/dpw/orie633/LectureNotes/lecture12.pdf"},"children":[{"type":"text","value":"Cornell University 的 Goldberg-Tarjan 演算法講義"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"a","properties":{"href":"#fnref-6","className":["footnote-backref"]},"children":[{"type":"text","value":"↩"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{"id":"fn-7"},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-854j-advanced-algorithms-fall-2008/lecture-notes/lec4.pdf"},"children":[{"type":"text","value":"MIT開放課程講義：Goldberg-Tarjan 演算法分析"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"a","properties":{"href":"#fnref-7","className":["footnote-backref"]},"children":[{"type":"text","value":"↩"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]}]}}},{"node":{"frontmatter":{"title":"SnackDown19 Elimination Round","category":"cp","path":"/cp/snckel19","date":"2018-12-08","_PARENT":"61db7e5a-936e-5da1-8d9e-f795244b3de6","description":null,"link":"https://www.codechef.com/SNCKEL19","code":null,"difficulty":null,"oj":null,"tags":null},"htmlAst":{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"唉唉，今天狀況超級不對啊。整個就是撞牆卡在 Suffix Palindrome 完全寫不出來，然後到了快三個半鐘頭才想到 Lighting Rectangle 要怎麼寫，還錯了一次，真是奇慘無比。"}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Lighting Rectangle "},{"type":"element","tagName":"a","properties":{"href":"https://www.codechef.com/SNCKEL19/problems/RECTLIT"},"children":[{"type":"text","value":"RECTLIT"}]}]},{"type":"element","tagName":"theorem","properties":{"c":"is-info"},"children":[{"type":"text","value":"\n在一個二維座標平面上有一個 $(0, 0)$ 到 $(N-1, N-1)$ 的正方形。在這個正方形區域內有 $K$ 盞燈。對於每一盞燈而言，這盞燈為原點可以把整個平面分成四個象限。而你可以為每一盞燈選擇照亮其中一個象限（在邊界上也算是有被照亮）。現在給你這 $K$ 盞燈的位置，是否存在一種方法，讓它們可以照亮整個正方形的範圍呢？\n"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"簡單來說就是分 Case 題："}]},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"在內部如果有四個點，那麼存在一種方式可以照亮所有區域。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"如果角落有一個點，那麼一定可以照亮所有區域。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"把邊分成上下、跟左右兩個部份。如果其中一個部份有兩個點，那可以照亮所有區域。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"如果邊上有一個點、而且內部有至少兩個點，那麼可以照亮所有區域。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"如果邊上有兩個點、而且內部至少有一個點，那麼可以照亮所有區域。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"除了以上情形外，其他情形都無法照亮所有區域。"}]},{"type":"text","value":"\n"}]},{"type":"element","tagName":"style","properties":{},"children":[{"type":"text","value":"\n#outer-rect {\n     stroke-width: 4;\n}\n.blue.quadrant.region {\n    fill: rgba(0,0,255,0.3);\n}\n.blue.quadrant.origin {\n    fill: blue;\n}\n.blue.quadrant.boundary.start,\n.blue.quadrant.boundary.end {\n    stroke-width: 2;\n    stroke: rgba(0,0,255,0.6);\n}\n.red.quadrant.region {\n    fill: rgba(255, 0, 0, 0.3);\n}\n.red.quadrant.origin {\n    fill: darkred;\n}\n.red.quadrant.boundary.start,\n.red.quadrant.boundary.end {\n    stroke-width: 2;\n    stroke: rgba(200,0,0,0.6);\n}\n.yellow.quadrant.region {\n    fill: rgba(255, 255, 0, 0.3);\n}\n.yellow.quadrant.origin {\n    fill: gold;\n}\n.yellow.quadrant.boundary.start,\n.yellow.quadrant.boundary.end {\n    stroke-width: 2;\n    stroke: rgba(233,233,0,0.6);\n}\n"}]},{"type":"element","tagName":"mysvg","properties":{"width":300,"height":200,"viewbox":"-10 -10 330 230"},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"rect","properties":{"x":"0","y":"0","width":300,"height":200,"fill":"none","stroke":"black","id":"outer-rect"},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"display-inner","properties":{"quadrant":"","dotAtOrigin":"","x":"90","y":"70","r":"600","angleStart":"0","angleEnd":"90","boundaryAtStart":"","boundaryAtEnd":"","c":"blue","clipHref":"#outer-rect"},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"display-inner","properties":{"quadrant":"","dotAtOrigin":"","x":"160","y":"120","r":"600","angleStart":"270","angleEnd":"360","boundaryAtStart":"","boundaryAtEnd":"","c":"red","clipHref":"#outer-rect"},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"display-inner","properties":{"quadrant":"","dotAtOrigin":"","x":"185","y":"90","r":"600","angleStart":"180","angleEnd":"270","boundaryAtStart":"","boundaryAtEnd":"","c":"yellow","clipHref":"#outer-rect"},"children":[]},{"type":"text","value":"\n"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"// by tmt514\n#include <cstdio>\nusing namespace std;\n\nvoid solve() {\n  int K, N;\n  scanf(\"%d%d\", &K, &N);\n  int ncorner = 0;\n  int nsidex = 0;\n  int nsidey = 0;\n  int ninside = 0;\n  for(int i=0;i<K;i++) {\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    int sx = (x==0 || x==N-1);\n    int sy = (y==0 || y==N-1);\n    if(sx && sy) { ncorner++; }\n    else if(sx) { nsidex++; }\n    else if(sy) { nsidey++; }\n    else ninside++;\n  }\n  if (ncorner==0 && nsidex==1 && nsidey==1 && ninside==0) puts(\"no\");\n  else\n  puts(4*ncorner + 2*nsidex + 2*nsidey + ninside >= 4? \"yes\": \"no\");\n}\n\nint main(void) {\n  int T;\n  scanf(\"%d\", &T);\n  while(T--) solve();\n  return 0;\n}\n"}]}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Suffix Palindromes "},{"type":"element","tagName":"a","properties":{"href":"https://www.codechef.com/SNCKEL19/problems/SFXPAL"},"children":[{"type":"text","value":"SFXPAL"}]}]},{"type":"element","tagName":"theorem","properties":{"c":"is-info"},"children":[{"type":"text","value":"\n考慮大小恰好為 $S$ 的字母集。請問有多少長度為 $N$ 的字串，其所有後綴字串都不是迴文？輸出答案除以 $M$ 的餘數。($1\\le N\\le 1000, 1\\le S\\le M-1 < 2^{30}-1$)\n"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這是一道很漂亮的 DP 題。假設 $f(n)$ 是答案，那麼每個字串的最後 $n-1$ 個字元都會被算入 $f(n-1)$。所以我們可以嘗試扣除掉加了一個字元以後會變成迴文的可能情形。而利用迴文的特性，我們可以證明在「加了一個字以後變成迴文」的當下，所有可能的迴文只能是來自 $f(\\lceil n/2\\rceil)$。所以，可以從 $f(1)=S$ 開始，依序計算 $f(n) = Sf(n-1) - f(\\lceil n/2\\rceil)$。"}]},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"display","properties":{"array":"","data":"[\"S\", \"---------f(n-1) 之中的答案---------\"]"},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"display","properties":{"array":"","data":"[\"--反過來的 f(n/2)--\", \"------f(n/2)------\"]"},"children":[]},{"type":"text","value":"    "}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"// by tmt514\n#include <iostream>\n#include <vector>\nusing namespace std;\ntypedef long long LL;\n\nint main(void) {\n  LL N, S, M;\n  cin >> N >> S >> M;\n  vector<LL> dp(N+1);\n  dp[0] = 1;\n  dp[1] = S;\n  for (int i = 2; i <= N; i++) {\n    dp[i] = S*dp[i-1] - dp[(i+1)/2];\n    dp[i] = (dp[i]%M+M)%M;\n  }\n  cout << dp[N] << endl;\n  return 0;\n}\n"}]}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Adi and the Tree "},{"type":"element","tagName":"a","properties":{"href":"https://www.codechef.com/SNCKEL19/problems/ADITREE"},"children":[{"type":"text","value":"ADITREE"}]}]},{"type":"element","tagName":"theorem","properties":{"c":"is-info"},"children":[{"type":"text","value":"\n在一個有 $N$ 個節點的樹上，進行 $M$ 項操作。一開始所有的節點都是「關燈」的狀態。每一次操作會給你兩個點 $a, b$。然後你把點 $a$ 與點 $b$ 切換其「開/關燈」狀態。接著，每一個操作結束之後，請你幫所有亮著的燈的節點兩兩配成一對，使得配對的節點距離總和最小。每次操作後，都輸出配對後的最小總和。$(1\\le N, M\\le 250000)$\n"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"另一個乾淨的漂亮問題。這題的主要觀察點在於：最小的距離總和，恰好等於所有「子樹中有奇數個亮燈」節點的數量。所以我們只需要維護一個資料結構，使得每次更新兩個點後，順便更新節點的奇偶性就行了！"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"要怎麼動態更新節點的奇偶性呢？我們可以利用樹鍊剖分，把一棵樹分成許多路徑，使得任何一個節點到樹根的路上至多只跨越 $O(\\log N)$ 條路徑。我們在每一條路徑上面維護一個線段樹，因此總時間複雜度是 $O(N+M\\log^2 N)$。"}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"// by tmt514\n#include <algorithm>\n#include <cstdio>\n#include <vector>\nusing namespace std;\n\nstruct SegNode {\n  int odd, even;\n  bool inverted;\n};\n\nclass SegmentTree {\n  public:\n    vector<SegNode> seg;\n    void init(int x, int l, int r) {\n      if (l == r) seg[x] = (SegNode){0, 1, false};\n      else {\n        int m = (l+r)/2;\n        init(x*2, l, m);\n        init(x*2+1, m+1, r);\n        seg[x] = (SegNode){0, r-l+1, false};\n      }\n    }\n    void init(int n) {\n      seg.resize(4*n);\n      init(1, 1, n);\n    }\n    void push(int x, int l, int r) {\n      if (l == r) { seg[x].inverted = false; }\n      else if (seg[x].inverted) {\n        swap(seg[x*2].odd, seg[x*2].even);\n        swap(seg[x*2+1].odd, seg[x*2+1].even);\n        seg[x*2].inverted ^= 1;\n        seg[x*2+1].inverted ^= 1;\n        seg[x].inverted = false;\n      }\n    }\n    void pull(int x) {\n      seg[x].odd = seg[x*2].odd + seg[x*2+1].odd;\n      seg[x].even = seg[x*2].even + seg[x*2+1].even;\n      if (seg[x].inverted) swap(seg[x].odd, seg[x].even);\n    }\n    void toggle(int x, int l, int r, int target) {\n      if (r <= target) {\n        swap(seg[x].odd, seg[x].even);\n        seg[x].inverted ^= 1;\n      } else {\n        int m = (l+r)/2;\n        push(x, l, r);\n        toggle(x*2, l, m, target);\n        if (target > m) toggle(x*2+1, m+1, r, target);\n        pull(x);\n      }\n    }\n    int ask(int x, int l, int r, int target) {\n      if (r <= target) {\n        return seg[x].odd;\n      } else {\n        int m = (l+r)/2;\n        push(x, l, r);\n        return seg[x*2].odd + ask(x*2+1, m+1, r, target);\n      }\n    }\n};\n\nconst int N = 250000;\nvector<int> a[N];\n\nint total_odd[N];\nint parent[N];\nint depth[N];\nint child[N];\nint segtree_idx[N];\nint segtree_seq[N];\nSegmentTree t[N];\nint segtree_root[N];\n\nvoid find_depth_dfs(int x, int p=-1) {\n  parent[x] = p;\n  depth[x] = 1;\n  for(auto y : a[x]) {\n    if (y != p) {\n      find_depth_dfs(y, x);\n      if(depth[y]+1 > depth[x]) {\n        depth[x] = depth[y]+1;\n        child[x] = y;\n      }\n    }\n  }\n}\n\nint all_segids = 0;\nvoid build_segment_tree(int x, int segid=0, int d=1) {\n  segtree_idx[x] = segid;\n  segtree_seq[x] = d;\n  if (d == 1) {\n    segtree_root[segid] = x;\n    t[segid].init(depth[x]);\n  }\n  for (auto y : a[x]) {\n    if (y == parent[x]) continue;\n    if (y == child[x]) build_segment_tree(y, segid, d+1);\n    else {\n      all_segids++;\n      build_segment_tree(y, all_segids, 1);\n    }\n  }\n}\n\n// 找出修改狀態時會經過的每一條鍊，我們把每一條鍊的進入點蒐集起來。\nvoid toggle(int x) {\n  vector<int> tree_ids;\n  int c = x;\n  while (c != -1) {\n    tree_ids.push_back(c);\n    c = parent[segtree_root[segtree_idx[c]]];\n  }\n  int delta = 0;\n  for (auto c : tree_ids) {\n    auto& tree = t[segtree_idx[c]];\n    delta -= tree.seg[1].odd;\n    tree.toggle(1, 1, depth[segtree_root[segtree_idx[c]]], segtree_seq[c]);\n    delta += tree.seg[1].odd;\n    total_odd[segtree_root[segtree_idx[c]]] += delta;\n  }\n}\n\nint main(void) {\n  int n, m;\n  // 處理第一部份的輸入：紀錄整棵樹的訊息。\n  scanf(\"%d\", &n);\n  for(int i=0;i<n-1;i++) {\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    a[x].push_back(y);\n    a[y].push_back(x);\n  }\n  // 用 DFS 連結每個節點至高度最高的子節點。\n  find_depth_dfs(1);\n  \n  // 對於每一條鍊，初始化一個相應大小的線段樹。\n  build_segment_tree(1);\n\n  // 處理第二部分輸入：對於一次輸入的兩個點 A, B，改變其燈號狀態。\n  scanf(\"%d\", &m);\n  while(m--) {\n    int A, B;\n    scanf(\"%d%d\", &A, &B);\n    toggle(A);\n    toggle(B);\n    printf(\"%d\\n\", total_odd[1]);\n  }\n\n  return 0;\n}\n"}]}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"其他推薦題解"}]},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://blog.csdn.net/qq_39972971/article/details/84922322"},"children":[{"type":"text","value":"cz_xuyixuan 博客"}]}]},{"type":"text","value":"\n"}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Recover Square "},{"type":"element","tagName":"a","properties":{"href":"https://www.codechef.com/SNCKEL19/problems/RECOVER"},"children":[{"type":"text","value":"RECOVER"}]}]},{"type":"element","tagName":"theorem","properties":{"c":"is-info"},"children":[{"type":"text","value":"\n在一個 $N\\times N$ 大小的網格中，每一格恰有一個不同的、介於 $1$ 到 $N\\cdot N$ 的數字。如果我們把"},{"type":"element","tagName":"b","properties":{},"children":[{"type":"text","value":"所有"}]},{"type":"text","value":"曼哈頓距離是 $1$ 或 $2$ 的格子對寫下來（總共有 $M$ 個這樣的配對），請問你是否能回溯出原本的網格？($1\\le N\\le 200$，一個輸入檔中有 $1\\le T\\le 200$ 筆測試資料。)\n"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"感覺就是從角落用拼拼圖的方式一個一個把它拼起來。可能有點麻煩就是了..."}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Adi and the Matrix "},{"type":"element","tagName":"a","properties":{"href":"https://www.codechef.com/SNCKEL19/problems/ADIMAT"},"children":[{"type":"text","value":"ADIMAT"}]}]},{"type":"element","tagName":"theorem","properties":{"c":"is-info"},"children":[{"type":"text","value":"\n對於兩個矩陣而言，若重排一些行、然後再重排一些列之後變成相等的矩陣，那我們就說這兩個矩陣同構。請問有多少種大小為 $2^{N\\times M}$ 的不同構 0/1-矩陣？輸出答案除以 $10^9+7$ 的餘數。($1\\le N\\times M\\le 550$)\n"}]}]}}},{"node":{"frontmatter":{"title":"Amazing Adventures","category":"prob","path":"/problem/icpc/asia_hanoi_2018/A","date":"2019-01-08","_PARENT":"e75f9cb1-c823-5bf1-a254-1dd09d6c4aa7","description":"在一個有 $N$ 列、$M$ 行的方格上，有四個英文字母 `B`, `C`, `G`, `U`。請你找出最短的、從 `B` 經過 `C` 到 `G` 但是不包括 `U` 的路徑，使得每一個格子（包含起點與終點）都不能重複經過。輸出這個路徑。\n","link":"https://open.kattis.com/problems/amazingadventures","code":"ICPC-HANOI-2018-A","difficulty":7,"oj":"kattis","tags":["ICPC 2018 Asia Hanoi Regional","graph modeling","min-cost max-flow"]},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"簡化後題目敘述"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"輸入包含多組測試資料，並以 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"0 0"}]},{"type":"text","value":" 作結束。每一筆測試資料包含 6 列："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"第一列有兩個正整數 $N, M$ （$1\\le M, N\\le 100$）"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"第二列有兩個正整數 $r_B, c_B$，表示英文字母 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"B"}]},{"type":"text","value":" 的位置。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"第三列有兩個正整數 $r_C, c_C$，表示英文字母 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"C"}]},{"type":"text","value":" 的位置。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"第四列有兩個正整數 $r_G, c_G$，表示英文字母 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"G"}]},{"type":"text","value":" 的位置。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"第五列有兩個正整數 $r_U, c_U$，表示英文字母 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"U"}]},{"type":"text","value":" 的位置。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"第六列為空白列。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"輸入保證 $1\\le r_B, r_C, r_G, r_U \\le N$ 且 $1\\le c_B, c_C, c_G, c_U\\le M$ 而且四個英文字母的位置不會重疊。\n所有輸入的 $N\\times M$ 加起來不會超過 $10^5$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"請注意：列的編號"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"從下往上"}]},{"type":"text","value":"編號為 1 到 $N$；行的編號"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"從左往右"}]},{"type":"text","value":"編號為 1 到 $M$。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸出說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"對於每一筆測試資料輸出 1 或 2 列。\n首先輸出是否存在滿足題目要求的路徑（"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"YES"}]},{"type":"text","value":" 或 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"NO"}]},{"type":"text","value":"）。如果答案是 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"YES"}]},{"type":"text","value":"，在第二列輸出任何一個滿足條件的最短路徑。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"3 3\n1 1\n3 3\n2 1\n2 2\n\n3 4\n1 1\n3 4\n2 1\n1 2\n\n2 2\n2 1\n2 2\n1 2\n1 1\n\n0 0\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"YES\nRRUULLD\nNO\nYES\nRD\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ 連結"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://open.kattis.com/problems/amazingadventures"},"children":[{"type":"text","value":"Open Kattis - Amazing Adventures"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"好一陣子沒有這麼痛苦地寫一個理論上有模板很好寫的東西了（淚）"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這題的關鍵是"},{"type":"element","tagName":"a","properties":{"href":"https://tmt514.github.io/algo/min-cost-max-flow"},"children":[{"type":"text","value":"最小費用流"}]},{"type":"element","tagName":"footnote","properties":{"goto":"1","show":"備註 1"},"children":[]},{"type":"text","value":"（或者，你可以說貪心地做兩次最短路徑。）\n每個格子不能經過超過一次這個條件，給我們一個很大的提示：要嘛這題是網路流、要嘛這是爆搜或連通性DP。\n我們可以令中繼的 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"C"}]},{"type":"text","value":" 作為 sink，而開頭與結束的 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"B"}]},{"type":"text","value":" 與 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"G"}]},{"type":"text","value":" 作為 source，並建立網路流的圖：對於每一個格子 $(i, j)$ 我們都把他變成兩個點 $(i, j)_{in}$ 跟 $(i, j)_{out}$，然後有一條邊從 in 連到 out，cost=1。此外，對於相鄰的兩個格子，比方說 $(i, j)$ 和 $(i, j+1)$。我們也建立兩條邊 $(i, j)_{out}\\to (i, j+1)_{in}$ 以及 $(i, j+1)_{out}\\to (i, j)_{in}$（請注意都是從 out 連到 in），cost=0。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"在這樣的圖上面找兩條「點不重複的路徑」 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"B"}]},{"type":"text","value":"$\\to$"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"C"}]},{"type":"text","value":"、"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"G"}]},{"type":"text","value":"$\\to$"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"C"}]},{"type":"text","value":"，而且讓總 cost 最小，就等價於找出最短的從 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"B"}]},{"type":"text","value":"$\\to$"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"C"}]},{"type":"text","value":"$\\to$"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"G"}]},{"type":"text","value":" 路徑。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"有模板會好很多很多很多！\n如果沒有的話，寫起來大概繪像我這樣慘慘的。有一些實作上的偷懶細節在這邊："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"每一次都用 priority queue 版本的 SPFA 找最短路徑。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"每一條邊還自帶輸出字元，這樣在找解的時候就不需要思考這條邊到底要給他 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"U"}]},{"type":"text","value":", "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"D"}]},{"type":"text","value":", "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"L"}]},{"type":"text","value":" 還是 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"R"}]},{"type":"text","value":" 了。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"下面程式碼裡面的逆向邊通通標記 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"#"}]},{"type":"text","value":"，這樣可以順便得知這條邊的 cost 到底是 $1$ 還是 $-1$（如果沿著逆向邊流，那 cost 就是 $-1$，反之為 $1$）。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Edge {\n  int to;\n  int capacity;\n  int reversed_index;\n  char ch;\n  Edge(int _to, int _c, int _r, char _ch): to(_to), capacity(_c), reversed_index(_r), ch(_ch) {}\n};\n\nclass FlowNetwork {\n  public:\n    int nid, sink;\n    vector<vector<Edge>> edges;\n    FlowNetwork() : nid(0) {\n      edges.clear();\n    }\n    void SetSink(int _sink) { sink = _sink; }\n    int AddNode() {\n      edges.push_back(vector<Edge>());\n      return nid++;\n    }\n    // 每加入一條邊，同時加上一條逆向邊，到時候增廣的時候我們必須在剩餘圖上的反向邊同步操作，\n    // 因此很需要能夠從一條邊跳到另一條。\n    void AddEdge(int from, int to, char mark) {\n      edges[from].emplace_back(to, 1, (int)edges[to].size(), mark);\n      edges[to].emplace_back(from, 0, (int)edges[from].size()-1, '#');\n    }\n\n    // 給定源點 x，找一條 cost 最小的路徑從 x 到 sink。如果找到了，順便把這條路徑增廣一下。\n    bool SPFA(int x) {\n      priority_queue<pair<int, int>> Q;\n      vector<int> dist(nid, 1e9);\n      vector<Edge> last(nid, Edge(-1,-1,-1,'X'));\n      dist[x] = 0;\n      Q.push({0, x});\n\n      while (!Q.empty()) {\n        auto it = Q.top(); Q.pop();\n        int d = -it.first;\n        int x = it.second;\n        if (d != dist[x]) continue;\n\n        for (auto&& e : edges[x]) {\n          if (e.capacity) {\n            int nd = d + (e.ch == '#' ? -1 : 1);\n            if (dist[e.to] > nd) {\n              dist[e.to] = nd;\n              last[e.to] = edges[e.to][e.reversed_index];\n              Q.push({ -nd, e.to });\n            }\n          }\n        }\n      }\n      if (last[sink].to == -1) return false;\n      x = sink;\n      while (last[x].to != -1) {\n        Edge& e = edges[last[x].to][last[x].reversed_index];\n        e.capacity--;\n        edges[e.to][e.reversed_index].capacity++;\n        x = last[x].to;\n      }\n      return true;\n    }\n\n    // 逆向追蹤還原路徑。\n    string Trace(int x) {\n      string ret = \"\";\n      while (x != sink) {\n        for (auto&& e : edges[x]) {\n          if (e.ch != '#' && e.capacity == 0) {\n            x = e.to;\n            if (e.ch != 'X') ret += e.ch;\n          }\n        }\n      }\n      return ret;\n    }\n};\n\n///////////////////////////////////////////////////////////////////////////////\n// 你看有模板的話上面都省下來了耶。\n\nint ids[105][105][2];\n\nbool solve() {\n  int M, N;\n  // 請不要讀反輸入，這樣會 debug 很久（淚）。\n  cin >> N >> M;\n\n  if (M == 0 && N == 0) return false;\n  FlowNetwork g;\n\n  // 先定義這個圖上的點。\n  for (int i = 1; i <= N; i++) {\n    for (int j = 1; j <= M; j++) {\n      ids[i][j][0] = g.AddNode();\n      ids[i][j][1] = g.AddNode();\n    }\n  }\n\n  int rB, cB, rC, cC, rG, cG, rU, cU;\n  cin >> rB >> cB >> rC >> cC >> rG >> cG >> rU >> cU;\n\n  // 把圖上的邊建立起來，記得要跳過 (rU, cU) 這格。\n  for (int x = 1; x <= N; x++) {\n    for (int y = 1; y <= M; y++) {\n      if (x == rU && y == cU) continue;\n      g.AddEdge(ids[x][y][0], ids[x][y][1], 'X');\n      const int dx[4] = {0, 1, 0, -1};\n      const int dy[4] = {1, 0, -1, 0};\n      const string dir = \"RULD\";\n      for (int f = 0; f < 4; f++) {\n        int nx = x + dx[f], ny = y + dy[f];\n        if (nx == rU && ny == cU) continue;\n        if (nx >= 1 && nx <= N && ny >= 1 && ny <= M) {\n          g.AddEdge(ids[x][y][1], ids[nx][ny][0], dir[f]);\n        }\n      }\n    }\n  }\n\n  g.SetSink(ids[rC][cC][0]);\n  if (g.SPFA(ids[rB][cB][0]) && g.SPFA(ids[rG][cG][0])) {\n    auto A = g.Trace(ids[rB][cB][0]);\n    auto B = g.Trace(ids[rG][cG][0]);\n    reverse(B.begin(), B.end());\n    for (auto&& x : B) {\n      if (x == 'U') x = 'D';\n      else if (x == 'D') x = 'U';\n      else if (x == 'L') x = 'R';\n      else if (x == 'R') x = 'L';\n    }\n    cout << \"YES\" << '\\n';\n    cout << A << B << '\\n';\n  } else {\n    cout << \"NO\" << '\\n';\n  }\n  \n  return true;\n}\n\nint main() {\n  while (solve());\n  return 0;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"備註 1"},{"type":"element","tagName":"footnote","properties":{"here":"1"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"需要關於這題更詳盡的資源請參考 "},{"type":"element","tagName":"a","properties":{"href":"https://stackoverflow.com/questions/11880738/shortest-two-disjoint-paths-between-two-specified-vertices"},"children":[{"type":"text","value":"Stackoverflow - Shortest two disjoint paths between two specified vertices"}]},{"type":"text","value":"。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"關於競程日記"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"🍅 如果您想到更多有趣漂亮簡單乾淨的解法話歡迎留言給競程日記小編群！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"ℹ️ 這是一篇投稿給"},{"type":"element","tagName":"a","properties":{"href":"https://www.facebook.com/%E7%AB%B6%E7%A8%8B%E6%97%A5%E8%A8%98-1514973425463954/"},"children":[{"type":"text","value":"競程日記"}]},{"type":"text","value":"的文章，歡迎大家投稿、交流與分享程式解題競賽的點點滴滴！"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"Divide Doughnut","category":"prob","path":"/problem/icpc/asia_hanoi_2018/D","date":"2019-01-12","_PARENT":"c63326dc-84dd-5a21-99ba-6821f15ee3cc","description":"**這是一個互動題。**\n\n![](https://open.kattis.com/problems/dividedoughnut/file/statement/en/img-0001.png)\n\nKhue 與 Hanh 獲得了一個上面灑了一些五彩巧克力米的甜甜圈。他們想要把一個甜甜圈切成公平的一半，使得兩邊的巧克力米的數量相等。\n\n甜甜圈可以視為由 $10^9$ 個單位組成，每一個單位的甜甜圈範圍內至多只會有一顆巧克力米。已知甜甜圈上總共有 $N$ 顆巧克力米（$N$ 是偶數）。你的目標是要協助 Khue 與 Hanh 找出正確的切法，使得兩個人分別擁有連續的 $5\\times 10^8$ 單位甜甜圈，而且上面巧克力米的數量恰好有 $N/2$ 個。\n\n### 互動的部份\n\n你的任務是透過互動式詢問找出一個滿足題目條件的切法。\n\n你的程式會首先讀入一個正整數 $N$。輸入保證 $N$ 是偶數。接下來：\n* 你的程式會輸出以下三種形式之一：\n    * `QUERY u v` ($0\\le u, v < 10^9$)，詢問有多少巧克力米位於第 $u$ 單位與第 $v$ 單位之間。請注意：當 $u>v$ 時表示要計算的巧克力米是從第 $u$ 單位到第 $10^9-1$ 單位、以及第 $0$ 單位到第 $v$ 單位之間。\n    * `YES x` ($0\\le x < 10^9$)，告訴 Khue 可以拿到第 $x$ 單位到第 $(x+5\\cdot 10^8-1)\\bmod 10^9$ 單位的甜甜圈。\n    * `NO`，回答不可能切成公平的兩部份。\n* 你的程式如果問了一個 `QUERY`，那麼接下來你可以從 standard input 讀入一個整數 $S$，表示得到的答案。\n* 否則的話，你的答案會被檢查。**而你必須立刻結束程式**。\n\n對於輸入的 $N$，你的程式至多只能詢問 $30+\\lfloor\\log_2\\sqrt{N}\\rfloor$ 次。\n","link":"https://open.kattis.com/problems/dividedoughnut","code":"ICPC-HANOI-2018-D","difficulty":3,"oj":"kattis","tags":["ICPC 2018 Asia Hanoi Regional","interactive"]},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"簡化後題目敘述"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ 連結"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://open.kattis.com/problems/dividedoughnut"},"children":[{"type":"text","value":"Open Kattis - Divide Doughnut"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"題目出處"}]},{"type":"text","value":"：ICPC 2018 Asia Hanoi Regional"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這題是個很棒的二分搜尋法練習題：關鍵在於每一個單位甜甜圈上頭至多只能有一顆巧克力米。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果我們繪製一個函數 $f$，對於每一個 $x$ 值計算區間 $[x, (x+5\\cdot 10^8-1)\\bmod 10^9]$ 裡面的巧克力米數量，那麼這個函數 $f$ 的相鄰兩個值只會差 $-1, 0, 1$。注意到 $f(0) + f(5\\cdot 10^8) = N$，如果其中一個 $< N/2$ 另一個就會 $> N/2$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"於是我們可以根據 $f(a) < N/2, f(b) > N/2 \\implies \\text{存在} c\\in [a, b] \\text{使得} f(c) = N/2$。然後就可以用"},{"type":"element","tagName":"a","properties":{"href":"/algo/binary-search-applications"},"children":[{"type":"text","value":"勘根定理"}]},{"type":"text","value":"進行二分搜尋法囉！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"要特別注意的是，這題的範圍很嚴格，所以一旦範圍縮小到 $l=r$ 的時候就不需要再詢問就可以直接輸出答案了。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"#include <bits/stdc++.h>\nusing namespace std;\n\nconst int WINDOW = 500000000;\nconst int FULL = 1e9;\nint MakeQuery(int x) {\n  cout << \"QUERY \" << x << \" \" << (x + WINDOW-1)%FULL << endl;\n  int ret;\n  cin >> ret;\n  return ret;\n}\n\nint main() {\n  int N;\n  cin >> N;\n  \n  int v0 = MakeQuery(0);\n  int l = 0, r = WINDOW;\n\n  if (v == N/2) {\n    cout << \"YES \" << 0 << endl;\n    return 0;\n  }\n  \n  while (l < r) {\n    int m = (l + r) / 2;\n    int v = MakeQuery(m);\n    if (v == N/2) {\n      cout << \"YES \" << m << endl;\n      return 0;\n    } else if ((v > N/2) != (v0 > N/2)) {\n      r = m - 1;\n    } else {\n      l = m + 1;\n    }\n  }\n  cout << \"YES \" << m << endl;\n  return 0;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"夢月說"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這題跟 Codeforces 的一個互動題非常相似 "},{"type":"element","tagName":"a","properties":{"href":"https://codeforces.com/contest/1019/problem/B"},"children":[{"type":"text","value":"Codeforces 1019B - The hat"}]},{"type":"text","value":"。該場比賽舉辦的時間是 2018/08/11，其實是相當新的題目。不過該題要求的詢問次數條件相對寬鬆許多，只要不超過 60 次就可以了。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"關於競程日記"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"🍅 如果您想到更多有趣漂亮簡單乾淨的解法話歡迎留言給競程日記小編群！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"ℹ️ 這是一篇投稿給"},{"type":"element","tagName":"a","properties":{"href":"https://www.facebook.com/%E7%AB%B6%E7%A8%8B%E6%97%A5%E8%A8%98-1514973425463954/"},"children":[{"type":"text","value":"競程日記"}]},{"type":"text","value":"的文章，歡迎大家投稿、交流與分享程式解題競賽的點點滴滴！"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"Jurassic Jungle","category":"prob","path":"/problem/icpc/asia_hanoi_2018/J","date":"2019-01-10","_PARENT":"3687c421-b5f1-5102-b690-3dd5e13e364a","description":"給你 $N$ ($3\\le N\\le 30$) 與 $M$ 的值，請問是否存在一個恰好有 $N$ 個點與 $M$ 條邊的無向簡單圖，滿足條件：從**任意**一個節點出發、每次隨意挑選新的節點走訪、而走出來的 DFS 樹都是一條鍊（path），而且那個唯一的葉子與樹根有邊相連。\n\n如果存在這樣的圖，請輸出 `YES` 以後輸出任意一個答案。否則的話輸出 `NO`。\n","link":"https://open.kattis.com/problems/jurassicjungle","code":"ICPC-HANOI-2018-J","difficulty":6,"oj":"kattis","tags":["ICPC 2018 Asia Hanoi Regional"]},"htmlAst":{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"簡化後題目敘述"}]},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"輸入可能包含多組測試資料。每一組測試資料包含兩個正整數 $N, M$（$3\\le N\\le 30, 0\\le M\\le \\frac{N(N-1)}{2}$）。測試資料以 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"-1 -1"}]},{"type":"text","value":" 作為結束。"}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸出說明"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果存在滿足題目要求的圖，請輸出 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"YES"}]},{"type":"text","value":" 以後輸出任意一個答案的 $M$ 條邊（點的編號為 $1, 2, \\ldots, N$）。否則的話輸出 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"NO"}]},{"type":"text","value":"。"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入"}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"3 3\n5 4\n-1 -1\n"}]}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出"}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"YES\n1 2\n1 3\n3 2\nNO\n"}]}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ 連結"}]},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://open.kattis.com/problems/jurassicjungle"},"children":[{"type":"text","value":"Open Kattis - Jurassic Jungle"}]}]},{"type":"text","value":"\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"題目出處"}]},{"type":"text","value":"：ICPC 2018 Asia Hanoi Regional"}]},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"看到數字範圍，你可能會覺得或許是 DP、或許是爆搜。但很遺憾地這題是個扎扎實實的圖論數學題。不過好消息是我們不需要會證明，只要全憑直覺就可以通過這題。（這到底是好消息還是壞消息...這代表題目品質很不穩定啊。）"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"對於這個題目，一開始很容易想到的是 Cycle 跟 Complete Graph。除了這兩種圖以外，似乎其他種類的圖都不太可能存在解。快速拿到一個 Wrong Answer 以後便開始細細思索到底還缺了什麼樣的圖。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"思考許久以後，便會發現完全二分圖 Complete Bipartite Graphs，只要兩邊的點數一樣多，那麼從任何一個點隨意出發也可以隨意走出一個 Hamiltonian Cycle。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"然後我就 AC 了（當時的心情是：囧）"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"事後諸葛"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"要給出一個優雅的證明其實還滿有挑戰性的。在此我節錄了一段關鍵的引理"},{"type":"element","tagName":"footnote","properties":{"goto":"1","show":"備註1"},"children":[]},{"type":"text","value":"。假設存在一個滿足條件的圖 $G=(V, E)$，那麼我們可以隨意先畫出一個漢米爾頓圈，其頂點順序依序編號為 $v_1, v_2, \\ldots, v_n$。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果除了這個 cycle 以外沒有其他弦（chord，橫越圈內兩點的邊）那麼顯然這是個滿足條件的圖（研究圖論的人會習慣把這樣的 cycle 寫作 $C_n$）。引理來了："}]},{"type":"element","tagName":"theorem","properties":{},"children":[{"type":"text","value":"\n如果這個 cycle 上面有一根弦 $(v_j, v_k)\\in E$，那麼必定有 $(v_{j+1}, v_{k+1})\\in E$（不妨令 $v_{n+1}=v_1$ 避免足標溢位的問題。）\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"引理的證明很簡單：考慮以下的 Hamiltonian Path 產生方法（原題指的是恐龍的走法）—— $v_{j+1}, \\ldots, v_{k}, v_{j}, v_{j-1}, \\ldots, v_{1}, v_{n}, \\ldots, v_{k+1}$。根據題意，此時必須保證 $(v_{j+1}, v_{k+1})\\in E$。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"有了這個引理以後，就可以如法炮製證明說：如果長度為 $\\ell$ 的弦存在的話，那麼長度為 $\\ell\\pm 2$ 的弦（如果長度在範圍內的話）一定也必須存在。所以最小弦長一定是橫跨兩條或三條邊。接下來要證明的是："}]},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"如果最小弦長橫跨兩條邊而已，那這個圖必須要是完全圖 $K_n$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"如果最小弦長橫跨了三條邊，那麼點數 $n$ 必須是偶數、而且這個圖會變成完全二分圖 $K_{n/2, n/2}$。"}]},{"type":"text","value":"\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"證明的細節實在是太細節了（不斷地找一條路徑然後說，這裡必須有邊這樣）。我們就此打住吧～"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"#include <bits/stdc++.h>\nusing namespace std;\n\nbool solve() {\n  int N, M;\n  cin >> N >> M;\n  if (N == -1 && M == -1) return false;\n\n  if (M == N) { // Cycle\n    cout << \"YES\" << '\\n';\n    for (int i=1;i<=N;i++)\n      cout << i << \" \" << (i==N?1: i+1) << '\\n';\n  } else if (M == N*(N-1)/2) { // Complete Graph\n    cout << \"YES\" << '\\n';\n    for (int i=1;i<=N;i++)\n      for(int j=i+1;j<=N;j++)\n        cout << i << \" \" << j << '\\n';\n  } else if (N%2==0 && M==(N/2)*(N/2)) { // Complete Bipartite Graph\n    cout << \"YES\" << '\\n';\n    for (int i=1;i<=N/2;i++)\n      for(int j=N/2+1;j<=N;j++)\n        cout << i << \" \" << j << '\\n';\n  } else {\n    cout << \"NO\" << '\\n';\n  }\n\n  return true;\n}\n\nint main() {\n  while(solve());\n  return 0;\n}\n"}]}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"備註 1"},{"type":"element","tagName":"footnote","properties":{"here":"1"},"children":[]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這要追溯到 1968 年的一篇論文 "},{"type":"element","tagName":"a","properties":{"href":"https://epubs.siam.org/doi/abs/10.1137/0116056?journalCode=smjmap"},"children":[{"type":"text","value":"Randomly Traceable Graphs"}]},{"type":"text","value":"，裡面關鍵的引理 3 就是上面這個引理。而定理6 就是這整題要問的結論。很 666666 吧。"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"關於競程日記"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"🍅 如果您想到更多有趣漂亮簡單乾淨的解法話歡迎留言給競程日記小編群！"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"ℹ️ 這是一篇投稿給"},{"type":"element","tagName":"a","properties":{"href":"https://www.facebook.com/%E7%AB%B6%E7%A8%8B%E6%97%A5%E8%A8%98-1514973425463954/"},"children":[{"type":"text","value":"競程日記"}]},{"type":"text","value":"的文章，歡迎大家投稿、交流與分享程式解題競賽的點點滴滴！"}]}]}}},{"node":{"frontmatter":{"title":"Edit Distance","category":"prob","path":"/problem/icpc/asia_jakarta_2018/A","date":"2019-01-01","_PARENT":"5c3e54f2-98d2-55ad-9371-2e966b37e556","description":"對於兩個給定的字串 $S$ 和 $T$，我們定義 $edit(S, T)$ 為從 $S$ 經過若干插入字元、修改字元、刪除字元等操作後得到 $T$ 所需要的最少步數。\n\nAyu 有一個二元字串 $S$（$1\\le |S|\\le 2000$），她想要找到另一個字串 $T_{max}$ 使得 $edit(S, T_{max})$ 最大。即對於所有與 $S$ 等長的 $T$，$edit(S, T_{max})\\ge edit(S, T)$。不過呢，為了讓事情變得簡單些，她希望你能夠幫她的忙，找到任何一個與 $S$ 長度相同的字串 $T$，只要 $edit(S, T) > |S|/2$ 即可。\n\n當然，你也可以選擇輸出 $T_{max}$，事實上我們可以證明 $edit(S, T_{max}) > |S|/2$。這也保證了對於任意輸入一定有解。\n","link":"https://codeforces.com/gym/102001/problem/A","code":"ICPC-JAKARTA-2018-A","difficulty":3,"oj":"codeforces-gym","tags":null},"htmlAst":{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"題目敘述"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"對於兩個給定的字串 $S$ 和 $T$，我們定義其 "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"Edit Distance"}]},{"type":"element","tagName":"footnote","properties":{"goto":"1","show":"備註1,2"},"children":[]},{"type":"text","value":" $edit(S, T)$ 為從 $S$ 經過若干插入字元、修改字元、刪除字元等操作後得到 $T$ 所需要的最少步數。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Ayu 有一個二元字串 $S$（$1\\le |S|\\le 2000$），她想要找到另一個字串 $T_{max}$ 使得 $edit(S, T_{max})$ 最大。即對於所有與 $S$ 等長的 $T$，$edit(S, T_{max})\\ge edit(S, T)$。不過呢，為了讓事情變得簡單些，她希望你能夠幫她的忙，找到任何一個與 $S$ 長度相同的字串 $T$，只要 $edit(S, T) > |S|/2$ 即可。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"當然，你也可以選擇輸出 $T_{max}$，事實上我們可以證明 $edit(S, T_{max}) > |S|/2$。這也保證了對於任意輸入一定有解。"}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"輸入僅有一行包含二元字串 $S$（$1\\le |S|\\le 2000$）。"}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸出說明"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"輸出一個與 $S$ 長度相等的二元字串 $T$，滿足 $edit(S, T) > |S|/2$。"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 1"}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"0011\n"}]}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 1"}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"1100\n"}]}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 2"}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"1100101\n"}]}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 2"}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"0011010\n"}]}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ 連結"}]},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://codeforces.com/gym/102001/problem/A"},"children":[{"type":"text","value":"Codeforces Gym 102001 - A"}]}]},{"type":"text","value":"\n"}]},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果單純把所有數字都反過來，可能不太行。比方說以下的反例："},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"01010101"}]},{"type":"text","value":"，反過來就變成 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"10101010"}]},{"type":"text","value":"，顯然我們只要刪掉第一個字元並且補到後面去就行了。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"換一個想法想，如果字串長度 $n$ 是奇數，那麼根據 $edit({\\tt{000\\cdots 0}}, S) + edit(S, {\\tt{111\\cdots 1}}) \\ge edit({\\tt{000\\cdots 0}}, {\\tt{111\\cdots 1}}) = n$，我們知道其中一個一定會超過 $n/2$，因為 $n$ 是奇數，所以一定有一個會嚴格大於 $n/2$。換句話說，$n$ 是奇數的時候很好解決！"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"那 $n$ 是偶數的時候怎麼辦？考慮 $S$ 的前 $n-1$ 個 bit（此時 $n-1$ 是奇數）我們稱這個前綴為 $S_0$。根據前一段的論述，我們可以找出一個"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"等長的"}]},{"type":"text","value":" $T_0$ 滿足 $edit(S_0, {T_0})\\ge \\lceil \\frac{n-1}{2}\\rceil = n/2$。此時顯然有 $edit(S, {T_0}), edit(S_0, \\red{T_0{\\tt{0}}}), edit(S_0, \\red{T_0{\\tt{1}}}) \\ge n/2$"},{"type":"element","tagName":"footnote","properties":{"goto":"3","show":"備註3"},"children":[]},{"type":"text","value":"。還記得計算 edit distance 的動態規劃嗎？無論我們在 $T_0$ 後面補哪個字元 $x$，總能夠有"}]},{"type":"text","value":"$$\n    edit(S, \\red{T_0x}) = \\min \\begin{cases}\n    edit(S_0, T_0) + (S[n-1] {\\tt{==}} x) & \\text{修改字元}\\\\\n    edit(S_0, \\red{T_0x}) + 1 & \\text{刪除字元}\\\\\n    edit(S, T_0) + 1 & \\text{插入字元}\n    \\end{cases}\n$$"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這時候注意到：如果我們選定 $x\\neq S[n-1]$，無論是哪種 case 都至少保證此時 $edit(S, \\red{T_0x}) > n/2$，達到目標！"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"為了實作方便，我們考慮的是 $S$ 的末 $n-1$ 個字元，然後找到 $T$ 以後再根據 $S[0]$ 把相對應的字元放到前面。"}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"#include <iostream>\n#include <string>\nusing namespace std;\n\nint main() {\n  string s, t;\n  cin >> s;\n  \n  // 計算字串中 0 和 1 出現的個數。\n  int b[2] = {};\n  for (int i = 1; i < s.size(); i++) b[s[i]=='1']++;\n  \n  // 構造出距離比較遠的全 0 或全 1 字串。\n  t = string(s.size(), '0' + (b[0] > b[1]));\n  \n  // 然後把第一個字元改成與 s[0] 不同的字元，並且輸出。\n  t[0] = '0' + '1' - s[0];\n  cout << t << endl;\n  return 0;\n}\n"}]}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"備註 1"},{"type":"element","tagName":"footnote","properties":{"here":"1"},"children":[]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Edit Distance 好像又被稱為 "},{"type":"element","tagName":"a","properties":{"href":"https://en.wikipedia.org/wiki/Levenshtein_distance"},"children":[{"type":"text","value":"Levenshtein Distance"}]},{"type":"text","value":"，是一種衡量兩個字串是否有多接近的指標（metric，不是 pointer XD）。"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"備註 2"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Edit Distance 滿足三角不等式：$edit(A, B)+edit(B, C) \\ge edit(A, C)$，白話文解釋就是從 $A$ 換到 $C$ 的方法，至少有先從 $A$ 變成 $B$ 再從 $B$ 變成 $C$ 來得好。"}]},{"type":"element","tagName":"theorem","properties":{"title":"演算法豆知識","c":"is-primary"},"children":[{"type":"text","value":"\n在[強指數時間假說](/algo/strong-exponential-time-hypothesis)為真的前提之下，計算兩個長度為 $n$ 字串的 Edit Distance (exact) 至少得花 $\\Omega(n^{2-\\epsilon})$ 的時間。但是就近似演算法 (Approximation Algorithms) 而言， 2018 年 FOCS 的一篇最佳論文 [_Approximating Edit Distance Within Constant Factor in Truly Sub-Quadratic Time_](https://arxiv.org/abs/1810.03664)，在 $\\tilde{O}(n^{12/7})$ 時間內保證得到 $1680$-approxmation 的近似解，是為近期的一個重大突破。（作者們相信稍微用他們的方法再努力一下就可以做到 $(3+\\epsilon)$-approximation）\n"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"備註 3"},{"type":"element","tagName":"footnote","properties":{"here":"3"},"children":[]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"解答上面有一句話：此時顯然有 $edit(S, {T_0}), edit(S_0, \\red{T_0{\\tt{0}}}), edit(S_0, \\red{T_0{\\tt{1}}}) \\ge n/2$。這句話必須在 $|S_0|= |T_0|$ 的時候才成立。當 $|S_0|\\neq|T_0|$ 的時候，你能找到反例嗎？"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"關於競程日記"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"🍅 如果您想到更多有趣漂亮簡單乾淨的解法話歡迎留言給競程日記小編群！"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"ℹ️ 這是一篇投稿給"},{"type":"element","tagName":"a","properties":{"href":"https://www.facebook.com/%E7%AB%B6%E7%A8%8B%E6%97%A5%E8%A8%98-1514973425463954/"},"children":[{"type":"text","value":"競程日記"}]},{"type":"text","value":"的文章，歡迎大家投稿、交流與分享程式解題競賽的點點滴滴！"}]}]}}},{"node":{"frontmatter":{"title":"ICPC 2018 Asia Jakarta Regional","category":"cp","path":"/problem/icpc/asia_jakarta_2018","date":"2018-12-26","_PARENT":"defe522f-c0a5-5364-be70-eaeecc05e501","description":null,"link":null,"code":null,"difficulty":null,"oj":null,"tags":null},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"include-problem","properties":{"titlePrefix":"Problem A. ","path":"/problem/icpc/asia_jakarta_2018/A"},"children":[{"type":"text","value":"\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"include-problem","properties":{"titlePrefix":"Problem B. ","path":"/problem/icpc/asia_jakarta_2018/B"},"children":[{"type":"text","value":"\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"include-problem","properties":{"titlePrefix":"Problem C. ","path":"/problem/icpc/asia_jakarta_2018/C"},"children":[{"type":"text","value":"\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"include-problem","properties":{"titlePrefix":"Problem D. ","path":"/problem/icpc/asia_jakarta_2018/D"},"children":[{"type":"text","value":"\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"include-problem","properties":{"titlePrefix":"Problem E. ","path":"/problem/icpc/asia_jakarta_2018/E"},"children":[{"type":"text","value":"\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"include-problem","properties":{"titlePrefix":"Problem F. ","path":"/problem/icpc/asia_jakarta_2018/F"},"children":[{"type":"text","value":"\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"include-problem","properties":{"titlePrefix":"Problem G. ","path":"/problem/icpc/asia_jakarta_2018/G"},"children":[{"type":"text","value":"\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"include-problem","properties":{"titlePrefix":"Problem H. ","path":"/problem/icpc/asia_jakarta_2018/H"},"children":[{"type":"text","value":"\n"}]}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"Go Make It Complete","category":"prob","path":"/problem/icpc/asia_jakarta_2018/G","date":"2019-01-04","_PARENT":"d6b743c0-cb89-5b59-8fb2-62c2f23c61ae","description":"給定一個無向簡單圖 $G$，找出最大的整數 $k$，使得存在一個包含所有尚未被加入 $G$ 的邊的序列 $L$，使得依序把這些邊 $(x, y)$ 加入圖 $G$ 的當下，$\\delta_x+\\delta_y \\ge k$。其中 $\\delta_x, \\delta_y$ 是當下點 $x$ 和點 $y$ 在圖 $G$ 上的度數。\n","link":"https://codeforces.com/gym/102001/problem/G","code":"ICPC-JAKARTA-2018-G","difficulty":5,"oj":"codeforces-gym","tags":null},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"簡化後題目敘述"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"輸入的第一列包含兩個整數 $N, M$ ($2\\le N\\le 500; 0\\le M < \\frac{N\\times (N-1)}{2}$) 代表點的數量與現存的邊數。接下來的 $M$ 列每一列包含兩個正整數 $a_i, b_i$ ($1\\le a_i < b_i \\le N$) 表示一條現存的邊。輸入保證任何配對 $(a_i, b_i)$ 只會出現至多一次。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸出說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"輸出所求的整數 $k$ 值。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"4 3\n1 2\n2 3\n3 4\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"3\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"5 0\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"0\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 3"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"5 2\n1 2\n3 4\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 3"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"2\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ 連結"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://codeforces.com/gym/102001/problem/G"},"children":[{"type":"text","value":"Codeforces Gym 102001 - G"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這題可以用枚舉法的概念，對於每一個 $k$ 值判斷是否存在一個加入邊的序列滿足條件。演算法如下："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"把所有滿足 $\\delta_x+\\delta_y\\ge k$ 但不在圖上的邊蒐集起來，加入一個佇列 $Q$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"只要佇列非空，抓一條佇列中的邊 $(x, y)$，把它加入圖中；掃過一次所有與點 $x$ 和點 $y$ 相鄰的所有不在圖上的邊，並判斷是否能夠把它們加入佇列。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"如果最終所有的邊都被加入了佇列，就代表這個 $k$ 值是個成功的 $k$ 值。反之則不行：在任意時刻加不進佇列的邊永遠度數和小於 $k$。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"以上的演算法的第一步會花 $O(N^2)$ 時間掃過所有點對。\n第二步可能會考慮 $O(N^2)$ 個點對、而每一條邊加入後會花 $O(N)$ 時間掃過相鄰的不在圖上的邊，因此第二步所花時間是 $O(N^3)$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"不難發現只要 $k$ 是答案，$k-1$ 也會是答案。於是我們可以對 $k$ 進行二分搜尋法，找到滿足條件的最大 $k$ 值。時間複雜度 $O(N^3\\log N)$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"但事實上二分搜尋法是不必要的。對於某個 $k$，若第二步完成後，還有邊沒有被加入圖上，那麼我們把 $k\\gets k-1$ 時，剛才那些已經加入的邊，顯然可以依照同樣順序被加入圖上。因此，我們只需要重新對剩下的邊跑過上述演算法即可。注意到最大可能的 $k$ 為 $(N-2)+(N-2)$，第一步可能要重新跑 $O(N)$ 次，因此總花費時間是 $O(N^3)$，第二步每一條邊仍然只會被加入到佇列至多一次，所以也還是 $O(N^3)$。我們就得到一個 $O(N^3)$ 的乾淨算法啦～"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"#include <algorithm>\n#include <iostream>\n#include <queue>\nusing namespace std;\n\nint a[505][505];\nint deg[505];\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n  for (int i = 0; i < m; i++) {\n    int x, y;\n    cin >> x >> y;\n    a[x][y] = a[y][x] = 1;\n    deg[x]++;\n    deg[y]++;\n  }\n  int k;\n  for (k = 2 * (n - 2); k >= 0; k--) {\n    queue<pair<int, int>> q;\n    // 第一步\n    for (int x = 1; x <= n; x++)\n      for (int y = x + 1; y <= n; y++)\n        if (!a[x][y] && deg[x] + deg[y] >= k) {\n          q.push({x, y});\n        }\n    // 第二步\n    while (!q.empty()) {\n      auto [x, y] = q.front();\n      q.pop();\n      if (a[x][y]) continue;\n      m++;\n      a[x][y] = a[y][x] = 1;\n      deg[x]++;\n      deg[y]++;\n      for (int z = 1; z <= n; z++) {\n        if (x != z && !a[x][z] && deg[x] + deg[z] >= k) q.push({x, z});\n        if (y != z && !a[y][z] && deg[y] + deg[z] >= k) q.push({y, z});\n      }\n    }\n    // 第三步\n    if (m >= n * (n - 1) / 2) break;\n  }\n  cout << k << endl;\n  return 0;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"備註"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果要再快個常數倍的話（大約兩倍），可以把第一步很多不必要的檢查節省起來：事先把所有沒在圖上的邊依照 $\\delta_x+\\delta_y$ 的值放到某個陣列裡面。在第二步更新的當下，可以順便更新 $(x, z)$ 和 $(y, z)$ 的度數和。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Open Question"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這題如果把 Queue 拿掉，變成以下的 code 會變得更快。不曉得有沒有辦法證明下面的 while loop 只會跑 $O(N)$ 次？"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"#include <algorithm>\n#include <iostream>\n#include <queue>\nusing namespace std;\n\nint a[505][505];\nint deg[505];\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n  \n  auto addedge = [&](int x, int y) {\n    a[x][y] = a[y][x] = 1;\n    deg[x]++;\n    deg[y]++;\n  };\n  for (int i = 0; i < m; i++) {\n    int x, y;\n    cin >> x >> y;\n    addedge(x, y);\n  }\n  int k = 2 * (n - 2);\n  while (m < n * (n - 1) / 2) {\n    int v = 0;\n    for (int x = 1; x <= n; x++)\n      for (int y = x + 1; y <= n; y++)\n        if (!a[x][y])\n            v = max(v, deg[x] + deg[y]);\n    k = min(k, v);\n    for (int x = 1; x <= n; x++)\n      for (int y = x + 1; y <= n; y++)\n        if (!a[x][y] && deg[x] + deg[y] >= k) {\n          m++;\n          addedge(x, y);\n        }\n  }\n  cout << k << endl;\n  return 0;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"關於競程日記"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"🍅 如果您想到更多有趣漂亮簡單乾淨的解法話歡迎留言給競程日記小編群！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"ℹ️ 這是一篇投稿給"},{"type":"element","tagName":"a","properties":{"href":"https://www.facebook.com/%E7%AB%B6%E7%A8%8B%E6%97%A5%E8%A8%98-1514973425463954/"},"children":[{"type":"text","value":"競程日記"}]},{"type":"text","value":"的文章，歡迎大家投稿、交流與分享程式解題競賽的點點滴滴！"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"Future Generation","category":"prob","path":"/problem/icpc/asia_jakarta_2018/J","date":"2019-01-06","_PARENT":"e085fd9f-2490-50b1-b6cd-cb4ddee392b9","description":"給你 $N$ ($1\\le N\\le 15$) 個字串 $S_1, \\ldots, S_N$ ($1\\le |S_i| \\le 15$)。現在請你對於每一個字串 $S_i$，找出一個非空的子序列 $A_i$，使得 $A_1, A_2, \\ldots, A_N$ 依照字典順序是嚴格遞增的。\n\n輸出最大的 $|A_1|+|A_2|+\\cdots + |A_N|$ 之值。若無解的話要輸出 `-1`。\n","link":"https://codeforces.com/gym/102001/problem/J","code":"ICPC-JAKARTA-2018-J","difficulty":4,"oj":"codeforces-gym","tags":["ICPC 2018 Asia Jakarta Regional"]},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"簡化後題目敘述"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"第一列包含一個正整數 $N$ ($1\\le N\\le 15$)。第二列開始有 $N$ 列，每一列包含一個僅由大寫字母組成的字串 $S_i$ ($1\\le |S_i|\\le 15$)\n。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸出說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"輸出最大的 $|A_1|+|A_2|+\\cdots + |A_N|$ 之值。若無解的話要輸出 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"-1"}]},{"type":"text","value":"。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"3\nKARIM\nPARBUDI\nCHANDRA\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"16\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"2\nZORO\nANDI\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"-1\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 3"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"7\nHAVE\nFUN\nIN\nICPC\nJAKARTA\nTWENTY\nEIGHTEEN\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 3"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"25\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ 連結"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://codeforces.com/gym/102001/problem/J"},"children":[{"type":"text","value":"Codeforces Gym 102001 - J"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"總之就是很直白的動態規劃囉。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"對於所有 $i$，我們可以先把所有 $S_i$ 的子序列列出來，並且排序好。假設這樣的子序列有 $m_i$ 個（不難得知 $m_i < 2^{|S_i|}$），我們令這樣的序列為 $S_i^{(0)} < S_i^{(1)} < \\cdots < S_i^{(m_i-1)}$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"定義 $\\dp[i][j]$ 為作到第 $i$ 個字串且選取 $A_i \\le S_i^{(j)}$ 的時候，$|A_1|+\\cdots + |A_i|$ 可能的最大值。此時我們可以列出遞迴式："}]},{"type":"text","value":"\n$$\n\\dp[i][j] = \\begin{cases}\n\\max_{k:\\ S_{i-1}^{(k)} < S_i^{(j)}} \\left\\{ \\dp[i-1][k] + |S|\\right\\} \\\\\n\\dp[i][j-1] & \\text{考慮結束在字典順序更小的情形。}\n\\end{cases}\n$$\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"注意到此時 $\\dp[i][0], \\dp[i][1], \\ldots$ 這是一個非遞減的序列。因此要讓 $\\dp[i-1][k] + |S|$ 的值最大，就等價於讓 $k$ 的值盡量大！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"實作上由於 $j$ 變大的時候，對應的 $k$ 也非遞減，我們可以利用 two pointer 的技巧，維護 $j$ 和 $k$ 兩個足標。在 $O(|S_i|\\times 2^{|S_i|})$ 的時間更新一整排的 $\\dp[i][0, \\ldots, m-1]$ 值（在兩個足標追趕的過程中，由於每次都是比較兩個字串，所以需要花 $O(|S_i|)$ 的時間推進一個足標）。因此整體時間複雜度為 $O(\\sum_{1\\le i\\le N} |S_i| 2^{|S_i|}) \\approx O(15^2\\times 2^{15})$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring S[15];\nvector<string> a[15];\nint dp[15][1<<15];\n\n// 產生一個字串的所有子序列。\nvoid GetAllSubstrings(string s, vector<string>& result) {\n  result.push_back(\"\");\n  for (int i = 0; i < (int)s.size(); i++) {\n    int n = result.size();\n    for (int j = 0; j < n; j++) {\n      result.push_back(result[j]+s[i]);\n    }\n  }\n  // 把找到的子序列依照字典順序排序，注意這邊 result[0] 會是空字串。\n  sort(result.begin(), result.end());\n}\n\nint main() {\n  int N;\n  cin >> N;\n  for (int i = 0; i < N; i++) cin >> S[i];\n  for (int i = 0; i < N; i++) GetAllSubstrings(S[i], a[i]);\n\n  const int INF = 1e5;\n  // 初始化動態規劃的首排。\n  dp[0][0] = -INF; // 不允許有空字串，所以給他 -INF。\n  for (int i = 1; i < (1<<S[0].size()); i++)\n    dp[0][i] = max(dp[0][i-1], (int)a[0][i].size());\n\n  // 然後依照遞迴關係計算剩下的部份。\n  for (int i = 1; i < N; i++) {\n    dp[i][0] = -INF; // 一樣不允許有空字串，所以給他 -INF。\n    for (int j = 1, k = 0; j < (1<<S[i].size()); j++) {\n        while (k < (1<<S[i-1].size()) && a[i-1][k] < a[i][j]) ++k;\n        dp[i][j] = max(dp[i][j-1], dp[i-1][k-1] + (int)a[i][j].size());\n    }\n  }\n  \n  int ans = dp[N-1][(1<<S[N-1].size())-1];\n  if (ans < 0) cout << \"-1\" << endl;\n  else cout << ans << endl;\n  return 0;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"備註"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果把所有的字串都預處理產生出來以後，用 Bucket Sort (桶子排序法) 把所有的字串全部排序起來。這麼一來就可以省下硬比較兩字串的時間，可以加速到 $O(15\\times 2^{15})$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"關於競程日記"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"🍅 如果您想到更多有趣漂亮簡單乾淨的解法話歡迎留言給競程日記小編群！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"ℹ️ 這是一篇投稿給"},{"type":"element","tagName":"a","properties":{"href":"https://www.facebook.com/%E7%AB%B6%E7%A8%8B%E6%97%A5%E8%A8%98-1514973425463954/"},"children":[{"type":"text","value":"競程日記"}]},{"type":"text","value":"的文章，歡迎大家投稿、交流與分享程式解題競賽的點點滴滴！"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"Boomerangs","category":"prob","path":"/problem/icpc/asia_jakarta_2018/K","date":"2019-01-07","_PARENT":"30b6970c-145c-5889-a990-647ad0e2e6f5","description":"給定一個有 $N$ 個點和 $M$ 條邊的簡單圖 $G=(V, E)$。我們定義圖 $G$ 上的三元數對 $\\langle u, v, w\\rangle$ 被稱為「迴力標」若且唯若 $\\set{(u, v), (v, w)}\\subseteq E$ 而且 $u\\neq w$。\n\n給你圖 $G$，請找出最大的邊不重複「迴力標集合」。也就是說，你要輸出盡量多的迴力標三元數對，而且沒有一條邊出現在兩個你輸出的迴力標裡面。若有多組解的話，輸出任何一組都可以。\n","link":"https://codeforces.com/gym/102001/problem/K","code":"ICPC-JAKARTA-2018-K","difficulty":4,"oj":"codeforces-gym","tags":["ICPC 2018 Asia Jakarta Regional"]},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"簡化後題目敘述"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"第一列包含兩個正整數 $N, M$ ($1\\le N, M\\le 100000$)。第二列開始有 $M$ 列，每一列包含兩個整數 $u_i, v_i$ ($1\\le u_i < v_i \\le N$) 代表一條圖上的邊，你可以假設圖上的邊不會重複在輸入出現。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸出說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"第一列輸出一個整數 $K$ 表示最大的迴力標集合大小。接下來的 $K$ 列，每一列請輸出三個由單一空白間隔開的整數，代表一個迴力標 $\\langle u, v, w\\rangle$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"5 7\n1 2\n1 4\n2 3\n2 4\n2 5\n3 4\n3 5\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"3\n4 1 2\n4 3 2\n2 5 3\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"4 6\n1 2\n1 3\n1 4\n2 3\n2 4\n3 4\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"3\n1 2 3\n1 3 4\n1 4 2\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 3"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"3 3\n1 2\n1 3\n2 3\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 3"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"1\n2 1 3\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ 連結"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://codeforces.com/gym/102001/problem/K"},"children":[{"type":"text","value":"Codeforces Gym 102001 - K"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這個題目很巧妙地利用了在圖上進行 DFS （或 BFS）遍歷的特性。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我們不妨假設整個圖 $G$ 是連通的，考慮從 $G$ 上面任何一個點出發先做一次 DFS。\n由於這個圖是無向圖，所有的邊會根據搜索的情形被分成兩種：在 DFS 樹上的邊（我們稱為 tree edge）、以及不在樹上的邊（此時稱為 back edge，因為發現時一定連到 DFS 樹上的祖先）。\n我們可以把所有的 back edge「掛在」比較深的點，這麼一來整張圖就會在搜索的過程看起來像是一棵樹（BFS也會有類似的效果）。\n對於這樣的樹來說，我們總可以從「葉子」的部份以 Greedy 的方法每次抓相連的兩條 sibling 邊（他們都是從同一個節點出發找到的），然後把它變成迴力標，然後把兩條邊拔掉。\n不難發現，這種拔法可以保證 (1) 拔完之後整個圖還是連通的、以及 (2) 剩下的圖用「數學歸納法」，保證可以拔出最大迴力標的數量。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"因此，根據以上的演算法，我們也在過程中證明了最大的迴力標數量總是 $\\lfloor |E|/2\\rfloor$ 組。而實作上也可以達到線性複雜度，很小品吧 😃"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"display","properties":{"graph":"","undirected":"","unweighted":"","data":"{\n    \"nodes\": [1, 2, 3, 4, 5],\n    \"edges\": [[1, 2], [1, 4], [2, 4], [2, 3], [3, 4], [2, 5], [3, 5]],\n  }","uihelperIdMap":"{\n        \"[1,2]\":{stroke: \"blue\", strokeWidth: \"5\"},\n        \"[1,4]\":{stroke: \"blue\", strokeWidth: \"5\"},\n        \"[2,4]\":{stroke: \"green\", strokeWidth: \"5\"},\n        \"[2,3]\":{stroke: \"green\", strokeWidth: \"5\"},\n        \"[3,4]\":{stroke: \"red\", strokeWidth: \"5\"},\n        \"[3,5]\":{stroke: \"red\", strokeWidth: \"5\"},\n    }"},"children":[{"type":"text","value":"\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"#include <iostream>\n#include <tuple>\n#include <vector>\nusing namespace std;\n\nint N, M;\nvector<int> a[100005];\nint x[100005], y[100005];\nint used[100005];\nvector<tuple<int, int, int>> ans;\n\nint neighbor(int eid, int u) { return x[eid] + y[eid] - u; }\n\n// 如果 dfs 回來以後還有一條邊沒有被配對，那就回傳這條邊，否則回傳 -1。\nint dfs(int u, int from=-1) {\n  int at_hand = -1;\n  // 依序考慮過所有的邊，但是因為 dfs 會經過同一個點很多次，\n  // 所以不妨用一個類似 stack 的方式實作，每走過一條邊就把這條邊去掉。\n  while (!a[u].empty()) {\n    int eid = a[u].back();\n    a[u].pop_back();\n    if (used[eid]) continue;\n    used[eid] = true;\n    int v = neighbor(eid, u);\n    int ret = dfs(v, eid);\n    if (ret == -1) continue;\n    if (at_hand == -1) {\n      at_hand = ret;\n    } else {\n      ans.emplace_back(v, u, neighbor(at_hand, u));\n      at_hand = -1;\n    }\n  }\n  if (at_hand != -1 && from != -1) {\n    ans.emplace_back(neighbor(at_hand, u), u, neighbor(from, u));\n    return -1;\n  } else if (from != -1) {\n    return from;\n  }\n  return -1;\n}\n\nint main() {\n  cin >> N >> M;\n  for (int i = 0; i < M; i++) {\n    cin >> x[i] >> y[i];\n    a[x[i]].push_back(i);\n    a[y[i]].push_back(i);\n  }\n  // 對於每個點進行 DFS，如果早就探索完了，那相鄰邊也都會被拔光，所以不用擔心重複搜索。\n  for (int i = 1; i <= N; i++) dfs(i);\n  \n  cout << ans.size() << endl;\n  // C++17 Structural Binding 好物，越來越像 python 了。\n  for (auto [u, v, w]: ans)\n    cout << u << \" \" << v << \" \" << w << '\\n';\n  return 0;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"備註 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"其實這題的重點在於把 Graph 透過搜索的過程拆成樹，然後在樹上面做迴力標的分組。大家可以試著用 BFS 寫看看～"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"備註 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"不好意思，今天操作型動畫來不及生出來...如果生出來的圖有點醜的話，大家可以多重新整理幾次喔～"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"關於競程日記"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"🍅 如果您想到更多有趣漂亮簡單乾淨的解法話歡迎留言給競程日記小編群！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"ℹ️ 這是一篇投稿給"},{"type":"element","tagName":"a","properties":{"href":"https://www.facebook.com/%E7%AB%B6%E7%A8%8B%E6%97%A5%E8%A8%98-1514973425463954/"},"children":[{"type":"text","value":"競程日記"}]},{"type":"text","value":"的文章，歡迎大家投稿、交流與分享程式解題競賽的點點滴滴！"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"Bitwise","category":"prob","path":"/problem/icpc/asia_singapore_2018/D","date":"2019-01-16","_PARENT":"3bec3a22-051a-5b03-af06-698e702b39cf","description":"給你 $N$ 個數字 $A_1, A_2, \\ldots, A_N$ **圍成一圈**。你的任務是要把這些數字分成 $K$ 個連續的區段（長度任意），使得每一個區段 OR 起來的值，其 AND 起來的值最大。\n","link":"https://open.kattis.com/problems/bitwise","code":"ICPC-SINGAPORE-D","difficulty":4,"oj":"kattis","tags":["ICPC 2018 Asia Singapore Regional"]},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"簡化後題目敘述"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"第一列有兩個正整數 $N, K$ （$1\\le K\\le N\\le 5\\cdot 10^5$）。\n第二列包含 $N$ 個整數，第 $i$ 個整數為 $A_i$（$0\\le A_i\\le 10^9$）。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸出說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"輸出一個整數。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"4 2\n2 3 4 1\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"3\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"6 3\n2 2 2 4 4 4\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"4\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 3"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"4 1\n0 1 2 3\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 3"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"3\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ 連結"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://open.kattis.com/problems/bitwise"},"children":[{"type":"text","value":"Open Kattis - Bitwise"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"題目出處"}]},{"type":"text","value":"：ICPC 2018 Asia Singapore Regional"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果沒有第一筆範例測資，可能就會誤以為整個序列不是接成一圈。所以有這樣一筆範例測資是很好的。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這題是要求最大化 ${\\tt AND}_{\\text{所有區間}}({\\tt OR}_{x\\in {\\text{區間}}} x)$。如果題目的目標函數改成：最大化 ${\\min}_{\\text{所有區間}}(\\sum_{x\\in {\\text{區間}}} x)$，而且把接成一圈改成一般的直線序列，那就會變成一纇很經典的經典題"},{"type":"element","tagName":"footnote","properties":{"goto":"1","show":"備註1"},"children":[]},{"type":"text","value":"。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"直線版的解法"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"對於經典題來說，一個作法是可以對答案做二分搜尋法：假設我們猜測答案是 $\\ge v$，那麼我們可以使用貪心的方法，從左邊刷過去，只要恰好累積到總和 $\\ge v$ 的區間，就可以把它切斷，然後開始累積下一個新的區間。如果最後能夠蒐集到至少 $K$ 個區間，那就存在一種分區間的方法滿足答案 $\\ge v$ 了。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"當我們從 MIN-SUM 函數換成 AND-OR 函數的時候，也可以如法炮製。不過呢，因為每一個位元實際上是分開的，我們的二分搜尋法可以寫成以下的等價描述：逐步判斷第 $29, 28, \\ldots, 1$ 個 bit 能否出現在答案中；如果可以的話，就把它加進目前搜尋到的目標答案。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"變成環狀"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"現在有個問題，就是不知道該從哪裡開始第一個區間。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我們可以注意到，對於這個問題來說，如果存在一個用上述 greedy 方式切出來的區間切法，那麼區間的結束點，都會出現在 "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"初獲得新的 bit"}]},{"type":"text","value":" 的那個位置。因為每一個數字都只有至多 30 個 bit，所有可能的區間開頭，至多只有 30 種。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"時間複雜度是 $O(30\\times 30\\times N)$。不曉得有沒有快一點的作法？"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"#include <bits/stdc++.h>\nusing namespace std;\n\nint N, K;\nvector<int> A;\n\nbool Test(int mask) {\n  int seeking = 0;\n  for (int start = 0; start < N; start++) {\n    if ((mask&(seeking|A[start])) != (mask&seeking)) {\n      int now = 0, groups = 0;\n      for (int i = start+1; i <= start+N; i++) {\n        now |= A[i];\n        if ((now&mask) == mask) {\n          groups++;\n          now = 0;\n        }\n      }\n      groups += ((now&mask) == mask);\n      if (groups >= K) return true;\n    }\n    seeking |= A[start];\n  }\n  return false;\n}\n\nint main() {\n  cin >> N >> K;\n  A.resize(N*2);\n  for (int i = 0; i < N; i++) cin >> A[i];\n  for (int i = 0; i < N; i++) A[N+i] = A[i];\n  int mask = 0;\n  for (int bit = 29; bit >= 0; bit--) {\n    if (Test(mask + (1<<bit))) {\n      mask += (1<<bit);\n    }\n  }\n  cout << mask << endl;\n  return 0;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"經典題蒐集"},{"type":"element","tagName":"footnote","properties":{"here":"1"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"筆者是在古早的TOI選訓營遇到這個問題的，但現在資料似乎已不可考。以下類似題的目標函數都是：最小化 $\\max_{\\text{所有區間}}(\\sum_{x\\in \\text{區間}} x)$"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://tioj.ck.tp.edu.tw/problems/1432"},"children":[{"type":"text","value":"TIOJ 1432 - 骨牌遊戲"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://tioj.ck.tp.edu.tw/problems/1465"},"children":[{"type":"text","value":"TIOJ 1465 - H遊戲密笈 - EXTREME"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2274"},"children":[{"type":"text","value":"UVa 11299 - Separating Rods"}]},{"type":"text","value":" (感謝夢月提供)"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果輸入的數字並不總是正數，那麼題目就會變難了（因為沒有了貪心法該有的性質：如果 $[i, j]$ 是一個超過總和的區間，$\\Longrightarrow [\\le i, \\ge j]$ 也都超過總和）。大家有興趣可以挑戰一下以下的題目："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://www.spoj.com/problems/SEQPAR/"},"children":[{"type":"text","value":"SPOJ SEQPAR - Partion the sequence"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"關於競程日記"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"🍅 如果您想到更多有趣漂亮簡單乾淨的解法話歡迎留言給競程日記小編群！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"ℹ️ 這是一篇投稿給"},{"type":"element","tagName":"a","properties":{"href":"https://www.facebook.com/%E7%AB%B6%E7%A8%8B%E6%97%A5%E8%A8%98-1514973425463954/"},"children":[{"type":"text","value":"競程日記"}]},{"type":"text","value":"的文章，歡迎大家投稿、交流與分享程式解題競賽的點點滴滴！"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"Wi Know","category":"prob","path":"/problem/icpc/asia_singapore_2018/F","date":"2019-01-15","_PARENT":"0ca94cc0-bb45-586b-be8f-acbbfcb6e43a","description":"給你一個長度為 $N$ 的序列 $S_1, S_2, \\ldots, S_N$，請找出字典順序最小的 $(A, B)$ 配對，使得 $A\\neq B$ 而且這個序列包含至少一個子序列 $A, B, A, B$。\n","link":"https://open.kattis.com/problems/wiknow","code":"ICPC-SINGAPORE-F","difficulty":4,"oj":"kattis","tags":["ICPC 2018 Asia Singapore Regional"]},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"簡化後題目敘述"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"第一列包含一個正整數 $N$ ($1\\le N\\le 400000$)。\n第二列開始有 $N$ 列，每一列包含一個正整數 $S_i$ ($1\\le S_i\\le N$)。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸出說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"若存在答案，請輸出 $A, B$ 之值。若不存在形如 $A, B, A, B$ 的子序列，輸出 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"-1"}]},{"type":"text","value":"。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"8\n1\n3\n2\n4\n1\n5\n2\n4\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"1 2\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"8\n1\n2\n3\n4\n5\n6\n7\n1\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"-1\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 3"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"4\n2\n1\n2\n1\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 3"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"2 1\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ 連結"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://open.kattis.com/problems/wiknow"},"children":[{"type":"text","value":"Open Kattis - Wi Know"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"題目出處"}]},{"type":"text","value":"：ICPC 2018 Asia Singapore Regional"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我們可以先做出以下觀察：如果存在至少一組交錯的子序列 A, B, A, B，那麼 A 總可以是序列中第一次出現的那個 A、而 B 總可以挑選序列中最後一次出現的 B。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"於是，對於每一個 A，我們想知道 A 的右邊的第一個 B、還有跟 A 左邊出現最靠近的 B，滿足這個條件的 B 的最小值。對於一個特定數字 X，那麼我們可以把整個序列，依據所有 X 出現過的位置，切成許多區間。\n利用「掃描線」的概念，從右到左，維護目前跨過這條掃描線的區間們。\n假設現在掃描線所在的位置是一個 A 數字，那麼所有橫跨過這個區間、並且左界落在「第一個 A 的右邊」的那些區間編號最小者，就會是一個可能的答案。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如下圖黑色部份，是我們想查詢的區間。打圈代表我們想知道的左界的確落在範圍內。而打叉代表左界落在範圍外："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"mysvg","properties":{"width":400,"height":200,"viewbox":"0 0 400 200"},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"line","properties":{"x1":"200","x2":"200","y1":"0","y2":"200","stroke":"black","strokeDasharray":"3"},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"text","properties":{"x":"200","y":"16"},"children":[{"type":"text","value":"A"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"text","properties":{"x":"140","y":"16"},"children":[{"type":"text","value":"A"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"text","properties":{"x":"100","y":"16"},"children":[{"type":"text","value":"A"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"line","properties":{"x1":"200","x2":"100","y1":"20","y2":"20","strokeWidth":"4pt","stroke":"black"},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"text","properties":{"x":"110","y":"46","fill":"red"},"children":[{"type":"text","value":"B"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"text","properties":{"x":"70","y":"46","fill":"red"},"children":[{"type":"text","value":"B"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"text","properties":{"x":"150","y":"46","fill":"red"},"children":[{"type":"text","value":"B"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"text","properties":{"x":"230","y":"46","fill":"red"},"children":[{"type":"text","value":"B"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"line","properties":{"x1":"150","x2":"230","y1":"50","y2":"50","strokeWidth":"4pt","stroke":"red"},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"circle","properties":{"cy":"50","cx":"350","r":"10","fill":"none","strokeWidth":"4pt","stroke":"red"},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"text","properties":{"x":"170","y":"76","fill":"gold"},"children":[{"type":"text","value":"C"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"text","properties":{"x":"80","y":"76","fill":"gold"},"children":[{"type":"text","value":"C"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"text","properties":{"x":"260","y":"76","fill":"gold"},"children":[{"type":"text","value":"C"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"line","properties":{"x1":"170","x2":"260","y1":"80","y2":"80","strokeWidth":"4pt","stroke":"gold"},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"circle","properties":{"cy":"80","cx":"350","r":"10","fill":"none","strokeWidth":"4pt","stroke":"gold"},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"text","properties":{"x":"270","y":"106","fill":"green"},"children":[{"type":"text","value":"D"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"text","properties":{"x":"60","y":"106","fill":"green"},"children":[{"type":"text","value":"D"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"line","properties":{"x1":"270","x2":"60","y1":"110","y2":"110","strokeWidth":"4pt","stroke":"green"},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"path","properties":{"d":"M 340,100 L 360,120 M 340,120 L 360,100","strokeWidth":"4pt","stroke":"green"},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"text","properties":{"x":"120","y":"136","fill":"blue"},"children":[{"type":"text","value":"E"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"text","properties":{"x":"240","y":"136","fill":"blue"},"children":[{"type":"text","value":"E"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"line","properties":{"x1":"120","x2":"240","y1":"140","y2":"140","strokeWidth":"4pt","stroke":"blue"},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"circle","properties":{"cy":"140","cx":"350","r":"10","fill":"none","strokeWidth":"4pt","stroke":"blue"},"children":[]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"那麼我們只要找出與黑色區間相交的「最小編號」區間就可以了！實作上我們維護一個區間樹，當掃描線從右掃到左的時候，先將「離開的區間」刪掉，然後再依據當前區間 $[\\ell, r]$，查詢現在「左界 $>\\ell$」的區間編號最小值。然後再將當前區間左界加入區間樹。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"#include <bits/stdc++.h>\nusing namespace std;\n\n// 關於區間樹的操作：依序為插入、刪除、詢問。\nconst int LEAF_OFFSET = (1<<19);\nint tree[(1<<20)];\ninline int GetMinLabel(int l, int r) {\n  if (l == 0 || r == 0) return l+r;\n  return min(l, r);\n}\nvoid Insert(int x, int label) {\n  x += LEAF_OFFSET;\n  tree[x] = label;\n  for (x/=2; x; x/=2)\n    tree[x] = GetMinLabel(tree[x*2], tree[x*2+1]);\n}\nvoid Remove(int x) {\n  x += LEAF_OFFSET;\n  tree[x] = 0;\n  for (x/=2; x; x/=2)\n    tree[x] = GetMinLabel(tree[x*2], tree[x*2+1]);\n}\nint Query(int l) {\n  l += LEAF_OFFSET;\n  int ans = tree[l];\n  while (l) {\n    if (l%2==0)\n      ans = GetMinLabel(ans, tree[l+1]);\n    l/=2;\n  }\n  return ans;\n}\n\n\n// 紀錄輸入的序列。\nint S[400005];\nvector<int> positions[400005];\n\npair<int, int> best = {-1, -1};\nvoid UpdateSolution(int A, int B) {\n  if (best.first == -1 || best > make_pair(A, B)) {\n    best = {A, B};\n  }\n}\n\nvoid OutputAnswer() {\n  if (best.first == -1) cout << \"-1\" << endl;\n  else cout << best.first << \" \" << best.second << endl;\n}\n\nint main() {\n  int N;\n  cin >> N;\n  for (int i = 0; i < N; i++) {\n    cin >> S[i];\n    positions[S[i]].push_back(i);\n  }\n  for (int i = N-1; i >= 0; i--) {\n    int A = S[i];\n    positions[A].pop_back();\n    Remove(i);\n    if (!positions[A].empty()) {\n      int B = Query(positions[A][0]);\n      if (B > 0) UpdateSolution(A, B);\n      Insert(positions[A].back(), A);\n    }\n  }\n  OutputAnswer();\n  return 0;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"夢月說"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"花一分鐘想不出來，花三分鐘就想到了！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"關於競程日記"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"🍅 如果您想到更多有趣漂亮簡單乾淨的解法話歡迎留言給競程日記小編群！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"ℹ️ 這是一篇投稿給"},{"type":"element","tagName":"a","properties":{"href":"https://www.facebook.com/%E7%AB%B6%E7%A8%8B%E6%97%A5%E8%A8%98-1514973425463954/"},"children":[{"type":"text","value":"競程日記"}]},{"type":"text","value":"的文章，歡迎大家投稿、交流與分享程式解題競賽的點點滴滴！"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"Rectangular City","category":"prob","path":"/problem/icpc/asia_singapore_2018/G","date":"2019-01-17","_PARENT":"535b61bd-d75b-5fda-b990-f21639622bc1","description":"給你 $N, R, C, K$，請問有多少種長度為 $N$ 的矩形序列，其中每一個矩形的四個頂點座標範圍都是介於 $[0, 0]\\times [R, C]$ 之間的整數，而且這 $N$ 個矩形交集面積至少有 $K$ 這麼大。\n\n對於任兩個序列，只要存在其中一個矩形位置或大小不同，就視為不同的序列。輸出答案除以 $10^9+7$ 之值。\n","link":"https://open.kattis.com/problems/rectangularcity","code":"ICPC-SINGAPORE-G","difficulty":4,"oj":"kattis","tags":["ICPC 2018 Asia Singapore Regional","combinatorics"]},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"簡化後題目敘述"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"輸入僅有一列包含四個正整數 $N, R, C, K$。（$1\\le N\\le 10^6; 1\\le R, C\\le 5000; 1\\le K\\le R\\cdot C$）"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸出說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"輸出可能的矩形序列數量除以 $10^9+7$ 的餘數。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"2 2 3 4\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"7\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ 連結"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://asiasg18.kattis.com/problems/rectangularcity"},"children":[{"type":"text","value":"Open Kattis - Rectangular City"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"題目出處"}]},{"type":"text","value":"：ICPC 2018 Asia Singapore Regional"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"今天是個輕巧的組合數學題喔！記分板上看起來解出來的隊伍數量不多，很可能是因為跟題效應的關係，導致後來大家都把時間花在寫起來比較複雜的題目上了。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"（記分板排名比較沒那麼前面的部份也有隊伍答對這題。這種跡象出現的時候，通常代表這題會有程式碼較短的解法，或是題目出壞了。這取決於是哪裡辦的比賽...不說了先解題）"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我們可以先考慮所有矩形交集的位置。接著，不難發現我們可以把兩個座標軸拆開來。任何 X 座標上交集後長度為 $c$ 的區間們，與任何 Y 座標上交集後長度為 $r$ 的區間們，的任意組合，都可以產生出"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"不同的"}]},{"type":"text","value":"、而且交集面積恰好是 $c\\times r$ 的矩形序列。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我們只要枚舉 $r, c$，當 $rc\\ge K$ 的時候把兩邊方法數乘起來、加至總和即可。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"所以現在問題便轉化成一維上的問題了！而一維的問題也只需要枚舉。考慮 $N$ 個 $[0, R]$ 之間的區間，我們希望最終他們的交集長度恰好為 $r$，那我們可以枚舉交集的位置：可能是 $[0, r], [1, r+1], \\ldots, [R-r, R]$。對於位置 $[i, r+i]$，我們再次分離左右界：左界可以選擇 $\\set{0, 1, \\ldots, i}$ 任何一個、並且至少有一個要踩到 $i$。右界可以選擇 $\\set{r+i, r+i+1, \\ldots, R}$ 的任何一個，而且至少有一個要踩到 $r+i$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"因此，在限制交集範圍恰好是 $[i, r+i]$ 的情形下，左界的選法數有 $(i+1)^N-i^N$ 種。如法炮製得右界方法數有 $(R-r-i+1)^N-(R-r-i)^N$ 種。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n\nconst LL MOD = 1e9 + 7;\n\nLL bigmod(LL a, LL n) {\n  LL b = 1;\n  while (n) {\n    if (n % 2)\n      b = b * a % MOD;\n    a = a * a % MOD;\n    n /= 2;\n  }\n  return b;\n}\n\nLL npower[5005];\nLL X[5005], Y[5005];\n\nint main() {\n  int N, R, C, K;\n  cin >> N >> R >> C >> K;\n  for (int i = 1; i <= 5000; i++)\n    npower[i] = bigmod(i, N);\n  for (int r = 0; r <= R; r++) {\n    for (int i = 0; i <= R - r; i++) {\n      X[r] += (npower[i + 1] - npower[i]) *\n              (npower[R - r - i + 1] - npower[R - r - i]) % MOD;\n    }\n    X[r] = (X[r] % MOD + MOD) % MOD;\n  }\n  for (int c = 0; c <= C; c++) {\n    for (int i = 0; i <= C - c; i++) {\n      Y[c] += (npower[i + 1] - npower[i]) *\n              (npower[C - c - i + 1] - npower[C - c - i]) % MOD;\n    }\n    Y[c] = (Y[c] % MOD + MOD) % MOD;\n  }\n\n  LL ans = 0;\n  for (int r = 1; r <= R; r++)\n    for (int c = 1; c <= C; c++) {\n      if (r * c >= K) {\n        ans += X[r] * Y[c] % MOD;\n      }\n    }\n  cout << ans % MOD << endl;\n  return 0;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"題外話"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"同一場比賽的 Problem A 明明就比這題需要的知識點難一些，為什麼過山過海呀 =口="}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"關於競程日記"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"🍅 如果您想到更多有趣漂亮簡單乾淨的解法話歡迎留言給競程日記小編群！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"ℹ️ 這是一篇投稿給"},{"type":"element","tagName":"a","properties":{"href":"https://www.facebook.com/%E7%AB%B6%E7%A8%8B%E6%97%A5%E8%A8%98-1514973425463954/"},"children":[{"type":"text","value":"競程日記"}]},{"type":"text","value":"的文章，歡迎大家投稿、交流與分享程式解題競賽的點點滴滴！"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"Conveyor Belts","category":"prob","path":"/problem/icpc/asia_singapore_2018/K","date":"2019-01-20","_PARENT":"aafd5b18-7a5b-53a5-b233-46cc9df6d7b3","description":"有 $N$ 個貨品集散地，以及 $M$ 條連接機器與機器之間的輸送帶。每個輸送帶每分鐘可以運送 $1$ 個貨品。恰好有 $K$ 個生產貨品的機器正在運作當中，他們的位置剛好分別在第 $1, 2, \\ldots, K$ 個貨品集散地。他們每 $K$ 分鐘就會做好一份貨品：對任意非負整數 $x\\ge 0$，編號為 $j$ 的機器會恰好在第 $xK+j$ 分鐘產出一份貨品。\n\n貨品可以經過任意事先指定的路線被送往編號為 $N$ 的貨品集散地。兩個以上的貨物可以同時被輸送至任一個集散地，上頭的機器手臂會以可忽略（即時）的速度將貨物轉送至其他輸送帶上面。\n\n請問至多可以保留多少運作中的生產機器，才能夠保證貨物輸送順暢？\n","link":"https://open.kattis.com/problems/conveyorbelts","code":"ICPC-SINGAPORE-K","difficulty":5,"oj":"kattis","tags":["ICPC 2018 Asia Singapore Regional"]},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"簡化後題目敘述"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"輸入第一列包含三個整數 $N, K, M$ ($1\\le N, K\\le 300; 0\\le M\\le 1000$)，代表貨物集散地、生產機器、以及輸送帶的數量。\n接下來的 $M$ 列每一列有兩個正整數 $a, b$ ($1\\le a, b\\le N$)，代表有一條輸送帶可將貨物從編號 $a$ 的集散地送往編號為 $b$ 的集散地。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸出說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"請輸出最多可保留的生產機器數量。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"4 2 3\n1 3\n2 3\n3 4\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"2\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"5 2 4\n1 3\n3 4\n2 4\n4 5\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"1\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 3"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"5 2 6\n1 4\n2 3\n3 4\n4 5\n2 4\n3 3\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 3"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"2\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ 連結"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://open.kattis.com/problems/conveyorbelts"},"children":[{"type":"text","value":"Open Kattis - Conveyor Belts"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"題目出處"}]},{"type":"text","value":"：ICPC 2018 Asia Singapore Regional"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"注意到每固定 $K$ 分鐘就會有個循環，如果某條輸送帶在第 $x$ 分鐘是有東西的，那麼它在第 $x+K, x+2K, \\ldots$ 分鐘也會有東西。因此，我們可以把整張圖複製 $K$ 份，原本的圖上的點 $i$ 會變成 $i_0, i_1, \\ldots, i_{K-1}$，而原本圖上的邊 $(i, j)$ 會變成 $K$ 條邊：經過了這條輸送帶以後，時間會從模 $K$ 餘 $r$ 變成模 $K$ 餘 $(r+1)\\%K$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"剩下就交給 flow 啦～正確的找出每個貨品產生的起點 $i_i$，然後試圖找出一條增廣路徑到任何一個原本編號是 $N$ 的節點 $N_r$。最大流量就是能夠生產的貨品數。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"由於我們構造出來的圖上所有邊都是單位流量，因此使用 Dinitz 演算法時間複雜度會是 $O(\\text{邊數}\\cdot \\min\\left(\\sqrt{\\text{邊數}}, \\text{點數}^{2/3}\\right)) = O((MK)^{1.5}) \\approx 1.6\\times 10^8$。在以下的程式碼中，我稍微偷懶了一下直接用類似二分圖匹配的方法 DFS 找出增廣路徑（在沒找到增廣路徑時不更新現有 DFS 標記），似乎跑起來滿快的，不小心就變成當下最快的上傳紀錄了 (0.06s)。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Edge {\n  int to, cap, rev;\n  Edge(int _to, int _cap, int _rev): to(_to), cap(_cap), rev(_rev) {}\n};\n\nclass FlowNetwork {\n  public:\n    int n, sink;\n    vector<vector<Edge>> adj;\n    int mark;\n    vector<int> marks;\n    FlowNetwork(int _n, int _sink): n(_n), sink(_sink) {\n      adj.resize(n);\n      marks.resize(n, 0);\n      mark = 1;\n    }\n    void AddEdge(int x, int y, int c = 1) {\n      adj[x].emplace_back(y, c, adj[y].size());\n      adj[y].emplace_back(x, 0, adj[x].size()-1);\n    }\n    bool _DFS(int x) {\n      marks[x] = mark;\n      if (x == sink) return true;\n      for (auto& e: adj[x]) {\n        if (marks[e.to] != mark && e.cap > 0 && _DFS(e.to)) {\n          adj[e.to][e.rev].cap++;\n          e.cap--;\n          return true;\n        }\n      }\n      return false;\n    }\n    bool DFS(int s) {\n      if (_DFS(s)) {\n        mark++;\n        return true;\n      }\n      return false;\n    }\n};\n\nint main() {\n  int N, K, M;\n  cin >> N >> K >> M;\n  FlowNetwork g(N*K+1, N*K);\n  auto enc = [&](int i, int j) {\n    return (i-1)*K+j;\n  };\n  for (int j = 0; j < K; j++)\n    g.AddEdge(enc(N, j), g.sink, K);\n  while (M--) {\n    int x, y;\n    cin >> x >> y;\n    for (int j = 0; j < K; j++)\n      g.AddEdge(enc(x, j), enc(y, (j+1)%K));\n  }\n  int ans = 0;\n  for (int i = 1; i <= K; i++) {\n    if (g.DFS(enc(i, i%K)))\n      ++ans;\n  }\n  cout << ans << endl;\n  return 0;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"關於競程日記"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"🍅 如果您想到更多有趣漂亮簡單乾淨的解法話歡迎留言給競程日記小編群！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"ℹ️ 這是一篇投稿給"},{"type":"element","tagName":"a","properties":{"href":"https://www.facebook.com/%E7%AB%B6%E7%A8%8B%E6%97%A5%E8%A8%98-1514973425463954/"},"children":[{"type":"text","value":"競程日記"}]},{"type":"text","value":"的文章，歡迎大家投稿、交流與分享程式解題競賽的點點滴滴！"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"Prolonged Password","category":"prob","path":"/problem/icpc/asia_singapore_2018/I","date":"2019-01-19","_PARENT":"a2859324-be06-5933-a33f-6277d067194d","description":"給你一個初始字串 $S$，然後根據函數 $f$ 構造密碼 $P=f^K(S)$。函數 $f$ 的操作如下：對於 $S$ 的所有字元，把該字元同時換成對應的字串。同一個字元對應到的替換字串是固定的，如果看到 `a` 就換成 $T_a$、看到 `b` 就換成 $T_b$、依此類推。\n\n給你 $M$ 個詢問。每一個詢問都會讀取一個整數 $m_i$，並且要你回答出密碼 $P$ 的第 $m_i$ 個字元為何。\n","link":"https://open.kattis.com/problems/prolongedpassword","code":"ICPC-SINGAPORE-I","difficulty":6,"oj":"kattis","tags":["ICPC 2018 Asia Singapore Regional"]},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"簡化後題目敘述"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"第一列包含一個字串 $S$, ($1\\le |S|\\le 1000000$)。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"第二列包含 13 個字串 $T_a, T_b, \\ldots, T_m$。($2\\le |T_a|, |T_b|, \\ldots, |T_m| \\le 50$)"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"第三列包含 13 個字串 $T_n, T_o, \\ldots, T_z$。($2\\le |T_n|, |T_o|, \\ldots, |T_z| \\le 50$)"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"第四列包含一個整數 $K$ ($1\\le K\\le 10^{15}$)。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"第五列包含一個整數 $M$ ($1\\le M\\le 1000$)。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"第六列包含 $M$ 個整數，第 $i$ 個整數為 $m_i$，其中 $1\\le m_i\\le \\min(|f^K(S)|, 10^{15})$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸出說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"對於每一個詢問，單獨輸出所求字元於一列。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"abca\nbc cd da dd ee ff gg hh ii jj kk ll mm\nnn oo pp qq rr ss tt uu vv ww xx yy zz\n1\n2\n1 8\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"b\nc\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"ab\nba ab cc dd ee ff gg hh ii jj kk ll mm\nnn oo pp qq rr ss tt uu vv ww xx yy zz\n2\n2\n1 8\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"a\nb\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ 連結"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://open.kattis.com/problems/prolongedpassword"},"children":[{"type":"text","value":"Open Kattis - Prolonged Password"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"題目出處"}]},{"type":"text","value":"：ICPC 2018 Asia Singapore Regional"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我們可以把函數 $f$ 迭代的過程展開成樹狀圖。而依照順序遍歷葉節點的時候，就相當於把最終的密碼 $P$ 印出來。如果要取得第 $m_i$ 個字元，那麼我們要找的便是由左至右數來第 $m_i$ 個葉子。下圖是第一筆範例以字母 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"a"}]},{"type":"text","value":" 開頭展開三層的樣子。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"display","properties":{"binaryTree":"","complete":"","depth":"4","uihelperContentMap":"{\n        \"a\": {font: \"24pt monospace\", fontColor: \"red\"},\n        \"b\": {font: \"24pt monospace\", fontColor: \"blue\"},\n        \"c\": {font: \"24pt monospace\", fontColor: \"green\"},\n        \"d\": {font: \"24pt monospace\", fontColor: \"gold\"},\n        }","data":"{\n        value: [\"a\", \"b\", \"c\", \"c\", \"d\", \"d\", \"a\", \"d\", \"a\", \"d\", \"d\", \"d\", \"d\", \"b\", \"c\"]\n    }"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果我們從根節點（某個字元 $\\alpha$）開始，事先知道每一個子樹的大小，就可以在 $|T_\\alpha|$ 的時間內直接前往帶有第 $m_i$ 個葉子的子樹。因此，預處理以後我們可以在 $O(50\\times K)$ 的時間內走到我們想要的葉節點。可惜的是，$K$ 太大了，而且整棵樹的大小不見得存得下。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"好消息是，會詢問的數字頂多只有 $10^{15}$，我們可以把超過的部份完全忽略掉：也就是說，對於超過 $10^{15}$ 大小的子樹，我們不需要精確計算其大小，只要標記成「唉呀太大了」就可以了。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"此外，還有另一個方便實作的好消息：題目的條件保證了每一個 $T_\\alpha$ 長度至少有 2。這代表什麼呢？我們只要關心最靠近底層的 $\\log_2(10^{15})\\approx 50$ 層就行啦！如果整棵樹太高，一開始我們只要想辦法從樹根，每次挑選第一個子節點往下走，快速抵達最底下的 50 層就行了～"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"注意到字串僅包含小寫英文字母，從上面往下走得過程，至多 26 步就會產生一個循環。我們可以快速跳過若干循環節，到第 $50+O(1)$ 層停下來。然後從那個地方開始進行前述的「搜索」過程，而且一開始也只需要紀錄 50 層左右的子樹的大小。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"為了方便起見，我直接紀錄到 63 層，往下找循環的時候，也是直接跳到 100 層左右，然後再一個一個走下去。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\nstring S;\nstring T[26];\nLL K;\n\nLL len[26][64];\nconst LL LIMIT = (LL)1e15;\n\nvoid add(LL &x, LL v) {\n  // -1 代表超過長度。\n  if (x == -1 || v == -1) {\n    x = -1;\n  } else {\n    x += v;\n    if (x >= LIMIT)\n      x = -1;\n  }\n}\n\nvoid pre() {\n  for (int i = 0; i < 26; i++) {\n    len[i][0] = 1;\n    len[i][1] = T[i].size();\n  }\n  for (int t = 2; t < 64; t++)\n    for (int i = 0; i < 26; i++)\n      for (auto x : T[i])\n        add(len[i][t], len[x - 'a'][t - 1]);\n}\n\nchar ans;\n\n// 如果還不夠的話就回傳 false，如果找到了就回傳 true.\nbool ask(LL &m, char root, LL k) {\n  if (k == 0) {\n    --m;\n    ans = root;\n    return (m == 0);\n  }\n  if (k < 64 && len[root - 'a'][k] != -1 && len[root - 'a'][k] < m) {\n    m -= len[root - 'a'][k];\n    return false;\n  }\n  if (k <= 100) {\n    for (auto child : T[root - 'a']) {\n      if (ask(m, child, k - 1)) {\n        return true;\n      }\n    }\n  } else {\n    // 找出 cycle, 然後飛到第一個小於100層的地方。\n    int pos[26] = {};\n    int now = root - 'a';\n    int cnt = 1;\n    while (pos[now] == 0) {\n      pos[now] = cnt;\n      now = T[now][0] - 'a';\n      cnt++;\n    }\n    int cycle = cnt - pos[now];\n    k -= (cnt - 1);\n    k -= (k - 100) / cycle * cycle;\n    k -= cycle;\n    return ask(m, now + 'a', k);\n  }\n  return false;\n}\n\nvoid solve() {\n  LL m;\n  cin >> m;\n  for (size_t i = 0; i < S.size(); i++) {\n    if (ask(m, S[i], K))\n      break;\n  }\n  cout << ans << '\\n';\n}\n\nint main() {\n  cin >> S;\n  for (int i = 0; i < 26; i++)\n    cin >> T[i];\n  cin >> K;\n  // 預處理，計算不超過 64 層，以某字元為樹根的子樹大小。\n  pre();\n\n  int M;\n  cin >> M;\n  while (M--)\n    solve();\n  return 0;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"關於競程日記"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"🍅 如果您想到更多有趣漂亮簡單乾淨的解法話歡迎留言給競程日記小編群！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"ℹ️ 這是一篇投稿給"},{"type":"element","tagName":"a","properties":{"href":"https://www.facebook.com/%E7%AB%B6%E7%A8%8B%E6%97%A5%E8%A8%98-1514973425463954/"},"children":[{"type":"text","value":"競程日記"}]},{"type":"text","value":"的文章，歡迎大家投稿、交流與分享程式解題競賽的點點滴滴！"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"Sliding Blocks","category":"prob","path":"/problem/icpc/asia_singapore_2018/H","date":"2019-01-18","_PARENT":"b84301d0-3354-5aa2-b4c2-a367f3ae7c44","description":"在一個 $N\\times M$ 大小的方格棋盤上，一開始恰好有一個格子上頭有個方塊，而棋盤的其他地方都是空的。現在，你可以逐步把一些方塊從棋盤的邊界，沿著水平或垂直方向**滑入**棋盤中。放入棋盤的方塊會一直滑，直到撞到某個現存於棋盤上的方塊停止。\n\n現在給你一個盤面，已知第一塊初始的方塊位置。請問能否用滑的滑出這個盤面？保證輸入的盤面所有方塊的位置連接成一棵樹：也就是說，如果我們把方塊當作節點、緊黏著邊的兩個方塊建立一條邊，那麼整個圖會形成一棵樹。\n","link":"https://open.kattis.com/problems/slidingblocks","code":"ICPC-SINGAPORE-H","difficulty":5,"oj":"kattis","tags":["ICPC 2018 Asia Singapore Regional"]},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"簡化後題目敘述"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"第一列有三個正整數 $N, M, B$ （$1\\le N, M, B\\le 4\\cdot 10^5$），依序代表棋盤的列數與行數，還有方格總數。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"接下來有 $B$ 列，每一列有兩個數字 $r, c$ （$1\\le r\\le N$; $1\\le c\\le M$）代表方格的位置。這 $B$ 列中的第一列，包含了初始方塊的位置。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸出說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果不存在任何構造棋盤上方塊的方式，請輸出 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"impossible"}]},{"type":"text","value":"。否則的話，輸出 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"possible"}]},{"type":"text","value":"，然後從第二列開始輸出 $B-1$ 列，每一列包含一個滑入方塊的指令：首先有一個方向 $c\\in\\{$ "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"<"}]},{"type":"text","value":", "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":">"}]},{"type":"text","value":", "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"^"}]},{"type":"text","value":", "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"v"}]},{"type":"text","value":" $\\}$。然後會跟著滑入方塊的列號($r$) 或行號($c$)。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"3 4 6\n1 1\n1 2\n2 2\n2 3\n3 3\n3 4\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"possible\n< 1\n^ 2\n< 2\n^ 3\n< 3\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"3 4 9\n3 1\n2 1\n1 1\n1 2\n1 3\n1 4\n2 4\n3 4\n3 3\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"impossible\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ 連結"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://open.kattis.com/problems/slidingblocks"},"children":[{"type":"text","value":"Open Kattis - Sliding Blocks"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"題目出處"}]},{"type":"text","value":"：ICPC 2018 Asia Singapore Regional"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"因為棋盤上的所有方塊會形成一棵樹，所以我們從初始方塊開始進行 DFS/BFS，就可以得知每一個方塊滑入的方向了。根據這個滑入的方向，同一行或同一列的相鄰方塊，必須有先後順序才行（總不能先把鄰居都放進去，這樣自己就滑不進去了）。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"因此，只要準確掌握好先後順序，最後進行一個拓撲排序，就可以把答案找出來啦！請參考落落長的程式碼。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"在程式碼中，我們使用了一些小撇步（不見得是必要的，但總之我是這樣寫了...）。比方說，我們把四個方向定義成左右一組、上下一組，這麼一來要存取"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"反方向"}]},{"type":"text","value":"的時候，只要透過 XOR 1 就可以了(比方說 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"dir^1"}]},{"type":"text","value":")。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXB = 400005;\nint r[MAXB], c[MAXB];\n\nconst vector<string> DSTR = {\">\", \"<\", \"v\", \"^\"};\nstring s[MAXB];\nint face[MAXB];\nint visit[MAXB];\nint link[MAXB][4];\nvector<pair<int, int>> rows[MAXB], cols[MAXB];\n\n// 定義四個方向。\nenum {\n  LEFT = 0,\n  RIGHT = 1,\n  UP = 2,\n  DOWN = 3\n};\n\ninline bool IsNeighbor(int x, int y) {\n  return abs(r[x]-r[y]) + abs(c[x]-c[y]) == 1;\n}\n\nvoid dfs(int x) {\n  visit[x] = 1;\n  for (int dir = 0; dir < 4; dir++) {\n    int y = link[x][dir];\n    if (IsNeighbor(x, y) && !visit[y]) {\n      face[y] = (dir^1);\n      s[y] = DSTR[dir] + \" \" + to_string(dir/2? c[y]: r[y]);\n      dfs(y);\n    }\n  }\n}\n\n// 紀錄優先順序 (得先有 y 才能有 x)。\nvector<int> deps[MAXB];\ninline void AddLink(int x, int y) {\n  if (x == -1 || y == -1) return;\n  deps[x].push_back(y);\n}\n\n// 紀錄解答用的。\nvector<int> solution;\nbool no_solution = false;\nvoid topological_sort(int x) {\n  visit[x] = 1;\n  for (auto y : deps[x]) {\n    if (visit[y] == 0)\n      topological_sort(y);\n    else if (visit[y] == 1)\n      no_solution = 1;\n  }\n  solution.push_back(x);\n  visit[x] = 2;\n}\n\nint main() {\n  int N, M, B;\n  cin >> N >> M >> B;\n  for (int i = 0; i < B; i++) {\n    cin >> r[i] >> c[i];\n    rows[r[i]].push_back({c[i], i});\n    cols[c[i]].push_back({r[i], i});\n  }\n  for (int i = 1; i < MAXB; i++) {\n    sort(rows[i].begin(), rows[i].end());\n    sort(cols[i].begin(), cols[i].end());\n  }\n\n  memset(link, -1, sizeof(link));\n  for (int i = 1; i < MAXB; i++) {\n    for (size_t j = 1; j < rows[i].size(); j++) {\n      int prev = rows[i][j-1].second;\n      int now = rows[i][j].second;\n      link[prev][RIGHT] = now;\n      link[now][LEFT] = prev;\n    }\n    for (size_t j = 1; j < cols[i].size(); j++) {\n      int prev = cols[i][j-1].second;\n      int now = cols[i][j].second;\n      link[prev][DOWN] = now;\n      link[now][UP] = prev;\n    }\n  }\n  dfs(0);\n  for (int x = 1; x < B; x++) {\n    AddLink(x, link[x][face[x]]);\n    AddLink(link[x][face[x]^1], x);\n  }\n  memset(visit, 0, sizeof(visit));\n  for (int x = 0; x < B; x++) {\n    if (!visit[x])\n      topological_sort(x);\n  }\n  if (no_solution) {\n    cout << \"impossible\" << endl;\n  } else {\n    cout << \"possible\" << '\\n';\n    for (auto x : solution)\n      if (x != 0)\n        cout << s[x] << '\\n';\n  }\n  return 0;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"關於競程日記"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"🍅 如果您想到更多有趣漂亮簡單乾淨的解法話歡迎留言給競程日記小編群！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"ℹ️ 這是一篇投稿給"},{"type":"element","tagName":"a","properties":{"href":"https://www.facebook.com/%E7%AB%B6%E7%A8%8B%E6%97%A5%E8%A8%98-1514973425463954/"},"children":[{"type":"text","value":"競程日記"}]},{"type":"text","value":"的文章，歡迎大家投稿、交流與分享程式解題競賽的點點滴滴！"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"Non-Prime Factors","category":"prob","path":"/problem/icpc/asia_singapore_2018/L","date":"2019-01-19","_PARENT":"d2c8a567-4fd8-53a5-a1bc-6aee8f18f73c","description":"給你 $Q$ 個正整數，對於每一個正整數 $n$，請你回答 $n$ 有多少個非質數的因數？\n","link":"https://open.kattis.com/problems/nonprimefactors","code":"ICPC-SINGAPORE-L","difficulty":2,"oj":"kattis","tags":["ICPC 2018 Asia Singapore Regional"]},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"簡化後題目敘述"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"第一列有一個正整數 $Q$ ($1\\le Q\\le 3\\cdot 10^6$)。接下來的 $Q$ 列每一列有一個正整數 $i$ ($2\\le i\\le 2\\cdot 10^6$)。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸出說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"對每個詢問輸出答案於一行。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"4\n100\n13\n12\n2018\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"7\n1\n4\n2\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ 連結"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://open.kattis.com/problems/nonprimefactors"},"children":[{"type":"text","value":"Open Kattis - Non-Prime Factors"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"題目出處"}]},{"type":"text","value":"：ICPC 2018 Asia Singapore Regional"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"計算總因數個數減去質因數個數就行啦。一般來說直接用篩法是 $O(N\\log\\log N)$ 時間"},{"type":"element","tagName":"footnote","properties":{"goto":"1","show":"備註1"},"children":[]},{"type":"text","value":"，所以已經很足夠了。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"在假設乘除法都是 $O(1)$ 的情形下（但可以證明 bit 數量不固定時，計算乘除必須要 $\\omega(1)$ 的時間，所以理論上乘除法不應該被視為常數。）下面程式碼範例使用的是線性時間的篩法 $O(N)$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"快速 I/O 感覺真的滿重要的。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 2000005;\nvector<int> primes;\nint almost_factors[N];\nint prime_factors[N];\nint min_power[N];\nint min_prime[N];\n\nchar s[32];\nvoid ReadInt(int &x) {\n  x = 0;\n  fgets(s, 32, stdin);\n  for (int i=0;s[i] >= '0';i++) {\n    x=x*10+s[i]-'0';\n  }\n}\n\nstring output;\nvoid WriteBuffer(int y) {\n  if (output.size()) output += '\\n';\n  output += to_string(y);\n}\n\nint main() {\n  for (int i = 2; i < N; i++) {\n    if (prime_factors[i] == 0) {\n      primes.push_back(i);\n      almost_factors[i] = 1;\n      prime_factors[i] = 1;\n      min_power[i] = 1;\n      min_prime[i] = i;\n    }\n    for (int j = 0; i * primes[j] < N; j++) {\n      int p = primes[j];\n      if (p != min_prime[i]) {\n        almost_factors[i * p] = almost_factors[i] * (min_power[i]+1);\n        prime_factors[i * p] = prime_factors[i] + 1;\n        min_power[i * p] = 1;\n        min_prime[i * p] = p;\n      } else {\n        almost_factors[i * p] = almost_factors[i];\n        prime_factors[i * p] = prime_factors[i];\n        min_power[i * p] = min_power[i] + 1;\n        min_prime[i * p] = min_prime[i];\n        break;\n      }\n    }\n  }\n\n  int Q, x;\n  //ios_base::sync_with_stdio(false);\n  //cin.tie(NULL);\n  //cin >> Q;\n  ReadInt(Q);\n  while (Q--) {\n    ReadInt(x);\n    WriteBuffer(almost_factors[x] * (min_power[x]+1) - prime_factors[x]);\n  }\n  puts(output.c_str());\n  return 0;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"備註 1"},{"type":"element","tagName":"footnote","properties":{"here":"1"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"關於篩法的時間複雜度之超單純證明，請容許我自肥一下，請參考以下連結："},{"type":"element","tagName":"a","properties":{"href":"https://tmt514.github.io/competitive-programming/2017/11/17/elementary-proof-on-analysis-of-eratosthenes-sieve.html"},"children":[{"type":"text","value":"https://tmt514.github.io/competitive-programming/2017/11/17/elementary-proof-on-analysis-of-eratosthenes-sieve.html"}]},{"type":"text","value":"。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"關於競程日記"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"🍅 如果您想到更多有趣漂亮簡單乾淨的解法話歡迎留言給競程日記小編群！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"ℹ️ 這是一篇投稿給"},{"type":"element","tagName":"a","properties":{"href":"https://www.facebook.com/%E7%AB%B6%E7%A8%8B%E6%97%A5%E8%A8%98-1514973425463954/"},"children":[{"type":"text","value":"競程日記"}]},{"type":"text","value":"的文章，歡迎大家投稿、交流與分享程式解題競賽的點點滴滴！"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"[ECNA2018B] Difference","category":"prob","path":"/problem/icpc/ecna2018/B","date":null,"_PARENT":"58477d25-748d-5907-8f90-20e2821e8a1c","description":"小差距序列(SDS) 是一個由正整數定義而成的序列。它的描述如下：首項 $A_1$ 為一個正整數 $r\\ge 1$。對於 $n>1$，定義 $A_n = A_{n-1}+d$，其中 $d$ 是最小的正整數，使得對於任意 $1\\le i<j<n$，$d\\neq A_j-A_i$。此外 $d$ 也不能等於任意一個當前數列的值。給定 $r$ 以及 $m$ 值($1\\le r \\le 100, 1\\le m\\le 200000000$)，請找出最小的 $n$ 使得要嘛 $m=A_n$，或者 $m$ 是兩個 $\\set{A_1, \\ldots, A_n}$ 的數字差。\n","link":"https://ecna18.kattis.com/problems/difference","code":"ECNA2018B","difficulty":null,"oj":"kattis","tags":null},"htmlAst":{"type":"root","children":[],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"Kingdom of Kittens","category":"prob","path":"/problem/icpc/asia_hanoi_2018/K","date":"2019-01-11","_PARENT":"0ce9d2d9-55ef-573f-bf79-500b149e6a9b","description":"給定平面上 $n$ ($1\\le n\\le 10^5$) 個點，判斷是否存在一個三角形，使得所有點都在這個三角形的邊界或頂點上？\n","link":"https://open.kattis.com/problems/kingdomofkittens","code":"ICPC-HANOI-2018-K","difficulty":8,"oj":"kattis","tags":["ICPC 2018 Asia Hanoi Regional","geometry"]},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"簡化後題目敘述"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"輸入可能包含多組測試資料。每一組測試資料第一列包含一個正整數 $n$，接下來有 $n$ 列分別包含兩個整數 $x_i, y_i$ （$-10^9\\le x_i, y_i\\le 10^9$）。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸出說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"4\n0 0\n0 2\n2 0\n2 2\n5\n0 0\n0 2\n2 0\n2 2\n1 1\n0\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"YES\nNO\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ 連結"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://open.kattis.com/problems/kingdomofkittens"},"children":[{"type":"text","value":"Open Kattis - Kingdom of Kittens"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"題目出處"}]},{"type":"text","value":"：ICPC 2018 Asia Hanoi Regional"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"唉。這種痛苦的計算幾何題好像似曾相識（遠目）"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這題的難點在於特別的 case 也太多了，尤其是，三角形可以有某個邊上面只包含一個點的情況。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"比我的作法簡單的方法應該有很多很多種。今天就獻醜了。"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"如果有更好的解法歡迎提供！"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我的作法是：先計算一個凸包（這個凸包上的點如果 $>6$ 個那就沒救了），然後找出哪些凸包上的邊「一定要出現在三角形裡面」。可能有 0~3 條。然後依據剩下的、沒有被這些邊蓋到的點，分成幾種情形討論。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"假定答案三角形的三條邊都來自凸包上面邊的延伸，那麼需要一個方法判斷：是否真的把這三條邊延伸以後可以圍住所有點。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"假定答案三角形的兩條邊來自凸包上的邊，那麼把邊上的點去掉以後，最多只會剩下一個點，我們需要另一個方法，判斷這種情形是否存在解。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"假定答案三角形的一條邊來自凸包上的邊，那麼凸包大小 $\\le 4$，此時保證有解。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"一些好用的測資"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"7\n2 0\n1 1\n0 2\n8 0\n9 1\n10 2\n5 3\n7\n0 0\n0 1\n0 2\n1 0\n2 0\n3 1\n4 3\n8\n0 0\n0 1\n0 2\n1 2\n2 2\n2 1\n2 0\n1 0\n5\n1 0\n2 0\n3 0\n1 6\n2 6\n7\n0 0\n0 0\n0 0\n0 0\n0 0\n0 0\n0 0\n6\n1 0\n2 0\n3 0\n2 6\n3 6\n4 6\n7\n1 0\n2 0\n3 0\n3 3\n0 1\n0 2\n0 3\n7\n0 2\n1 1\n2 0\n7 0\n8 1\n9 2\n5 -1\n7\n0 2\n1 1\n2 0\n3 0\n4 0\n5 1\n6 2\n7\n0 2\n1 0\n2 0\n3 0\n4 1\n5 2\n7 8\n7\n0 2\n1 0\n2 0\n3 0\n4 1\n5 2\n7 10\n7\n0 2\n1 0\n2 0\n3 0\n4 1\n5 2\n7 9\n8\n0 0\n0 1\n0 2\n1 0\n1 4\n2 0\n2 1\n2 2\n7\n0 0\n0 1\n0 2\n1 0\n2 0\n1 3\n2 3\n6\n0 0\n0 1\n5 0\n5 10\n1 9\n4 10\n6\n0 0\n0 1\n0 2\n6 0\n2 0\n5 0\n5\n0 0\n0 1\n0 2\n0 3\n0 4\n6\n0 0\n0 1\n1 0\n2 3\n3 2\n3 3\n4\n0 0\n0 2\n2 0\n1 1\n4\n0 0\n0 2\n2 0\n2 2\n5\n0 0\n0 2\n2 0\n2 2\n1 1\n0\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"答案應該要是"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"YES\nNO\nNO\nYES\nYES\nNO\nYES\nNO\nNO\nYES\nNO\nNO\nNO\nNO\nNO\nYES\nYES\nYES\nYES\nYES\nNO\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long double Double;\n\nclass Point {\n  public:\n    long long x, y;\n    \n    Point(long long _x=0, long long _y=0): x(_x), y(_y) {}\n    Point operator+(const Point &q) const {\n      return Point(x + q.x, y + q.y);\n    }\n    Point operator-(const Point &q) const {\n      return Point(x - q.x, y - q.y);\n    }\n    bool operator<(const Point &q) const {\n      if (x != q.x) return x < q.x;\n      return y < q.y;\n    }\n    bool operator==(const Point &q) const {\n      return x == q.x && y == q.y;\n    }\n    Double length() const {\n      return sqrtl(x*x+y*y);\n    }\n  friend istream& operator>>(istream& in, Point& p) {\n    in >> p.x >> p.y;\n    return in;\n  }\n    \n};\n\n\nlong long cross(const Point &p, const Point &q) {\n  return p.x * q.y - p.y * q.x;\n}\nlong long dot(const Point &p, const Point &q) {\n  return p.x * q.x + p.y * q.y;\n}\n\nDouble GetAngle(const Point &u, const Point &v) {\n  Double t = ((Double)dot(u, v) / u.length() / v.length());\n  return acosl(t);\n}\n\nbool CheckInvalid(const vector<Point> &angles) {\n  for (size_t i=0;i<angles.size();i++)\n    for(size_t j=i+1;j<angles.size();j++)\n      if(cross(angles[i], angles[j]) == 0)\n        return true;\n\n// 這邊判斷逆時針的三個方向是否真的可以湊成一個涵蓋凸包範圍的三角形。\n  if (angles.size() == 3) {\n    bool f0 = (cross(angles[0], angles[1]) < 0)^(cross(angles[0], angles[2]) < 0);\n    bool f1 = (cross(angles[1], angles[0]) < 0)^(cross(angles[1], angles[2]) < 0);\n    bool f2 = (cross(angles[2], angles[0]) < 0)^(cross(angles[2], angles[1]) < 0);\n    if (!f0 || !f1 || !f2)\n      return true;\n  }\n  return false;\n}\n\nvector<Point> p;\n\nbool IsRightTurn(int A, int B, int C) {\n  return cross(p[B]-p[A], p[C]-p[B]) <= 0;\n}\n\nbool solve() {\n  int N;\n  cin >> N;\n  if (N == 0) return false;\n\n  p.resize(N);\n  for (int i = 0; i < N; i++) cin >> p[i];\n  sort(p.begin(), p.end());\n  \n  N = unique(p.begin(), p.end()) - p.begin();\n  p.resize(N);\n\n  if (N <= 3) {\n    cout << \"YES\" << '\\n';\n    return true;\n  }\n\n  deque<int> cvx, cvx_upper;\n  for(int i=0;i<N;i++) {\n    while (cvx.size() >= 2 &&\n        IsRightTurn(cvx[cvx.size()-2], cvx[cvx.size()-1], i)) {\n      cvx.pop_back();\n    }\n    cvx.push_back(i);\n  }\n  for(int i=N-1;i>=0;i--) {\n    while (cvx_upper.size() >= 2 &&\n        IsRightTurn(cvx_upper[cvx_upper.size()-2], cvx_upper[cvx_upper.size()-1], i)) {\n      cvx_upper.pop_back();\n    }\n    cvx_upper.push_back(i);\n  }\n  for(size_t i=1;i+1<cvx_upper.size();i++) cvx.push_back(cvx_upper[i]);\n  \n  while (cvx.size() >= 3 &&\n      IsRightTurn(cvx[cvx.size()-1], cvx[0], cvx[1])) {\n    cvx.pop_front();\n  }\n\n  // 超過六條邊就一定是 NO 了。\n  if (cvx.size() > 6) {\n    cout << \"NO\" << endl;\n    return true;\n  }\n  \n\n  \n  // 所有點都要在凸包上，並紀錄哪些凸包上的邊有點。\n  vector<bool> has_edge(cvx.size(), false);\n  cvx.push_back(cvx[0]);\n  for (int i = 0; i < N; i++) {\n    int ok = false;\n    for (size_t j = 0; j+1 < cvx.size(); j++) {\n      if (cross(p[cvx[j]]-p[i], p[i]-p[cvx[j+1]]) == 0) {\n        if (cvx[j] != i && cvx[j+1] != i) {\n          has_edge[j] = true;\n        }\n        ok = true;\n      }\n    }\n    if (!ok) {\n      cout << \"NO\" << '\\n';\n      return true;\n    }\n  }\n  \n  // 如果是共線或三角形的情形，就一定是 YES 了。\n  if (has_edge.size() <= 3) {\n    cout << \"YES\" << endl;\n    return true;\n  }\n  \n\n  // 檢查必須擁有的邊是否都不平行。\n  int cnt = 0;\n  vector<Point> angles;\n  for (size_t i = 0; i+1 < cvx.size(); i++) {\n    if (has_edge[i]) {\n      angles.push_back(p[cvx[i+1]]-p[cvx[i]]);\n      ++cnt;\n    }\n  }\n  if (cnt > 3 || CheckInvalid(angles)) {\n    cout << \"NO\" << endl;\n    return true;\n  }\n\n  \n  // 少於五條邊不一定是 YES。\n  // 如果兩條邊固定了，看看是否還有兩個以上還沒蓋到的點。\n  vector<int> empty_point;\n  if(!has_edge[0] && !has_edge.back()) empty_point.push_back(0);\n  for (size_t i=1;i+1<cvx.size();i++) {\n    if(!has_edge[i] && !has_edge[i-1]) {\n      empty_point.push_back(i);\n    }\n  }\n\n  if (empty_point.empty()) {\n    cout << \"YES\" << endl;\n    return true;\n  }\n\n\n  if (cnt == 3 && !empty_point.empty()) {\n    cout << \"NO\" << endl;\n    return true;\n  }\n\n  // Case #9 有這個\n  if (has_edge.size() == 5 && cnt == 2) {\n    if (empty_point.size() == 2) {\n      if (empty_point[1] != empty_point[0]+1 &&\n          (empty_point[0] != 0 ||\n           empty_point[1] != (int)has_edge.size()-1)) {\n        cout << \"NO\" << endl;\n        return true;\n      }\n      if (empty_point[1] == (int)has_edge.size()-1 && empty_point[0] == 0)\n        swap(empty_point[0], empty_point[1]);\n      angles.push_back(p[cvx[empty_point[1]]]-p[cvx[empty_point[0]]]);\n      if (CheckInvalid(angles)) {\n        cout << \"NO\" << endl;\n        return true;\n      } else {\n        cout << \"YES\" << endl;\n        return true;\n      }\n    }\n  }\n\n\n  // 如果兩條邊固定了，取決於剩下那個點出現在那一邊。\n  if (cnt == 2 && empty_point.size() == 1 && has_edge.size() == 5) {\n    \n    int i = empty_point[0];\n    Point first = p[cvx[(i+2)%5]] - p[cvx[(i+1)%5]];\n    Point second = p[cvx[(i+4)%5]] - p[cvx[(i+3)%5]];\n    \n    if (cross(first, second) <= 0) {\n      cout << \"NO\" << endl;\n      return true;\n    }\n    \n  }\n\n\n\n  // 剩下的情況，少於五條邊一定是 YES。\n  if (has_edge.size() <= 5) {\n    cout << \"YES\" << endl;\n    return true;\n  }\n\n\n\n\n  // 只剩下兩種可能。\n  // 1. 考慮偶數位置的邊。\n  vector<Point> odds = { p[cvx[1]]-p[cvx[0]],\n    p[cvx[3]]-p[cvx[2]],\n    p[cvx[5]]-p[cvx[4]]};\n\n  if (CheckInvalid(odds) == false) {\n    bool alleven = (!has_edge[1] && !has_edge[3] && !has_edge[5]);\n    if (alleven) {\n      cout << \"YES\" << '\\n';\n      return true;\n    }\n  }\n  \n  \n  // 2. 考慮奇數位置的邊。\n  vector<Point> evens = { p[cvx[2]]-p[cvx[1]],\n    p[cvx[4]]-p[cvx[3]],\n    p[cvx[0]]-p[cvx[5]]};\n  \n  \n  if (CheckInvalid(evens) == false) {\n    bool allodd = (!has_edge[0] && !has_edge[2] && !has_edge[4]);\n    if (allodd) {\n      cout << \"YES\" << '\\n';\n      return true;\n    }\n  }\n  cout << \"NO\" << '\\n';\n  return true;\n}\n\nint main() {\n  while (solve());\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"關於競程日記"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"🍅 如果您想到更多有趣漂亮簡單乾淨的解法話歡迎留言給競程日記小編群！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"ℹ️ 這是一篇投稿給"},{"type":"element","tagName":"a","properties":{"href":"https://www.facebook.com/%E7%AB%B6%E7%A8%8B%E6%97%A5%E8%A8%98-1514973425463954/"},"children":[{"type":"text","value":"競程日記"}]},{"type":"text","value":"的文章，歡迎大家投稿、交流與分享程式解題競賽的點點滴滴！"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"Fun with Fibonacci","category":"prob","path":"/problem/icpc/asia_hanoi_2018/F","date":"2019-01-13","_PARENT":"1da3d9cc-82b8-5c13-af9a-b103f88a15e4","description":"費氏數列的遞迴定義如下：\n\n$$ F_n = F_{n-1} + F_{n-2} $$\n\n初始條件為 $F_0=0, F_1=1$。這個數列的首幾項為 0, 1, 1, 2, 3, 5, 8, 13, 21, ...\n\n我們現在定義誇張版的費氏數列\n\n* 定義 $G(1, n)$ 為第 $n$ 個費氏數列。\n* 定義 $G(2, n) = G(1, G(1, n))$。\n* 對於任意正整數 $i$，定義 $G(i, n) = G(1, G(i-1, n))$。\n\n給定 $n, k, p$，請你計算 $G(k, n)\\bmod p$ 之值。\n","link":"https://open.kattis.com/problems/funwithfibonacci","code":"ICPC-HANOI-2018-F","difficulty":8,"oj":"kattis","tags":["ICPC 2018 Asia Hanoi Regional","number theory"]},"htmlAst":{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"簡化後題目敘述"}]},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"輸入的第一列包含一個正整數 $T$ ($1\\le T\\le 10^5$) 代表測試資料組數。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"接下來有 $T$ 列，每一列為一組測試資料，包含三個正整數 $n, k, p$（$1\\le n, k\\le 10^{18}, 1\\le p\\le 10^6$）。"}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ 連結"}]},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://open.kattis.com/problems/funwithfibonacci"},"children":[{"type":"text","value":"Open Kattis - Fun with Fibonacci"}]}]},{"type":"text","value":"\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"題目出處"}]},{"type":"text","value":"：ICPC 2018 Asia Hanoi Regional"}]},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"今天是數論小教室。看到這題範圍這麼大，其中必定有詐。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這題真的很難。而且第一步就是你真的要對費氏數列有所認識的那種難。看到計算費氏數列除以 $p$ 的餘數（注意這裡 $p$ 不是質數唷），就"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"應該"}]},{"type":"text","value":"要想到費氏數列模 $p$ 的循環節長度是 $O(p)$ 的！是不是很 OP！"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"而事實上，我們可以利用以下定理刻劃出費氏數列模 $p$ 的循環節長度："}]},{"type":"element","tagName":"theorem","properties":{"title":"費氏數列的循環節"},"children":[{"type":"text","value":"\n設 $p$ 為質數。則：\n* 當 $p=5$ 的時候 $F_{20} \\equiv 0, F_{21}\\equiv 1 \\pmod 5$。\n    * 這保證了循環節長度整除 $20$。\n* 當 $p\\equiv \\pm 1 \\pmod 5$ 的時候 $F_{p-1} \\equiv 0, F_{p}\\equiv 1 \\pmod 5$。\n    * 這保證了循環節長度整除 $p-1$。\n* 當 $p\\equiv \\pm 2 \\pmod 5$ 的時候 $F_{2p+2}\\equiv 0, F_{2p+3}\\equiv 1 \\pmod 5$。\n    * 這保證了循環節長度整除 $2p+2$。\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"然後經過努力推敲一下，可以推得對任意正整數 $r$，模 $p^r$ 的時候，循環節長度整除： $p^{r-1} \\times (\\text{模$p$的循環節長度})$。再根據中國剩餘定理用力觀察一下，就可以知道把一個正整數拆成許多質因數的次方積，每一個部份的循環節長度之最小公倍數（LCM）就是我們要的答案。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"上面這個定理的證明可以在"},{"type":"element","tagName":"a","properties":{"href":"https://www.math.arizona.edu/~ura-reports/071/Campbell.Charles/Final.pdf"},"children":[{"type":"text","value":"這裡"}]},{"type":"text","value":"找到唷（我不太喜歡他的證明，有些地方定義不是很清楚的感覺。之後找到更好的再換掉。）"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"有了這個以後，就可以真真正正地開始 "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Fun With Fibonacci"}]},{"type":"text","value":" 了。"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"把循環節往下丟"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"對於任意正整數 $p$，我們令函數 $f(p)$ 表示循環節大小。首先我們可以做出以下觀察：\n$G(i, n) \\bmod p = F_{G(i-1, n)} \\bmod p = F_{G(i-1, n)\\bmod f(p)} \\bmod p$。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我們可以把這個寫成遞迴關係，透過解決 $G(i-1, n)$ 回頭解 $G(i, n)$。這個遞迴最終得跑過 $k$ 次，基本上是個 $k=1000000000000000000$ 次的概念。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"經過了今天大量 TLE 的洗禮，我觀察到了以下幾個很酷炫的點："}]},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"$p, f(p), f(f(p)), f(f(f(p))), \\ldots$ 這個序列非常快就進入循環了。而且，只要 3~4 步以後就會跑到"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"不動點"}]},{"type":"text","value":"！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"大部分的不動點 $p$（i.e. $f(p)=p$），都是 $2^4\\times 3\\times 5^8$ 的因數。"}]},{"type":"text","value":"\n"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"處理不動點"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"好的，現在問題變成了處理 $F_{F_{F_{F_n}}} \\bmod p$...，而好消息是我們總可以把 $\\bmod p$ 往註標裡面丟。壞消息是我們要這樣做幾乎 $k$ 次啊！"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"注意到每次答案都是一個介於 $[0, p-1]$ 之間的整數，若我們定義一個有 $p$ 個點的圖，其中每個點 $x\\mapsto (F_x\\bmod p)$。那麼，這樣的圖一定長得很水母森林（Jellyfish-es）。迭代 $k$ 次就相當於從 $n$ 出發，連續走 $k$ 步，看看到底停留在什麼地方，而這個地方就是答案。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"（我猜這邊需要另一個定理幫助我們快速找出答案。但我試著用各種鴉常數的方法硬迭代找循環節拿到 AC 了就是......）"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"我最後的大絕招"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"計算 $F_x\\bmod p$ 是很吃重而且很難算的。根據亂跑得結果，上述循環節大小很可能高達 $156250$ 這麼大。因為 $T\\le 10^5$，我們必須要非常非常快速的算出 $F_x\\bmod p$ 才有辦法在時限內跑完最壞測資。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"一個想法是，如果我們找到了一些巨大 cycle，那麼可以把他們存下來，因為下一次再碰到同一個 cycle 的機會是高的。但是，如果今天換了一個 $p$ 值，整個圖都會不一樣，這個存下來的東西就不能用了。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"好消息是，假若有許多不動點都整除 $18750000=2^4\\times 3\\times 5^8$，那一開始我可以偷偷用一個很大的陣列 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"special[18750000]"}]},{"type":"text","value":" 存下費氏數列每一項 $\\bmod 18750000$ 的值。萬一今天遇到 $p=10000$，我們想計算 $F_{123}\\bmod 10000$，這個值就會恰恰等於 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"special[123] % 10000"}]},{"type":"text","value":"（因為 10000 整除 18750000）。"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"今天的程式碼真的非常非常傷眼，真的很對不起。我以後有空再把它淨化一下（淚）"}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\nconst int N = 2000005;\nvector<bool> sieve(N);\nvector<int> primes;\n\nconst int VS = 18750000;\nint special[18750000];\n\nstruct Matrix {\n  LL a[2][2];\n  Matrix(LL A = 1, LL B = 0, LL C = 0, LL D = 1) {\n    a[0][0] = A;\n    a[0][1] = B;\n    a[1][0] = C;\n    a[1][1] = D;\n  }\n  Matrix operator % (const LL mod) const {\n    LL P = a[0][0]%mod;\n    LL Q = a[0][1]%mod;\n    LL R = Q;\n    LL S = a[1][1]%mod;\n    return Matrix(P, Q, R, S);\n  }\n  Matrix operator *(const Matrix m) const {\n    LL P = a[0][0] * m.a[0][0] + a[0][1] * m.a[1][0];\n    LL Q = a[0][0] * m.a[0][1] + a[0][1] * m.a[1][1];\n    LL R = Q;\n    LL S = a[1][0] * m.a[0][1] + a[1][1] * m.a[1][1];\n    return Matrix(P, Q, R, S);\n  }\n};\n\nMatrix MatrixPowerMod(Matrix A, LL n, LL mod) {\n  if (n == 0) return Matrix() % mod;\n  if (n == 1) return A % mod;\n  Matrix B = Matrix();\n  while (n > 0) {\n    if (n%2) B = B * A % mod;\n    A = A * A % mod;\n    n/=2;\n  }\n  return B;\n}\n\nLL Fib(LL n, LL mod) {\n  if (VS % mod == 0) return special[n] % mod;\n\n  Matrix A(1, 1, 1, 0);\n  A = MatrixPowerMod(A, n, mod);\n  return A.a[0][1];\n}\n\nLL GCD(LL x, LL y) {\n  while ((x%=y) && (y%=x));\n  return x+y;\n}\n\nLL LCM(LL x, LL y) {\n  return x / GCD(x, y) * y;\n}\n\nLL GetPrimePeriod(LL p, int k) {\n  LL result = 0;\n\n  if (p == 5) {\n    LL t = 20;\n    LL w = t; while(--k) w *= p;\n    return (result = w);\n  } else if (p%5 == 1 || p%5 == 4) {\n    LL N = 1; for(int _=0;_<k;_++) N*=p;\n    LL w = p-1; while(--k) w *= p;\n    return (result = w);\n  } else {\n    LL N = 1; for(int _=0;_<k;_++) N*=p;\n    LL w = 2*p+2; while(--k) w *= p;\n    return (result = w);\n  }\n}\n\nLL GetPeriod(LL m) {\n  LL t = 1;\n  LL copy = m;\n  for (int j = 0; primes[j] * primes[j] <= copy; j++) {\n    LL p = primes[j];\n    if (copy % p == 0) {\n      int power = 0;\n      do {\n        copy /= p;\n        ++power;\n      } while (copy % p == 0);\n      \n      t = LCM(t, GetPrimePeriod(p, power));\n    }\n  }\n  if (copy > 1) {\n   t = LCM(t, GetPrimePeriod(copy, 1));\n  }\n  return t;\n}\n\nvoid PreCompute() {\n  for (int i = 2; i <= 20000; i++) {\n    if (!sieve[i]) {\n      for (int j = i*i; j < N; j+=i)\n        sieve[j] = true;\n    }\n  }\n  for (int i = 2; i < N; i++)\n    if (!sieve[i])\n      primes.push_back(i);\n}\n\nLL pp;\nunordered_map<LL, int> pindex;\nunordered_map<LL, pair<int, int>> cycindex[128];\nvector<vector<LL>> bigcycles[128];\nint u[9375000];\nint idx[9375000] = {}, ucnt;\n\nLL getans(LL n, LL k, LL p) {\n  if (k == 1) {\n    return Fib(n, p);\n  }\n  LL next_period = GetPeriod(p);\n  if (p == next_period) {\n\n    if (pindex.find(p) == pindex.end()) {\n      int newidx = pindex.size();\n      pindex[p] = newidx;\n    }\n    int pidx = pindex[p];\n\n    vector<LL> g;\n    \n    ++ucnt;\n\n    n %= p;\n    g.push_back(n);\n    idx[n] = 0;\n    u[n] = ucnt;\n\n    for (LL i = 1; i <= k; i++) {\n      n = Fib(n, p);\n      if (cycindex[pidx].find(n) != cycindex[pidx].end()) {\n        auto [cidx, at] = cycindex[pidx][n];\n        vector<LL> &cycle = bigcycles[pidx][cidx];\n        int length = cycle.size();\n        i += (k-i)/length*length;\n        return cycle[ (k-i+at) % length ];\n      }\n      \n      //if (idx.find(n) != idx.end()) {\n      if (u[n] == ucnt) {\n        // found! from idx[n] to i-1.\n        int length = i - idx[n];\n\n        if (i>=10000 || length >=10000)\n        cerr << \"(pp=\" << pp << \") Found a cycle of length \" << length  << \" at index \" << i << endl;\n        if (length >= 1000) {\n          // Memorize it.\n          int cidx = bigcycles[pidx].size();\n          vector<LL> cycle;\n          for (int j = idx[n]; j < i; j++) {\n            cycle.push_back(g[j]);\n            cycindex[pidx][g[j]] = {cidx, j-idx[n]};\n          }\n          bigcycles[pidx].push_back(cycle);\n        }\n\n        i += (k-i)/length*length;\n        return g[idx[n] + k-i];\n      } else {\n        g.push_back(n);\n        idx[n] = i;\n        u[n] = ucnt;\n      }\n    }\n    return n;\n  }\n  LL t = getans(n, k-1, next_period);\n  return Fib(t, p);\n}\n\nvoid solve() {\n  LL n, k, p;\n  cin >> n >> k >> p;\n  LL t = getans(n, k, p);\n  cout << t << '\\n';\n}\n\nvoid PreTest() {\n  for(LL p = 2; p <= 1000000; p++) {\n    pp = p;\n    getans(576460752303423487LL, 576460752303423487LL, p);\n  }\n}\n\nvoid PreTwo() {\n  LL mod = VS;\n  special[0] = 0;\n  special[1] = 1;\n  for(int i=2;i<mod;i++) {\n    special[i] = (special[i-1]+special[i-2]);\n    if(special[i] >= mod) special[i] -= mod;\n  }\n}\n\nint main() {\n  PreCompute();\n  PreTwo();\n  // PreTest();\n  int T;\n  cin >> T;\n  while(T--) solve();\n  return 0;\n}\n"}]}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"夢月說"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這題應該要 150 行以內寫完才高竿啊。"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Shik說"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"BubbleCup 2013 曾經出過一道類似題，但是此題的 $T\\le 10^3$，而且 $p \\le 10^{18}$ 超大。要因數分解還得用 pollar-rho。"}]},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"有興趣的朋友們可以參考 "},{"type":"element","tagName":"a","properties":{"href":"https://www.spoj.com/problems/FRSKH"},"children":[{"type":"text","value":"SPOJ - FRSKH Fibonacci recursive sequences (hard)"}]},{"type":"text","value":"。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"http://www.bubblecup.org/Content/Media/Booklet2013.pdf"},"children":[{"type":"text","value":"題解手冊"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://github.com/zimpha/competitive-programming/blob/master/spoj/FRSKH.cc"},"children":[{"type":"text","value":"zimpha 的 FRSKH 題解"}]}]},{"type":"text","value":"\n"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"關於競程日記"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"🍅 如果您想到更多有趣漂亮簡單乾淨的解法話歡迎留言給競程日記小編群！"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"ℹ️ 這是一篇投稿給"},{"type":"element","tagName":"a","properties":{"href":"https://www.facebook.com/%E7%AB%B6%E7%A8%8B%E6%97%A5%E8%A8%98-1514973425463954/"},"children":[{"type":"text","value":"競程日記"}]},{"type":"text","value":"的文章，歡迎大家投稿、交流與分享程式解題競賽的點點滴滴！"}]}]}}},{"node":{"frontmatter":{"title":"Popping Balloons","category":"prob","path":"/problem/icpc/asia_jakarta_2018/F","date":"2019-01-03","_PARENT":"5d7d5a7e-8cee-5c6e-b03c-db47c102936e","description":"Ayu 和 Budi 正在一場類似 ICPC 的比賽上面決鬥。這樣的比賽題目總共有 $N$ 題，然而，參賽者比須按照指定順序依序解題。\n\nAyu 熟知她自己與 Budi 解每一題的能力，因此，Ayu 能夠事先得知兩個陣列 $A_{1, \\ldots, N}$ 以及 $B_{1, \\ldots, N}$，其中 $A_i$ 與 $B_i$ 分別表示 Ayu 和 Budi 解出第 $i$ 題所需要的時間。\n\n故事是這樣的，Ayu 知道 Budi 對突然的巨大聲響相當敏感，比方說當氣球爆炸的時刻。一旦 Budi 受到驚嚇，他手邊的工作就會立即停擺，而且當下解的題目必須**重頭開始**解。如果在恰好要解出一題的當下被嚇到，Budi 也得從頭開始才行。\n\nAyu 想利用這點勝過 Budi，她唯一能夠利用的，就是自己解出題目的當下所獲得的氣球。你可以假設 Ayu 一旦解出題目就可以立即獲得氣球，也可以立即戳破氣球（如果 Budi 同時即將解完，可憐的 Budi 就得重頭開始）。請問 Ayu 是否有戳氣球的策略使得在時間 $M$ 結束的當下，Ayu 解出的題數**嚴格大於** Budi 的呢？\n","link":"https://codeforces.com/gym/102001/problem/F","code":"ICPC-JAKARTA-2018-F","difficulty":6,"oj":"codeforces-gym","tags":null},"htmlAst":{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"題目敘述"}]},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"輸入的第一列包含兩個正整數 $N, M$ （$1\\le N\\le 100000; 1\\le M\\le 10^9$）依序代表題目的數量與比賽的時間長度。第二列包含 $N$ 個整數 $A_i$（$1\\le A_i\\le 10^9$），第三列包含 $N$ 個整數 $B_i$（$1\\le B_i\\le 10^9$）。"}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸出說明"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果不存在任何方法使得 Ayu 最終題數嚴格大於 Budi 的題數，輸出 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"-1"}]},{"type":"text","value":"。否則的話輸出一個整數 $K$，然後在第二列輸出 $K$ 個嚴格遞增的數字：Ayu 只要在這些時間點戳破氣球，就可以贏過 Budi。"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 1"}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"4 30\n9 10 10 10\n4 10 5 10\n"}]}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 1"}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"2\n12 19\n"}]}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 2"}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"5 50\n10 10 10 10 10\n15 12 19 17 20\n"}]}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 2"}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"0\n"}]}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 3"}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"5 10\n15 10 5 5 5\n9 10 10 10 10\n"}]}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 3"}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"-1\n"}]}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ 連結"}]},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://codeforces.com/gym/102001/problem/F"},"children":[{"type":"text","value":"Codeforces Gym 102001 - F"}]}]},{"type":"text","value":"\n"}]},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"俗話說得好："},{"type":"element","tagName":"s","properties":{},"children":[{"type":"text","value":"氣球恆久遠，一顆永流傳。"}]},{"type":"text","value":"如果 Ayu 在 Budi 解題目解到一半的時候戳破氣球嚇嚇他，倒不如多等一下，在 Budi 即將解出來的那剎那"},{"type":"element","tagName":"s","properties":{},"children":[{"type":"text","value":"說時遲那時快"}]},{"type":"text","value":"再把氣球戳破，讓 Budi 重來感覺豈不是更好嗎！"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"假設我們有個答案，那我們可以把 Budi 的解題心路歷程記錄下來，比方說（紅色的字代表被嚇到所以沒有解出該題）："}]},{"type":"text","value":"$$\nB_1, B_2, \\red{B_3}, \\red{B_3}, B_3, \\red{B_4}, B_4, B_5, ...\n$$"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果今天 $B_3 < B_4$，那麼 Ayu 總是可以再多等一下，讓 Budi 重做 $B_4$ 總是比重做 $B_3$ 賺更多！"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"以上的觀察引導我們使用「堆疊」的解法，去模擬 Ayu 的選擇，把得到的氣球花在 Budi 的哪些題目上頭。我們維護一個堆疊，從堆疊底部到頂部，永遠是「任務編號遞增、所花費時間嚴格遞減」並且紀錄有多少顆氣球花在這題上面。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"以下面這個例子而言，假設 Ayu 可以在以下時間 8, 20, 40, 48, 56, 65, 109, 114, 117, 118 分別獲得氣球，那堆疊的改變看起來會像這樣："}]},{"type":"element","tagName":"algorithm","properties":{},"children":[{"type":"text","value":"\n    "},{"type":"element","tagName":"generator","properties":{},"children":[{"type":"element","tagName":"pre","properties":{},"children":[{"type":"text","value":"\n        function*(input, ui) {\n            var B = input.B;\n            var C = input.C;\n            var n = B.length;\n            var s = [];\n            var show = function(stack) {\n                return stack.map((x) => `B[${x[0]}] = ${B[x[0]]}\\n重做=${x[1]}`);\n            };\n            var bshow = function(b, s) {\n                var bmsg = [];\n                var i;\n                var v = 0;\n                for (i = 0; i < b.length; i++) {\n                    var msg = '-';\n                    v += b[i];\n                    for (j = 0; j < s.length; j++) {\n                        if (s[j][0] === i) {\n                            msg = `重做 ${s[j][1]} 次`;\n                            v += s[j][1] * b[i];\n                        }\n                    }\n                    bmsg.push(`${b[i]}\\n${msg}\\n完成時間=${v}`);\n                }\n                return bmsg;\n            };\n            var i, j;\n            for (i = 0; i < n; i++) {\n                s.push([i, C[i]]);\n                for (j = 0; j < s.length-1; j++) {\n                        ui.setStyleOnce('arr', `${j}`, {fill: 'lightyellow'});\n                        ui.setStyleOnce('B', `${s[j][0]}`, {fill: 'lightyellow'});\n                    }\n                ui.setStyleOnce('B', `${i}`, {fill: 'cyan'});\n                ui.setStyleOnce('arr', `${s.length-1}`, {fill: 'cyan'});\n                yield ({B: bshow(B,s), arr: show(s)});\n                while (s.length >= 2 &&\n                    B[s[s.length-1][0]] >=\n                    B[s[s.length-2][0]]) {\n                        s[s.length-2][1] += s[s.length-1][1];\n                        s[s.length-2][0] = s[s.length-1][0];\n                        s.pop();\n                    for (j = 0; j < s.length-1; j++) {\n                        ui.setStyleOnce('arr', `${j}`, {fill: 'lightyellow'});\n                        ui.setStyleOnce('B', `${s[j][0]}`, {fill: 'lightyellow'});\n                    }\n                    ui.setStyleOnce('B', `${i}`, {fill: 'cyan'});\n                    ui.setStyleOnce('arr', `${s.length-1}`, {fill: 'cyan'});\n                    yield ({B: bshow(B,s), arr: show(s)});\n                }\n            }\n            for (j = 0; j < s.length; j++) {\n                        ui.setStyleOnce('arr', `${j}`, {fill: 'lightyellow'});\n                        ui.setStyleOnce('B', `${s[j][0]}`, {fill: 'lightyellow'});\n                    }\n            return {B: bshow(B,s), arr: show(s)};\n        }\n        "}]},{"type":"text","value":"\n    "}]},{"type":"text","value":"\n    "},{"type":"element","tagName":"inputdata","properties":{"data":"{\"B\": [8, 10, 5, 3, 1, 9, 6, 7, 4, 2],\n               \"C\": [1, 1, 2, 1, 0, 1, 0, 0, 1, 3]}"},"children":[]},{"type":"text","value":"\n    "},{"type":"element","tagName":"indirectdisplay","properties":{"array":"","fixedwidth":"","minwidth":"30","highlightdiff":"","varname":"B"},"children":[]},{"type":"text","value":"\n    "},{"type":"element","tagName":"indirectdisplay","properties":{"array":"","fixedwidth":"","n":"5","minwidth":"30","highlightdiff":"","varname":"arr"},"children":[]},{"type":"text","value":"\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果總比賽時間 $M=119$，那麼 Ayu 能讓 Budi 在第 119 分鐘的時候還做不出最後一題，因此 Ayu 能夠獲勝。"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n  int N, M;\n  cin.sync_with_stdio(false);\n  cin >> N >> M;\n  vector<long long> A(N), B(N);\n\n  for (int i = 0; i < N; i++) cin >> A[i];\n  for (int i = 0; i < N; i++) cin >> B[i];\n\n  // 先算出 Ayu 拿到每顆氣球的時間點，並算出 Ayu 可以解幾題。\n  int nsolved = 0;\n  for (int i = 1; i < N; i++) A[i] += A[i - 1];\n  for (int i = 0; i < N; i++) nsolved += (A[i] <= M);\n\n  // 我們目標就是要讓 Budi 解出第 nsolved 的時間嚴格大於 M。\n  long long t = 0;\n  vector<pair<int, int>> stack;\n  for (int i = 0, j = 0; i < nsolved; i++) {\n    int balloons = 0;\n    while (!stack.empty() && B[stack.back().first] <= B[i]) {\n      balloons += stack.back().second;\n      t -= stack.back().second * B[stack.back().first];\n      stack.pop_back();\n    }\n    t += B[i] * (balloons + 1);\n    while (j < nsolved && A[j] <= t) {\n      ++j;\n      ++balloons;\n      t += B[i];\n    }\n    stack.push_back(make_pair(i, balloons));\n  }\n\n  // 如果還是在 M 分鐘內解出來了，就輸出 -1。\n  if (t <= M) {\n    cout << \"-1\" << endl;\n    return 0;\n  }\n\n  // 計算每顆氣球被戳破的時間。\n  t = 0;\n  int j = 0;\n  vector<long long> ans;\n  for (auto [i, b] : stack) {\n    while (j < i) t += B[j++];\n    for (int l = 0; l < b; l++)\n      ans.push_back(t += B[i]);\n  }\n\n  // 輸出答案。\n  while (!ans.empty() && ans.back() > M) ans.pop_back();\n  cout << ans.size() << endl;\n  for (auto x : ans) cout << x << \" \";\n  cout << endl;\n  return 0;\n}\n"}]}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"關於競程日記"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"🍅 如果您想到更多有趣漂亮簡單乾淨的解法話歡迎留言給競程日記小編群！"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"ℹ️ 這是一篇投稿給"},{"type":"element","tagName":"a","properties":{"href":"https://www.facebook.com/%E7%AB%B6%E7%A8%8B%E6%97%A5%E8%A8%98-1514973425463954/"},"children":[{"type":"text","value":"競程日記"}]},{"type":"text","value":"的文章，歡迎大家投稿、交流與分享程式解題競賽的點點滴滴！"}]}]}}},{"node":{"frontmatter":{"title":"Smart Thief","category":"prob","path":"/problem/icpc/asia_jakarta_2018/C","date":"2019-01-02","_PARENT":"f1d4ba02-37dc-5266-a1e7-02310dbb958c","description":"Ayu 想要打開一個使用密碼鎖加密的箱子。為了能夠找出正確密碼，Ayu 必須要很遺憾地嘗試所有長度為 $N$ 的密碼組合。\n\n有趣的是，Ayu 發現了這套密碼鎖系統其實相當古板：當你輸入 $N$ 個數字以後，系統會自動判斷你到底輸入正確與否。如果輸入了正確的密碼，那麼箱子的鎖便會打開。反之，如果輸入了錯誤的密碼，那麼系統會很聰明地把你先前輸入的第一個數字（最早的）丟掉，這麼一來，你只要再輸入一個數字就可以讓他變成長度 $N$ 了。\n\n舉例來說，如果 $N=4$，而且 Ayu 依序輸入了 `204320435`，那麼系統實際上會檢測 6 次（共有 5 種不同的 PIN）：\n\n* `2043`\n* `0432`\n* `4320`\n* `3204`\n* `2043`\n* `0435`\n\nAyu 想要在第一天測試 $K$ 種不同的密碼。你能不能找出任何一個長度最短的字串 $S$，使得它可以讓機器檢測到任意 $K$ 個不同的密碼呢？這個古老的系統能夠鍵入的數字種類有限：它們會是 `0` 到 `9` 這些數字中的某 $M$ 個。\n","link":"https://codeforces.com/gym/102001/problem/C","code":"ICPC-JAKARTA-2018-C","difficulty":7,"oj":"codeforces-gym","tags":null},"htmlAst":{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"題目敘述"}]},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"輸入包含 3 個整數 $N, M, K$（$1\\le N\\le 100000, 1\\le M\\le 10, 1\\le K\\le \\min(M^N, 100000)$），依序代表密碼的長度、能夠鍵入的數字種類、還有第一天想要測試的密碼量。輸入的第二列包含 $M$ 個整數：$A_i (0\\le A_i\\le 9)$ 表示能夠使用的數字們。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"你可以假設輸入的 $N, M, K$ 會使得答案字串不超過 $100000$ 位數。"}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸出說明"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"輸出任何一個滿足條件的、最短的字串 $S$。"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 1"}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"3 2 5\n4 7\n"}]}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 1"}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"7477447\n"}]}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 2"}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"2 5 9\n1 2 3 4 5\n"}]}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 2"}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"1234554321\n"}]}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 3"}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"6 3 2\n9 3 5\n"}]}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 2"}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"9353593\n"}]}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ 連結"}]},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://codeforces.com/gym/102001/problem/C"},"children":[{"type":"text","value":"Codeforces Gym 102001 - C"}]}]},{"type":"text","value":"\n"}]},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"首先，輸入的 $A_i$ 跟答案一點關係也沒有，因此我們總是可以假設這些數字是 $0, 1, \\ldots, M-1$。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這題的關鍵字只有一個，就是 "},{"type":"element","tagName":"a","properties":{"href":"https://en.wikipedia.org/wiki/De_Bruijn_sequence"},"children":[{"type":"text","value":"De Bruijn Sequence"}]},{"type":"text","value":"。對於給定的參數 $n, m$ 來說，De Bruijn Sequence $B(n, m)\\in [m]^n$ 是一個長度為 $n^m$ 的序列，把他接成一圈以後，任何連續的 $n$ 個字元都不相同。從這個序列的存在性來說，我們就可以斷定本題的答案長度一定是 $|S|=K+N-1$。所以囉，對於輸入的 $N, M, K$，答案之一就可以是 $B(N, M)$ 接成一圈以後的任何長度為 $K+N-1$ 的子字串。"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"第一種解法：一筆畫問題 Eulerian Path"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"常見的建構 De Bruijn Sequence 有兩種。第一種是將這個題目轉化成"},{"type":"element","tagName":"a","properties":{"href":"https://en.wikipedia.org/wiki/Eulerian_path"},"children":[{"type":"text","value":"一筆畫問題"}]},{"type":"text","value":"，如下圖所示（圖片參考自維基百科）："}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://upload.wikimedia.org/wikipedia/commons/thumb/3/38/De_bruijn_graph-for_binary_sequence_of_order_4.svg/800px-De_bruijn_graph-for_binary_sequence_of_order_4.svg.png","style":"max-width: 300px"},"children":[]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"從任何一點出發，然後走過所有的邊恰好可以接出一個 $B(2, 4)$。我們可以"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"利用 DFS 解一筆畫問題"}]},{"type":"text","value":"。由於這個圖很大（上面會有 $2^{N-1}$ 個節點），所以我們不可能把整張圖生出來再跑一筆畫演算法："}]},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"在 DFS 過程中，如果深度到達 $K$，那依循 DFS 的路徑就可以找到想要的 sequence。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"在 DFS 過程中，如果走訪完畢的邊數到達 $K$ 條，那這 $K$ 條邊也可以接成一個理想的 sequence。"}]},{"type":"text","value":"\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"由於 DFS 演算法每一步要嘛走訪一條新的邊、或是沿著一條邊回溯（並把這條邊丟進 stack），我們很確定最多只要走訪 $2K$ 條邊就可以中止我們的演算法。判斷一條邊被走過與否，有兩種方式：把每條邊雜湊以後存起來、或是把每個點雜湊以後，映至當前還有哪些邊沒走過（是一個 $0$ 到 $M-1$ 之間的數字）。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"所以本題可以在 $O(K)$ 次雜湊存取的時間被解決。"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"第二種解法：利用林登字串 Lyndon Words"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://en.wikipedia.org/wiki/Roger_Lyndon"},"children":[{"type":"text","value":"Roger Lyndon"}]},{"type":"text","value":" 是美國密西根大學的數學系教授，他在 1954 年的時候做了一些最小旋轉字典序字串的相關研究（主要是計數方面）。如果一個字串 $S$，滿足以下兩個特徵："}]},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"非循環字串：找不到另一個字串 $P$ 和整數 $k>1$ 使得 $S=\\underbrace{PP\\cdots P}_k$"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"$S$ 是所有 $S$ 的旋轉字串中字典順序最小的。"}]},{"type":"text","value":"\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"那麼該字串 $S$ 就是一個 Lyndon word。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"（題外話——說到旋轉字串與字典序，大家可能想到的就是 Burrows-Wheeler 轉換，這類型資料壓縮的技巧與 Lyndon Word 有著密切關聯。）"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"儘管早在 1934 年，M. H. Martin（我查不到是誰﹍）就用了類似 Lyndon word 的方法做出了 De Bruijn Sequence，但直到 1978 年才由 Harold Fredericksen 和 James Maiorana 兩位發現以下驚人的事實："}]},{"type":"element","tagName":"theorem","properties":{},"children":[{"type":"text","value":"\n把所有長度整除 $n$ 的 Lyndon words，依照字典順序（注意不是長度）排序後，全部接起來，就得到一個 de Bruijn 序列了！\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"下面這個演算法是使用第二種解法製作的："},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"依照字典順序"}]},{"type":"text","value":"產生所有長度整除 $n$ 的 Lyndon words，直到我們需要的長度為止。為了解釋下面的程式碼，我們利用關於 Lyndon word 旋轉字典序最小的性質："}]},{"type":"element","tagName":"theorem","properties":{},"children":[{"type":"text","value":"\n如果字串 $S$ 是一個 Lyndon word，那麼把他隨意拆成兩個子字串，左半邊的字典序保證小於右半邊。\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"有了這件事情以後，我們可以利用 DFS 一個一個字元決定。還記得 "},{"type":"element","tagName":"a","properties":{"href":"https://zh.wikipedia.org/wiki/%E5%85%8B%E5%8A%AA%E6%96%AF-%E8%8E%AB%E9%87%8C%E6%96%AF-%E6%99%AE%E6%8B%89%E7%89%B9%E7%AE%97%E6%B3%95"},"children":[{"type":"text","value":"KMP 字串匹配演算法"}]},{"type":"text","value":"嗎？我們利用 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"last[]"}]},{"type":"text","value":" 陣列描述對於所有前綴字串，與之匹配的最長前綴子字串。"}]},{"type":"element","tagName":"algorithm","properties":{},"children":[{"type":"text","value":"\n    "},{"type":"element","tagName":"generator","properties":{},"children":[{"type":"element","tagName":"pre","properties":{},"children":[{"type":"text","value":"\n        function*(input, ui) {\n            var S = input.S;\n            var n = S.length;\n            var last = [];\n            var i, j;\n            last.push(-1);\n            ui.setStyleOnce('arr', `0`, {fill: 'yellow'});\n              ui.setStyleOnce('S', `0`, {fill: 'yellow'});\n            for (i = 1; i < n; i++) {\n              yield {S: S, arr: last};\n              j = last[i-1]+1;\n              while (j > 0 && S[j] !== S[i])\n                j = last[j-1]+1;\n              last[i] = (S[i]===S[j]? j : -1)\n              for (var k = 0; k <= j; k++) {\n                ui.setStyleOnce('arr', `${i-k}`, {fill: 'lightyellow'});\n                ui.setStyleOnce('S', `${i-k}`, {fill: 'lightyellow'});\n              }\n              ui.setStyleOnce('arr', `${i}`, {fill: 'yellow'});\n              ui.setStyleOnce('S', `${i}`, {fill: 'yellow'});\n            }\n            return {S: S, arr: last};\n        }\n        "}]},{"type":"text","value":"\n    "}]},{"type":"text","value":"\n    "},{"type":"element","tagName":"inputdata","properties":{"data":"{\"S\": \"aaabaaabaaabaabbaaabaabbb\"}"},"children":[]},{"type":"text","value":"\n    "},{"type":"element","tagName":"indirectdisplay","properties":{"array":"","fixedwidth":"","minwidth":"30","highlightdiff":"","varname":"S"},"children":[]},{"type":"text","value":"\n    "},{"type":"element","tagName":"indirectdisplay","properties":{"array":"","fixedwidth":"","n":"25","minwidth":"30","highlightdiff":"","varname":"arr"},"children":[]},{"type":"text","value":"\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果輸入的字串是 Lyndon word，那麼我們可以得到兩個觀察："}]},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"last[]"}]},{"type":"text","value":" 陣列，從左到右一旦有數字變小，永遠是從 $-1$ 開始，不會從中間繼續。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Lyndon word 做出來的 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"last[]"}]},{"type":"text","value":" 陣列，最後一個 last 值永遠是 $-1$。"}]},{"type":"text","value":"\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"所以 DFS 就很簡單啦：每次決定到底現在的 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"last[i]"}]},{"type":"text","value":" 要等於 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"last[i-1]+1"}]},{"type":"text","value":" 還是等於 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"-1"}]},{"type":"text","value":"。如果是前者，那麼只有一種選擇，如果是後者，那麼根據「分兩半字典序必須比較大」的原則，下一個值必須是從 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"last[i-1]+1"}]},{"type":"text","value":" 對應到的字元"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"的下一個"}]},{"type":"text","value":"往後開始跳。"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"#include <iostream>\n#include <vector>\nusing namespace std;\n\nstring s;\nint N, M, K;\nint current[100005];\nint a[10];\n\nstring get_string(int len) {\n  string ret = \"\";\n  for (int x = 0; x < len; x++)\n    ret += ('0' + a[current[x]]);\n  return ret;\n}\n\nvoid generate_lyndon_words(int now, int last) {\n  if (now && N%now == 0 && last == -1) {\n    s += get_string(now);\n  }\n\n  if (s.size() >= K+N-1) return;\n  if (now == N) return;\n\n  // 選擇延續 last。\n  if (now > 0) {\n    current[now] = current[last+1];\n    generate_lyndon_words(now+1, last+1);\n  }\n  // 選擇把 last 換成 -1，但是你的字典序要比原本的還要大。\n  for (int x = now? current[last+1]+1 : 0; x < M; x++) {\n    current[now] = x;\n    generate_lyndon_words(now+1, -1);\n  }\n}\n\nint main() {\n  cin >> N >> M >> K;\n  for (int i = 0; i < M; i++) cin >> a[i];\n  generate_lyndon_words(0, -1);\n  while (s.size() < K+N-1) s += s; // 某種邊界條件...\n  s = s.substr(0, K+N-1);\n  cout << s << endl;\n  return 0;\n}\n"}]}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"備註"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"官方題解使用的是第一種解法的不需要 Hash 版，分成兩種情形探討："}]},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"$M^N\\le 2^{40}$。整個 de Bruijn Graph 的邊數 $= 2^{40}$，也就是說所有的邊都可以直接以 $M$-進位轉換成 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"long long"}]},{"type":"text","value":" 數值。此時可以用 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"set<long long>"}]},{"type":"text","value":" 直接存走訪過的邊。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"$M^N > 2^{40}$。此時使用 "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"random walk"}]},{"type":"text","value":" 大法，隨機產生長度為 $K+N-1$ 的序列，有很高的機率會產出一個合法的答案。"}]},{"type":"text","value":"\n"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"關於競程日記"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"🍅 如果您想到更多有趣漂亮簡單乾淨的解法話歡迎留言給競程日記小編群！"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"ℹ️ 這是一篇投稿給"},{"type":"element","tagName":"a","properties":{"href":"https://www.facebook.com/%E7%AB%B6%E7%A8%8B%E6%97%A5%E8%A8%98-1514973425463954/"},"children":[{"type":"text","value":"競程日記"}]},{"type":"text","value":"的文章，歡迎大家投稿、交流與分享程式解題競賽的點點滴滴！"}]}]}}},{"node":{"frontmatter":{"title":"Lexical Sign Sequence","category":"prob","path":"/problem/icpc/asia_jakarta_2018/H","date":"2019-01-05","_PARENT":"2c19eadd-cf3a-56ec-8638-7191c1d80dd2","description":"給你一個包含 $0, 1, -1$ 的序列 $P$，你的任務是要把所有 $0$ 換成 $\\pm 1$，並同時滿足以下 $K$ 個條件：每一個條件由三個整數 $A_i, B_i, C_i$ 描述之，表示從第 $A_i$ 個數加至第 $B_i$ 個數的總和，必須要 $\\ge C_i$。\n\n若有解，請輸出字典順序最小的序列。否則的話輸出 `Impossible`。\n","link":"https://codeforces.com/gym/102001/problem/H","code":"ICPC-JAKARTA-2018-H","difficulty":5,"oj":"codeforces-gym","tags":["ICPC 2018 Asia Jakarta Regional"]},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"簡化後題目敘述"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"輸入的第一列包含兩個整數 $N, K$ ($1\\le N\\le 100000; 0\\le K \\le 100000$) 代表序列的長度與條件的數量。第二列包含 $N$ 個整數 $P_i$ ($-1\\le P_i\\le 1$)，若 $P_i=0$ 代表第 $i$ 個位置還沒有決定是 $-1$ 還是 $1$，否則的話 $P_i$ 的值已經固定了。接下來的 $K$ 列每一列包含三個整數 $A_i, B_i, C_i$ ($1\\le A_i \\le B_i\\le N; -N\\le C_i\\le N$)。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸出說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"若這樣的序列存在，輸出 $N$ 個以空白隔開的整數。否則輸出 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"Impossible"}]},{"type":"text","value":"。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"3 2\n0 0 0\n1 2 2\n2 3 -1\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"1 1 -1\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"3 2\n0 -1 0\n1 2 2\n2 3 -1\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"Impossible\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ 連結"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://codeforces.com/gym/102001/problem/H"},"children":[{"type":"text","value":"Codeforces Gym 102001 - H"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"通常要找出最小的字典順序的題目，絕對與 Greedy 演算法脫不了干係。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"從前面填過去"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這題一個直接的想法就是從最前面開始，依序在空格（$P_i=0$ 處）填上 $-1$，並看看是否違反任何一個條件。但直接做要花 $O(NK)$ 的時間，所以實際上我們需要對每個條件 $j$ 維護一個值 ${\\mathit{remain}}=$「再補幾個 $-1$ 就不夠了」。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"假設我們現在填到第 $i$ 個位置了。令 $S$ 為目前與這個位置有關的所有條件形成的集合。我們考慮 $S$ 內所有條件的 ${\\mathit{remain}}$ 值。如果當前有某個 ${\\mathit{remain}} < 0$，代表沒救了；如果當前有某個 ${\\mathit{remain}}=0$，代表這格一定要填上 $1$，否則的話，我們總是可以貪婪地把這格填上 $-1$、並且把所有 $S$ 內條件的 ${\\mathit{remain}}$ 值通通減 $1$。（這一步可以透過宣告並維護一個全域變數 ${\\mathit{offset}}$，在常數時間內辦到把所有條件 ${\\mathit{remain}}$ 值通通 $-1$）。判斷是否存在 ${\\mathit{remain}}=0$ 就相當於判斷集合 $S$ 裡面的最小值是否 $=0$，這個可以透過一個 heap 辦到。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"於是，整個演算法就可以在 $O(N + K\\log K)$ 時間內完成。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"從後面改回來"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"另一個我覺得在演算法上面很實用的方法——拖延法（Lazy Evaluation，總是拖到最後一刻才作必要的改變），也可以用在這題當中。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我們先把所有能夠填數字的地方全部填上 $-1$，然後逐一檢視每個條件 $(A_i, B_i, C_i)$，如果這個條件沒有被滿足，那我們便貪心地從 $B_i$ 往回查看，把所有能改的 $-1$ 依序改成 $1$，直到條件被滿足為止。如果按照"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"右界"}]},{"type":"text","value":" $B_i$ 由小到大依序把條件加進去的話，每一次把 $-1$ 改成 $1$ 的過程，都保證會造福未來的條件，因此感情上我們可以得到字典順序最小的解。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"檢查一個條件需要計算一段連續和，如果不想花太多力氣的話，一個簡單的 "},{"type":"element","tagName":"a","properties":{"href":"https://zh.wikipedia.org/wiki/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84"},"children":[{"type":"text","value":"Fenwick Tree(BIT)"}]},{"type":"text","value":" 就可以達到目標。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我們注意到，當我們決定要把一個 $-1$ 改成 $1$ 的時候，這個數字就再也不會更改了。按照右界順序考慮條件有個實作上方便之處：可以把「仍然可改」的位置丟進一個"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"堆疊"}]},{"type":"text","value":"裡面，這個堆疊最上面的索引就恰好是距離當前右界最接近的一個。每一次需要把一個 $-1$ 變成 $1$ 就從這個堆疊上面拿 index 就好。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"堆疊的部分時間複雜度是 $O(N)$，對於每一個條件來說，除了修改 $-1$ 以外，其餘要花的時間只有一開始計算區間和所需的時間，因此整體時間複雜度為 $O(N+K\\log N)$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"#include <iostream>\n#include <vector>\nusing namespace std;\n\nint input[100005];\nint now[100005];\nvector<pair<int, int>> hook[100005];\nvector<int> stack;\nint N, K;\n\n// 一個活生生、跳脫框架（好像不太應該）的 Fenwick Tree。\nint bit[100005];\n\n// 把 x 這格的值加上 v。\nvoid add(int x, int v) {\n  while (x <= N) {\n    bit[x] += v;\n    x += (x & -x);\n  }\n}\n\n// 計算序列前 x 項的總和。\nint ask(int x) {\n  int ret = 0;\n  while (x) {\n    ret += bit[x];\n    x -= (x & -x);\n  }\n  return ret;\n}\n\n// 計算序列從第 l 項到第 r 項的總和。\nint ask(int l, int r) { return ask(r) - ask(l - 1); }\n\nint main() {\n  cin >> N >> K;\n  for (int i = 1; i <= N; i++) cin >> input[i];\n  for (int i = 1; i <= N; i++) now[i] = (input[i] != 0 ? input[i] : -1);\n  for (int i = 1; i <= N; i++) add(i, now[i]);\n  // 把所有條件依照右界的順序\n  for (int i = 0; i < K; i++) {\n    int l, r, c;\n    cin >> l >> r >> c;\n    hook[r].push_back({l, c});\n  }\n  for (int i = 1; i <= N; i++) {\n    // 如果現在這格是空的，就把註標塞進堆疊裡備用。\n    if (input[i] == 0) stack.push_back(i);\n    \n    // 逐一掃過所有右界在 i 的條件，並試圖滿足他們。\n    for (auto [l, c] : hook[i]) {\n      int v = ask(l, i);\n      // 如果當前總和仍不達 c，就必須把最接近的 -1 改成 1。\n      while (v < c) {\n        if (stack.empty() || stack.back() < l) {\n          puts(\"Impossible\");\n          return 0;\n        }\n        v += 2;\n        now[stack.back()] = 1;\n        add(stack.back(), 2);\n        stack.pop_back();\n      }\n    }\n  }\n  for (int i = 1; i <= N; i++) {\n    cout << now[i] << ' ';\n  }\n  cout << endl;\n  return 0;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"備註"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"稍微多想一下下，這題其實可以做到 $O(N+K)$。不過以這題的範圍而言，$O(N+K\\log N)$ 或 $O(N+K\\log K)$ 都相當足夠了。大致作法如下：首先經過線性時間預處理，把已經固定數值的地方全部處理掉。因此題目可以轉化為在一個空的序列上指定 $\\pm 1$ 的數值。接下來，我們可以利用 Disjoint Set，維護已經被改成 $1$ 的所有位置（以區間的方式儲存，如果相鄰兩個位置都是 $1$，那麼這兩個位置同屬一個 Set。）"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"display","properties":{"array":"","minWidth":"32","fixedwidth":"","uihelperContentMap":"{\n        \"1\":{fill: \"#FA8\"},\n    }","data":"[\"-1\", \"-1\", \"-1\", \"1\", \"1\", \"-1\", \"1\", \"1\", \"-1\", \"-1\", \"-1\", \"1\", \"1\", \"1\", \"-1\"]"},"children":[{"type":"text","value":"\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"因此計算連續和的任務就等價於紀錄當前區間「左方」（包含自己）的區間長度總和。這個「左方區間長度總和」的值，很幸運地不會頻繁地被更新（因為更新只會從已考慮過的位置最右邊開始，也就是當前的最右邊的區間。）"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"display","properties":{"array":"","minWidth":"32","fixedwidthRatios":"[1,1,1,2,1,2,1,1,1,3,1]","data":"[0, 0, 0, \"2\", 2, \"4\", 4, 4, 4, \"7\", 7]"},"children":[{"type":"text","value":"\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Disjoint Set Union 的演算法在這個情形下（每一次只 Union 相鄰兩個區間）是可以做到 worst-case $O(1)$ 的。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"關於 Greedy 演算法的正確性證明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這真的真的很恐怖。不要問。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Greedy 演算法是一類，通常直覺上很對，證明起來卻很崩潰的一類演算法（一淚眼算法）。可以參考 "},{"type":"element","tagName":"a","properties":{"href":"https://cs.stackexchange.com/questions/59964/how-to-prove-greedy-algorithm-is-correct"},"children":[{"type":"text","value":"Stack Exchange"}]},{"type":"text","value":"、"},{"type":"element","tagName":"a","properties":{"href":"http://www.cs.cornell.edu/courses/cs482/2007su/exchange.pdf"},"children":[{"type":"text","value":"康乃爾大學講義"}]},{"type":"text","value":"、"},{"type":"element","tagName":"a","properties":{"href":"https://web.stanford.edu/class/archive/cs/cs161/cs161.1138/handouts/120%20Guide%20to%20Greedy%20Algorithms.pdf"},"children":[{"type":"text","value":"史丹佛大學講義"}]},{"type":"text","value":"對於證明貪婪演算法的正確性所下的註解。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"關於競程日記"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"🍅 如果您想到更多有趣漂亮簡單乾淨的解法話歡迎留言給競程日記小編群！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"ℹ️ 這是一篇投稿給"},{"type":"element","tagName":"a","properties":{"href":"https://www.facebook.com/%E7%AB%B6%E7%A8%8B%E6%97%A5%E8%A8%98-1514973425463954/"},"children":[{"type":"text","value":"競程日記"}]},{"type":"text","value":"的文章，歡迎大家投稿、交流與分享程式解題競賽的點點滴滴！"}]}],"data":{"quirksMode":false}}}}]}}}