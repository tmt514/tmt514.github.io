{"data":{"markdownRemark":{"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"簡化後題目敘述"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"第一列包含一個正整數 $N$ ($1\\le N\\le 400000$)。\n第二列開始有 $N$ 列，每一列包含一個正整數 $S_i$ ($1\\le S_i\\le N$)。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸出說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"若存在答案，請輸出 $A, B$ 之值。若不存在形如 $A, B, A, B$ 的子序列，輸出 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"-1"}]},{"type":"text","value":"。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"8\n1\n3\n2\n4\n1\n5\n2\n4\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"1 2\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"8\n1\n2\n3\n4\n5\n6\n7\n1\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"-1\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 3"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"4\n2\n1\n2\n1\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 3"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"2 1\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ 連結"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://open.kattis.com/problems/wiknow"},"children":[{"type":"text","value":"Open Kattis - Wi Know"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"題目出處"}]},{"type":"text","value":"：ICPC 2018 Asia Hanoi Regional"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我們可以先做出以下觀察：如果存在至少一組交錯的子序列 A, B, A, B，那麼可以選取接連出現的某兩個 A、以及接連出現的某兩個 B，他們仍然是一個交錯出現的子序列。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"於是，對於每個數字 X 我們可以把所有 X 出現的位置表達成許多區間。這個題目便轉化為找字典順序最小的兩個相交的區間。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我們可以利用「掃描線」的概念，從右到左，維護目前跨過這條掃描線的區間們。如果現在有一個區間緊貼著掃描線"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"mysvg","properties":{"width":300,"height":200,"viewbox":"0 -100 300 100"},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"line","properties":{"x1":"200","x2":"200","y1":"-100","y2":"100","stroke":"black","strokeDasharray":"3"},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"line","properties":{"x1":"200","x2":"300","y1":"0","y2":"0","stroke":"2pt black"},"children":[{"type":"text","value":"\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"display","properties":{"binaryTree":"","complete":"","depth":"5","data":"{\n        value: Array(32).fill(\"   \"),\n    }"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"#include <bits/stdc++.h>\nusing namespace std;\n\n// 關於區間樹的操作：依序為插入、刪除、詢問。\nconst int LEAF_OFFSET = (1<<19);\nint tree[(1<<20)];\ninline int GetMinLabel(int l, int r) {\n  if (l == 0 || r == 0) return l+r;\n  return min(l, r);\n}\nvoid Insert(int x, int label) {\n  x += LEAF_OFFSET;\n  tree[x] = label;\n  for (x/=2; x; x/=2)\n    tree[x] = GetMinLabel(tree[x*2], tree[x*2+1]);\n}\nvoid Remove(int x) {\n  x += LEAF_OFFSET;\n  tree[x] = 0;\n  for (x/=2; x; x/=2)\n    tree[x] = GetMinLabel(tree[x*2], tree[x*2+1]);\n}\nint Query(int l) {\n  l += LEAF_OFFSET;\n  int ans = tree[l];\n  while (l) {\n    if (l%2==0)\n      ans = GetMinLabel(ans, tree[l+1]);\n    l/=2;\n  }\n  return ans;\n}\n\n\n// 紀錄輸入的序列。\nint S[400005];\nvector<int> positions[400005];\n\npair<int, int> best = {-1, -1};\nvoid UpdateSolution(int A, int B) {\n  if (best.first == -1 || best > make_pair(A, B)) {\n    best = {A, B};\n  }\n}\n\nvoid OutputAnswer() {\n  if (best.first == -1) cout << \"-1\" << endl;\n  else cout << best.first << \" \" << best.second << endl;\n}\n\nint main() {\n  int N;\n  cin >> N;\n  for (int i = 0; i < N; i++) {\n    cin >> S[i];\n    positions[S[i]].push_back(i);\n  }\n  for (int i = N-1; i >= 0; i--) {\n    int A = S[i];\n    positions[A].pop_back();\n    Remove(i);\n    if (!positions[A].empty()) {\n      int B = Query(positions[A].back());\n      if (B > 0) UpdateSolution(A, B);\n      Insert(positions[A].back(), A);\n    }\n  }\n  OutputAnswer();\n  return 0;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"關於競程日記"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"🍅 如果您想到更多有趣漂亮簡單乾淨的解法話歡迎留言給競程日記小編群！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"ℹ️ 這是一篇投稿給"},{"type":"element","tagName":"a","properties":{"href":"https://www.facebook.com/%E7%AB%B6%E7%A8%8B%E6%97%A5%E8%A8%98-1514973425463954/"},"children":[{"type":"text","value":"競程日記"}]},{"type":"text","value":"的文章，歡迎大家投稿、交流與分享程式解題競賽的點點滴滴！"}]}],"data":{"quirksMode":false}},"frontmatter":{"date":"January 15, 2019","path":"/problem/icpc/asia_singapore_2018/F","title":"Wi Know","description":"給你一個長度為 $N$ 的序列 $S_1, S_2, \\ldots, S_N$，請找出字典順序最小的 $(A, B)$ 配對，使得 $A\\neq B$ 而且這個序列包含至少一個子序列 $A, B, A, B$。\n","roadmap_label_h3":null,"backlink":"/icpcblog-weekly-2019"}}},"pageContext":{}}