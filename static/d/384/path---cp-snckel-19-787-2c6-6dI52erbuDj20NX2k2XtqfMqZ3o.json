{"data":{"markdownRemark":{"htmlAst":{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"唉唉，今天狀況超級不對啊。整個就是撞牆卡在 Suffix Palindrome 完全寫不出來，然後到了快三個半鐘頭才想到 Lighting Rectangle 要怎麼寫，還錯了一次，真是奇慘無比。"}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Lighting Rectangle "},{"type":"element","tagName":"a","properties":{"href":"https://www.codechef.com/SNCKEL19/problems/RECTLIT"},"children":[{"type":"text","value":"RECTLIT"}]}]},{"type":"element","tagName":"theorem","properties":{"c":"is-info"},"children":[{"type":"text","value":"\n在一個二維座標平面上有一個 $(0, 0)$ 到 $(N-1, N-1)$ 的正方形。在這個正方形區域內有 $K$ 盞燈。對於每一盞燈而言，這盞燈為原點可以把整個平面分成四個象限。而你可以為每一盞燈選擇照亮其中一個象限（在邊界上也算是有被照亮）。現在給你這 $K$ 盞燈的位置，是否存在一種方法，讓它們可以照亮整個正方形的範圍呢？\n"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"簡單來說就是分 Case 題："}]},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"在內部如果有四個點，那麼存在一種方式可以照亮所有區域。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"如果角落有一個點，那麼一定可以照亮所有區域。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"把邊分成上下、跟左右兩個部份。如果其中一個部份有兩個點，那可以照亮所有區域。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"如果邊上有一個點、而且內部有至少兩個點，那麼可以照亮所有區域。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"如果邊上有兩個點、而且內部至少有一個點，那麼可以照亮所有區域。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"除了以上情形外，其他情形都無法照亮所有區域。"}]},{"type":"text","value":"\n"}]},{"type":"element","tagName":"style","properties":{},"children":[{"type":"text","value":"\n#outer-rect {\n     stroke-width: 4;\n}\n.blue.quadrant.region {\n    fill: rgba(0,0,255,0.3);\n}\n.blue.quadrant.origin {\n    fill: blue;\n}\n.blue.quadrant.boundary.start,\n.blue.quadrant.boundary.end {\n    stroke-width: 2;\n    stroke: rgba(0,0,255,0.6);\n}\n.red.quadrant.region {\n    fill: rgba(255, 0, 0, 0.3);\n}\n.red.quadrant.origin {\n    fill: darkred;\n}\n.red.quadrant.boundary.start,\n.red.quadrant.boundary.end {\n    stroke-width: 2;\n    stroke: rgba(200,0,0,0.6);\n}\n.yellow.quadrant.region {\n    fill: rgba(255, 255, 0, 0.3);\n}\n.yellow.quadrant.origin {\n    fill: gold;\n}\n.yellow.quadrant.boundary.start,\n.yellow.quadrant.boundary.end {\n    stroke-width: 2;\n    stroke: rgba(233,233,0,0.6);\n}\n"}]},{"type":"element","tagName":"mysvg","properties":{"width":300,"height":200,"viewbox":"-10 -10 330 230"},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"rect","properties":{"x":"0","y":"0","width":300,"height":200,"fill":"none","stroke":"black","id":"outer-rect"},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"display-inner","properties":{"quadrant":"","dotAtOrigin":"","x":"90","y":"70","r":"600","angleStart":"0","angleEnd":"90","boundaryAtStart":"","boundaryAtEnd":"","c":"blue","clipHref":"#outer-rect"},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"display-inner","properties":{"quadrant":"","dotAtOrigin":"","x":"160","y":"120","r":"600","angleStart":"270","angleEnd":"360","boundaryAtStart":"","boundaryAtEnd":"","c":"red","clipHref":"#outer-rect"},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"display-inner","properties":{"quadrant":"","dotAtOrigin":"","x":"185","y":"90","r":"600","angleStart":"180","angleEnd":"270","boundaryAtStart":"","boundaryAtEnd":"","c":"yellow","clipHref":"#outer-rect"},"children":[]},{"type":"text","value":"\n"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"// by tmt514\n#include <cstdio>\nusing namespace std;\n\nvoid solve() {\n  int K, N;\n  scanf(\"%d%d\", &K, &N);\n  int ncorner = 0;\n  int nsidex = 0;\n  int nsidey = 0;\n  int ninside = 0;\n  for(int i=0;i<K;i++) {\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    int sx = (x==0 || x==N-1);\n    int sy = (y==0 || y==N-1);\n    if(sx && sy) { ncorner++; }\n    else if(sx) { nsidex++; }\n    else if(sy) { nsidey++; }\n    else ninside++;\n  }\n  if (ncorner==0 && nsidex==1 && nsidey==1 && ninside==0) puts(\"no\");\n  else\n  puts(4*ncorner + 2*nsidex + 2*nsidey + ninside >= 4? \"yes\": \"no\");\n}\n\nint main(void) {\n  int T;\n  scanf(\"%d\", &T);\n  while(T--) solve();\n  return 0;\n}\n"}]}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Suffix Palindromes "},{"type":"element","tagName":"a","properties":{"href":"https://www.codechef.com/SNCKEL19/problems/SFXPAL"},"children":[{"type":"text","value":"SFXPAL"}]}]},{"type":"element","tagName":"theorem","properties":{"c":"is-info"},"children":[{"type":"text","value":"\n考慮大小恰好為 $S$ 的字母集。請問有多少長度為 $N$ 的字串，其所有後綴字串都不是迴文？輸出答案除以 $M$ 的餘數。($1\\le N\\le 1000, 1\\le S\\le M-1 < 2^{30}-1$)\n"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這是一道很漂亮的 DP 題。假設 $f(n)$ 是答案，那麼每個字串的最後 $n-1$ 個字元都會被算入 $f(n-1)$。所以我們可以嘗試扣除掉加了一個字元以後會變成迴文的可能情形。而利用迴文的特性，我們可以證明在「加了一個字以後變成迴文」的當下，所有可能的迴文只能是來自 $f(\\lceil n/2\\rceil)$。所以，可以從 $f(1)=S$ 開始，依序計算 $f(n) = Sf(n-1) - f(\\lceil n/2\\rceil)$。"}]},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"display","properties":{"array":"","data":"[\"S\", \"---------f(n-1) 之中的答案---------\"]"},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"display","properties":{"array":"","data":"[\"--反過來的 f(n/2)--\", \"------f(n/2)------\"]"},"children":[]},{"type":"text","value":"    "}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"// by tmt514\n#include <iostream>\n#include <vector>\nusing namespace std;\ntypedef long long LL;\n\nint main(void) {\n  LL N, S, M;\n  cin >> N >> S >> M;\n  vector<LL> dp(N+1);\n  dp[0] = 1;\n  dp[1] = S;\n  for (int i = 2; i <= N; i++) {\n    dp[i] = S*dp[i-1] - dp[(i+1)/2];\n    dp[i] = (dp[i]%M+M)%M;\n  }\n  cout << dp[N] << endl;\n  return 0;\n}\n"}]}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Adi and the Tree "},{"type":"element","tagName":"a","properties":{"href":"https://www.codechef.com/SNCKEL19/problems/ADITREE"},"children":[{"type":"text","value":"ADITREE"}]}]},{"type":"element","tagName":"theorem","properties":{"c":"is-info"},"children":[{"type":"text","value":"\n在一個有 $N$ 個節點的樹上，進行 $M$ 項操作。一開始所有的節點都是「關燈」的狀態。每一次操作會給你兩個點 $a, b$。然後你把點 $a$ 與點 $b$ 切換其「開/關燈」狀態。接著，每一個操作結束之後，請你幫所有亮著的燈的節點兩兩配成一對，使得配對的節點距離總和最小。每次操作後，都輸出配對後的最小總和。$(1\\le N, M\\le 250000)$\n"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"另一個乾淨的漂亮問題。這題的主要觀察點在於：最小的距離總和，恰好等於所有「子樹中有奇數個亮燈」節點的數量。所以我們只需要維護一個資料結構，使得每次更新兩個點後，順便更新節點的奇偶性就行了！"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"要怎麼動態更新節點的奇偶性呢？我們可以利用樹鍊剖分，把一棵樹分成許多路徑，使得任何一個節點到樹根的路上至多只跨越 $O(\\log N)$ 條路徑。"}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"// by tmt514\n#include <algorithm>\n#include <cstdio>\n#include <vector>\nusing namespace std;\n\nstruct SegNode {\n  int odd, even;\n  bool inverted;\n};\n\nclass SegmentTree {\n  public:\n    vector<SegNode> seg;\n    void init(int x, int l, int r) {\n      if (l == r) seg[x] = (SegNode){0, 1, false};\n      else {\n        int m = (l+r)/2;\n        init(x*2, l, m);\n        init(x*2+1, m+1, r);\n        seg[x] = (SegNode){0, r-l+1, false};\n      }\n    }\n    void init(int n) {\n      seg.resize(4*n);\n      init(1, 1, n);\n    }\n    void push(int x, int l, int r) {\n      if (l == r) { seg[x].inverted = false; }\n      else if (seg[x].inverted) {\n        swap(seg[x*2].odd, seg[x*2].even);\n        swap(seg[x*2+1].odd, seg[x*2+1].even);\n        seg[x*2].inverted ^= 1;\n        seg[x*2+1].inverted ^= 1;\n        seg[x].inverted = false;\n      }\n    }\n    void pull(int x) {\n      seg[x].odd = seg[x*2].odd + seg[x*2+1].odd;\n      seg[x].even = seg[x*2].even + seg[x*2+1].even;\n      if (seg[x].inverted) swap(seg[x].odd, seg[x].even);\n    }\n    void toggle(int x, int l, int r, int target) {\n      if (r <= target) {\n        swap(seg[x].odd, seg[x].even);\n        seg[x].inverted ^= 1;\n      } else {\n        int m = (l+r)/2;\n        push(x, l, r);\n        toggle(x*2, l, m, target);\n        if (target > m) toggle(x*2+1, m+1, r, target);\n        pull(x);\n      }\n    }\n    int ask(int x, int l, int r, int target) {\n      if (r <= target) {\n        return seg[x].odd;\n      } else {\n        int m = (l+r)/2;\n        push(x, l, r);\n        return seg[x*2].odd + ask(x*2+1, m+1, r, target);\n      }\n    }\n};\n\nconst int N = 250000;\nvector<int> a[N];\n\nint total_odd[N];\nint parent[N];\nint depth[N];\nint child[N];\nint segtree_idx[N];\nint segtree_seq[N];\nSegmentTree t[N];\nint segtree_root[N];\n\nvoid find_depth_dfs(int x, int p=-1) {\n  parent[x] = p;\n  depth[x] = 1;\n  for(auto y : a[x]) {\n    if (y != p) {\n      find_depth_dfs(y, x);\n      if(depth[y]+1 > depth[x]) {\n        depth[x] = depth[y]+1;\n        child[x] = y;\n      }\n    }\n  }\n}\n\nint all_segids = 0;\nvoid build_segment_tree(int x, int segid=0, int d=1) {\n  segtree_idx[x] = segid;\n  segtree_seq[x] = d;\n  if (d == 1) {\n    segtree_root[segid] = x;\n    t[segid].init(depth[x]);\n  }\n  for (auto y : a[x]) {\n    if (y == parent[x]) continue;\n    if (y == child[x]) build_segment_tree(y, segid, d+1);\n    else {\n      all_segids++;\n      build_segment_tree(y, all_segids, 1);\n    }\n  }\n}\n\nvoid toggle(int x) {\n  vector<int> tree_ids;\n  int c = x;\n  while (c != -1) {\n    tree_ids.push_back(c);\n    c = parent[segtree_root[segtree_idx[c]]];\n  }\n  int delta = 0;\n  for (auto c : tree_ids) {\n    delta -= t[segtree_idx[c]].seg[1].odd;\n    t[segtree_idx[c]].toggle(1, 1, depth[segtree_root[segtree_idx[c]]], segtree_seq[c]);\n    delta += t[segtree_idx[c]].seg[1].odd;\n    total_odd[segtree_root[segtree_idx[c]]] += delta;\n  }\n}\n\nint main(void) {\n  int n, m;\n  // 處理第一部份的輸入：紀錄整棵樹的訊息。\n  scanf(\"%d\", &n);\n  for(int i=0;i<n-1;i++) {\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    a[x].push_back(y);\n    a[y].push_back(x);\n  }\n  // 用 DFS 連結每個節點至高度最高的子節點。\n  find_depth_dfs(1);\n  build_segment_tree(1);\n\n  scanf(\"%d\", &m);\n  while(m--) {\n    int A, B;\n    scanf(\"%d%d\", &A, &B);\n    toggle(A);\n    toggle(B);\n    printf(\"%d\\n\", total_odd[1]);\n  }\n\n  return 0;\n}\n"}]}]}]},"frontmatter":{"date":"December 08, 2018","path":"/cp/snckel19","title":"SnackDown19 Elimination Round","description":null}}},"pageContext":{}}