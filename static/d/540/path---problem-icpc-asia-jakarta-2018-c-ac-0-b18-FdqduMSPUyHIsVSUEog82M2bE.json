{"data":{"markdownRemark":{"htmlAst":{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"題目敘述"}]},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"輸入包含 3 個整數 $N, M, K$（$1\\le N\\le 100000, 1\\le M\\le 10, 1\\le K\\le \\min(M^N, 100000)$），依序代表密碼的長度、能夠鍵入的數字種類、還有第一天想要測試的密碼量。輸入的第二列包含 $M$ 個整數：$A_i (0\\le A_i\\le 9)$ 表示能夠使用的數字們。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"你可以假設輸入的 $N, M, K$ 會使得答案字串不超過 $100000$ 位數。"}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸出說明"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"輸出任何一個滿足條件的、最短的字串 $S$。"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 1"}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"3 2 5\n4 7\n"}]}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 1"}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"7477447\n"}]}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 2"}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"2 5 9\n1 2 3 4 5\n"}]}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 2"}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"1234554321\n"}]}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 3"}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"6 3 2\n9 3 5\n"}]}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 2"}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"9353593\n"}]}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ 連結"}]},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://codeforces.com/gym/102001/problem/C"},"children":[{"type":"text","value":"Codeforces Gym 102001 - C"}]}]},{"type":"text","value":"\n"}]},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"首先，輸入的 $A_i$ 跟答案一點關係也沒有，因此我們總是可以假設這些數字是 $0, 1, \\ldots, M-1$。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這題的關鍵字只有一個，就是 "},{"type":"element","tagName":"a","properties":{"href":"https://en.wikipedia.org/wiki/De_Bruijn_sequence"},"children":[{"type":"text","value":"De Bruijn Sequence"}]},{"type":"text","value":"。對於給定的參數 $n, m$ 來說，De Bruijn Sequence $B(n, m)\\in [m]^n$ 是一個長度為 $n^m$ 的序列，把他接成一圈以後，任何連續的 $n$ 個字元都不相同。從這個序列的存在性來說，我們就可以斷定本題的答案長度一定是 $|S|=K+N-1$。所以囉，對於輸入的 $N, M, K$，答案之一就可以是 $B(N, M)$ 接成一圈以後的任何長度為 $K+N-1$ 的子字串。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"常見的建構 De Bruijn Sequence 有兩種。第一種是將這個題目轉化成"},{"type":"element","tagName":"a","properties":{"href":"https://en.wikipedia.org/wiki/Eulerian_path"},"children":[{"type":"text","value":"一筆劃問題"}]},{"type":"text","value":"，如下圖所示（圖片參考自維基百科）："}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://upload.wikimedia.org/wikipedia/commons/thumb/3/38/De_bruijn_graph-for_binary_sequence_of_order_4.svg/800px-De_bruijn_graph-for_binary_sequence_of_order_4.svg.png","style":"max-width: 300px"},"children":[]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"從任何一點出發，然後走過所有的邊恰好可以接出一個 $B(2, 4)$。"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"#include <iostream>\n#include <vector>\nusing namespace std;\n\nstring s;\nint N, M, K;\nint last[100005] = {-1};\nint a[10];\nvector<int> current;\n\nstring get_string() {\n  string ret = \"\";\n  for (int x: current) ret += ('0' + a[x]);\n  return ret;\n}\n\nvoid generate_lyndon_words(int now = 0) {\n  if (now && N % now == 0) {\n    if (last[now-1] == -1) {\n      s += get_string();\n    }\n  }\n\n  if (s.size() >= K+N-1) return;\n  if (now == N) return;\n\n  for (int i = now? current[last[now-1]+1]: 0; i < M; i++) {\n    current.push_back(i);\n    if(now) last[now] = last[now-1]+1;\n    while (last[now] > 0 && current[now] != current[last[now]]) {\n      last[now] = last[last[now]-1]+1;\n    }\n    if (last[now]==0 && current[0] != current[now]) last[now] = -1;\n    generate_lyndon_words(now + 1);\n    current.pop_back();\n    if (s.size() >= K+N-1) break;\n  }\n}\n\nint main() {\n  cin >> N >> M >> K;\n  for (int i = 0; i < M; i++) cin >> a[i];\n  generate_lyndon_words();\n  while (s.size() < K+N-1)\n    s += s;\n  s = s.substr(0, K+N-1);\n  cout << s << endl;\n  return 0;\n}\n"}]}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"備註 1"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Edit Distance 好像又被稱為 "},{"type":"element","tagName":"a","properties":{"href":"https://en.wikipedia.org/wiki/Levenshtein_distance"},"children":[{"type":"text","value":"Levenshtein Distance"}]},{"type":"text","value":"，是一種衡量兩個字串是否有多接近的指標（metric，不是 pointer XD）。"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"備註 2"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Edit Distance 滿足三角不等式：$edit(A, B)+edit(B, C) \\ge edit(A, C)$，白話文解釋就是從 $A$ 換到 $C$ 的方法，至少有先從 $A$ 變成 $B$ 再從 $B$ 變成 $C$ 來得好。"}]},{"type":"element","tagName":"theorem","properties":{"title":"演算法豆知識","c":"is-primary"},"children":[{"type":"text","value":"\n在[強指數時間假說](/algo/strong-exponential-time-hypothesis)為真的前提之下，計算兩個長度為 $n$ 字串的 Edit Distance (exact) 至少得花 $\\Omega(n^{2-\\epsilon})$ 的時間。但是就近似演算法 (Approximation Algorithms) 而言， 2018 年 FOCS 的一篇最佳論文 [_Approximating Edit Distance Within Constant Factor in Truly Sub-Quadratic Time_](https://arxiv.org/abs/1810.03664)，在 $\\tilde{O}(n^{12/7})$ 時間內保證得到 $1680$-approxmation 的近似解，是為近期的一個重大突破。（作者們相信稍微用他們的方法再努力一下就可以做到 $(3+\\epsilon)$-approximation）\n"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"關於競程日記"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"🍅 如果您想到更多有趣漂亮簡單乾淨的解法話歡迎留言給競程日記小編群！"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"ℹ️ 這是一篇投稿給"},{"type":"element","tagName":"a","properties":{"href":"https://www.facebook.com/%E7%AB%B6%E7%A8%8B%E6%97%A5%E8%A8%98-1514973425463954/"},"children":[{"type":"text","value":"競程日記"}]},{"type":"text","value":"的文章，歡迎大家投稿、交流與分享程式解題競賽的點點滴滴！"}]}]},"frontmatter":{"date":"January 02, 2019","path":"/problem/icpc/asia_jakarta_2018/C","title":"Smart Thief","description":"Ayu 想要打開一個使用密碼鎖加密的箱子。為了能夠找出正確密碼，Ayu 必須要很遺憾地嘗試所有長度為 $N$ 的密碼組合。\n\n有趣的是，Ayu 發現了這套密碼鎖系統其實相當古板：當你輸入 $N$ 個數字以後，系統會自動判斷你到底輸入正確與否。如果輸入了正確的密碼，那麼箱子的鎖便會打開。反之，如果輸入了錯誤的密碼，那麼系統會很聰明地把你先前輸入的第一個數字（最早的）丟掉，這麼一來，你只要再輸入一個數字就可以讓他變成長度 $N$ 了。\n\n舉例來說，如果 $N=4$，而且 Ayu 依序輸入了 `204320435`，那麼系統實際上會檢測 6 次（共有 5 種不同的 PIN）：\n\n* `2043`\n* `0432`\n* `4320`\n* `3204`\n* `2043`\n* `0435`\n\nAyu 想要在第一天測試 $K$ 種不同的密碼。你能不能找出任何一個長度最短的字串 $S$，使得它可以讓機器檢測到任意 $K$ 個不同的密碼呢？這個古老的系統能夠鍵入的數字種類有限：它們會是 `0` 到 `9` 這些數字中的某 $M$ 個。\n","roadmap_label_h3":null,"backlink":null}}},"pageContext":{}}