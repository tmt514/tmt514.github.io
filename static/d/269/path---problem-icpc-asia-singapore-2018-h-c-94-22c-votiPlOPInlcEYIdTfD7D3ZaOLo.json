{"data":{"markdownRemark":{"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"簡化後題目敘述"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"第一列有三個正整數 $N, M, B$ （$1\\le N, M, B\\le 4\\cdot 10^5$），依序代表棋盤的列數與行數，還有方格總數。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"接下來有 $B$ 列，每一列有兩個數字 $r, c$ （$1\\le r\\le N$; $1\\le c\\le M$）代表方格的位置。這 $B$ 列中的第一列，包含了初始方塊的位置。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸出說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"3 4 6\n1 1\n1 2\n2 2\n2 3\n3 3\n3 4\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"possible\n< 1\n^ 2\n< 2\n^ 3\n< 3\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"3 4 9\n3 1\n2 1\n1 1\n1 2\n1 3\n1 4\n2 4\n3 4\n3 3\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"impossible\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ 連結"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://open.kattis.com/problems/slidingblocks"},"children":[{"type":"text","value":"Open Kattis - Sliding Blocks"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"題目出處"}]},{"type":"text","value":"：ICPC 2018 Asia Singapore Regional"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"今天是個輕巧的組合數學題喔！記分板上看起來解出來的隊伍數量不多，很可能是因為跟題效應的關係，導致後來大家都把時間花在寫起來比較複雜的題目上了。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"（記分板排名比較沒那麼前面的部份也有隊伍答對這題。這種跡象出現的時候，通常代表這題會有程式碼較短的解法，或是題目出壞了。這取決於是哪裡辦的比賽...不說了先解題）"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我們可以先考慮所有矩形交集的位置。接著，不難發現我們可以把兩個座標軸拆開來。任何 X 座標上交集後長度為 $c$ 的區間們，與任何 Y 座標上交集後長度為 $r$ 的區間們，的任意組合，都可以產生出"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"不同的"}]},{"type":"text","value":"、而且交集面積恰好是 $c\\times r$ 的矩形序列。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我們只要枚舉 $r, c$，當 $rc\\ge K$ 的時候把兩邊方法數乘起來、加至總和即可。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"所以現在問題便轉化成一維上的問題了！而一維的問題也只需要枚舉。考慮 $N$ 個 $[0, R]$ 之間的區間，我們希望最終他們的交集長度恰好為 $r$，那我們可以枚舉交集的位置：可能是 $[0, r], [1, r+1], \\ldots, [R-r, R]$。對於位置 $[i, r+i]$，我們再次分離左右界：左界可以選擇 $\\set{0, 1, \\ldots, i}$ 任何一個、並且至少有一個要踩到 $i$。右界可以選擇 $\\set{r+i, r+i+1, \\ldots, R}$ 的任何一個，而且至少有一個要踩到 $r+i$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"因此，在限制交集範圍恰好是 $[i, r+i]$ 的情形下，左界的選法數有 $(i+1)^N-i^N$ 種。如法炮製得右界方法數有 $(R-r-i+1)^N-(R-r-i)^N$ 種。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n\nconst LL MOD = 1e9 + 7;\n\nLL bigmod(LL a, LL n) {\n  LL b = 1;\n  while (n) {\n    if (n % 2)\n      b = b * a % MOD;\n    a = a * a % MOD;\n    n /= 2;\n  }\n  return b;\n}\n\nLL npower[5005];\nLL X[5005], Y[5005];\n\nint main() {\n  int N, R, C, K;\n  cin >> N >> R >> C >> K;\n  for (int i = 1; i <= 5000; i++)\n    npower[i] = bigmod(i, N);\n  for (int r = 0; r <= R; r++) {\n    for (int i = 0; i <= R - r; i++) {\n      X[r] += (npower[i + 1] - npower[i]) *\n              (npower[R - r - i + 1] - npower[R - r - i]) % MOD;\n    }\n    X[r] = (X[r] % MOD + MOD) % MOD;\n  }\n  for (int c = 0; c <= C; c++) {\n    for (int i = 0; i <= C - c; i++) {\n      Y[c] += (npower[i + 1] - npower[i]) *\n              (npower[C - c - i + 1] - npower[C - c - i]) % MOD;\n    }\n    Y[c] = (Y[c] % MOD + MOD) % MOD;\n  }\n\n  LL ans = 0;\n  for (int r = 1; r <= R; r++)\n    for (int c = 1; c <= C; c++) {\n      if (r * c >= K) {\n        ans += X[r] * Y[c] % MOD;\n      }\n    }\n  cout << ans % MOD << endl;\n  return 0;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"題外話"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"同一場比賽的 Problem A 明明就比這題需要的知識點難一些，為什麼過山過海呀 =口="}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"關於競程日記"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"🍅 如果您想到更多有趣漂亮簡單乾淨的解法話歡迎留言給競程日記小編群！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"ℹ️ 這是一篇投稿給"},{"type":"element","tagName":"a","properties":{"href":"https://www.facebook.com/%E7%AB%B6%E7%A8%8B%E6%97%A5%E8%A8%98-1514973425463954/"},"children":[{"type":"text","value":"競程日記"}]},{"type":"text","value":"的文章，歡迎大家投稿、交流與分享程式解題競賽的點點滴滴！"}]}],"data":{"quirksMode":false}},"frontmatter":{"date":"January 18, 2019","path":"/problem/icpc/asia_singapore_2018/H","title":"Sliding Blocks","description":"在一個 $N\\times M$ 大小的方格棋盤上，一開始恰好有一個格子上頭有個方塊，而棋盤的其他地方都是空的。現在，你可以逐步把一些方塊從棋盤的邊界，沿著水平或垂直方向**滑入**棋盤中。放入棋盤的方塊會一直滑，直到撞到某個現存於棋盤上的方塊停止。\n\n現在給你一個盤面，已知第一塊初始的方塊位置。請問能否用滑的滑出這個盤面？保證輸入的盤面所有方塊的位置連接成一棵樹：也就是說，如果我們把方塊當作節點、緊黏著邊的兩個方塊建立一條邊，那麼整個圖會形成一棵樹。\n","roadmap_label_h3":null,"backlink":"/icpcblog-weekly-2019"}}},"pageContext":{}}