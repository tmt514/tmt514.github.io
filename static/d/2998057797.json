{"data":{"pages":{"edges":[{"node":{"frontmatter":{"title":"關於競程日記 2019","category":"roadmap","path":"/icpcblog-weekly-2019","date":"2018-12-26","_PARENT":"5b35e544-8f78-5ac3-a045-f8cece05889c","description":null,"link":null,"code":null,"difficulty":null,"oj":null},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"每一週我們會決定一個題組，然後從當中盡量每天挑選一題撰寫題解，並且同步發布於"},{"type":"element","tagName":"a","properties":{"href":"https://www.facebook.com/TaiwanCompetitiveProgrammingBlog/"},"children":[{"type":"text","value":"競程日記FB專頁"}]},{"type":"text","value":"上面。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"(Jan.01 - Jan.07) ICPC 2018 Asia Jakarta Regional"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://codeforces.com/blog/entry/63220"},"children":[{"type":"text","value":"Codeforces 文章連結"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://codeforces.com/gym/102001"},"children":[{"type":"text","value":"Codefroces Gym 題目連結"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://competition.binus.ac.id/icpc2018/final.html"},"children":[{"type":"text","value":"Final Standings"}]},{"type":"text","value":" (點選上面題號可以看到題目 PDF)"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://github.com/jonathanirvings/icpc-jakarta-2018/"},"children":[{"type":"text","value":"測試資料與解答 GitHub"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"提供競程日記的參考題解："},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"a","properties":{"href":"/problem/icpc/asia_jakarta_2018/A"},"children":[{"type":"element","tagName":"span","properties":{"className":["tag","is-success"]},"children":[{"type":"text","value":"A"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"span","properties":{"className":["tag"]},"children":[{"type":"text","value":"B"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"a","properties":{"href":"/problem/icpc/asia_jakarta_2018/C"},"children":[{"type":"element","tagName":"span","properties":{"className":["tag"]},"children":[{"type":"text","value":"C"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"span","properties":{"className":["tag"]},"children":[{"type":"text","value":"D"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"span","properties":{"className":["tag"]},"children":[{"type":"text","value":"E"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"a","properties":{"href":"/problem/icpc/asia_jakarta_2018/F"},"children":[{"type":"element","tagName":"span","properties":{"className":["tag"]},"children":[{"type":"text","value":"F"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"a","properties":{"href":"/problem/icpc/asia_jakarta_2018/G"},"children":[{"type":"element","tagName":"span","properties":{"className":["tag"]},"children":[{"type":"text","value":"G"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"span","properties":{"className":["tag"]},"children":[{"type":"text","value":"H"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"span","properties":{"className":["tag"]},"children":[{"type":"text","value":"I"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"span","properties":{"className":["tag"]},"children":[{"type":"text","value":"J"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"span","properties":{"className":["tag"]},"children":[{"type":"text","value":"K"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"span","properties":{"className":["tag"]},"children":[{"type":"text","value":"L"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"(Jan.08 - Jan.14) ICPC 2018 Asia Hanoi Regional"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://open.kattis.com/problem-sources/The%202018%20ICPC%20Asia%20Hanoi%20Regional%20Contest"},"children":[{"type":"text","value":"ProblemSet On Open Kattis"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://hanoi18.kattis.com/standings"},"children":[{"type":"text","value":"Final Standings"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"提供競程日記的參考題解："},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"span","properties":{"className":["tag"]},"children":[{"type":"text","value":"A"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"span","properties":{"className":["tag"]},"children":[{"type":"text","value":"B"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"span","properties":{"className":["tag"]},"children":[{"type":"text","value":"C"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"span","properties":{"className":["tag"]},"children":[{"type":"text","value":"D"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"span","properties":{"className":["tag"]},"children":[{"type":"text","value":"E"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"span","properties":{"className":["tag"]},"children":[{"type":"text","value":"F"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"span","properties":{"className":["tag"]},"children":[{"type":"text","value":"G"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"span","properties":{"className":["tag"]},"children":[{"type":"text","value":"H"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"span","properties":{"className":["tag"]},"children":[{"type":"text","value":"I"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"span","properties":{"className":["tag"]},"children":[{"type":"text","value":"J"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"span","properties":{"className":["tag"]},"children":[{"type":"text","value":"K"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"span","properties":{"className":["tag"]},"children":[{"type":"text","value":"L"}]}]},{"type":"text","value":"\n"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"Leetcode 刷題指南 v0.1","category":"roadmap","path":"/leetcode-guide","date":"2018-12-21","_PARENT":"7f2afd93-1f83-5c39-b156-2babacdc8d3e","description":null,"link":null,"code":null,"difficulty":null,"oj":null},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這份指南把一些面試經典題型整理出來，給大家參考。\n每一個主題大約是 1 小時的閱讀份量與 3 小時的實作份量。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"一道題目如果給不出三種不盡相同的作法，代表你還沒有參透這個題目，或是這個題目太死板啦。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"卡恩 (2018.12)"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"鏈結串列 Linked Lists"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"mylink","properties":{"to":"/leetcode-guide/linked-lists"},"children":[{"type":"text","value":"鏈結串列的大致分類 Type of Linked Lists"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"練習題"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"陣列 Arrays"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"排序方法 Sorting Algorithms"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"單調性與兩個指標 Two Pointers"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"樹 Trees"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"堆疊與深度優先搜索 Stack and Depth First Search"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"佇列與廣度優先搜索 Queue and Breadth First Search"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"雜湊表 Hash Tables"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"優先序佇列與堆積 Priority Queues and Heaps"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"圖 Graphs"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"動態規劃：序列 Dynamic Programming on Sequences"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"動態規劃：字串 Dynamic Programming on Strings"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"機率與隨機數 Probabilities"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"搜尋樹 Search Trees"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"字母樹 Tries"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"計算幾何 Computational Geometry"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"數論 Number Theory"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"物件導向程式設計 OOP"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"熟悉你的程式語言：C++"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"熟悉你的程式語言：Python"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"熟悉你的程式語言：Javascript"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"測試文章","category":"algo","path":"/hello-world","date":"2018-11-09","_PARENT":"192a55e1-4ef0-5d9d-be9c-3ceb8fe80ce8","description":null,"link":null,"code":null,"difficulty":null,"oj":null},"htmlAst":{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"This is a test"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"$f(x) = x^2$"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"額外的測試嗎XD"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這樣就可以一邊寫文章一邊寫數學式子了！"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"$ax+by=\\frac{z^2}{y} what$"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"程式碼"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"test"}]}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"test123 \n"}]}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"#include <cstdio>\nusing namespace std;\n\nint main(void) {\n    // 中文也可以\n    printf(\"Hello! World!\\n\");\n    return 0;\n}\n"}]}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"My Algorithm Displayer"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"1. Static Data Display."}]},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"display","properties":{"array":"","data":"[1, 2, \"test123\\n456\"]"},"children":[]}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-html"]},"children":[{"type":"text","value":"<display array\n    data='[1, 2, \"test123\\n456\"]'></display>\n"}]}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"2. A simple looping algorithm."}]},{"type":"element","tagName":"algorithm","properties":{},"children":[{"type":"text","value":"\n    "},{"type":"element","tagName":"generator","properties":{},"children":[{"type":"element","tagName":"pre","properties":{},"children":[{"type":"text","value":"\n        function*(input, ui) {\n            var n = input.n;\n            var i;\n            var s = [];\n            for (i = 0; i < n; i++) {\n                s.push(i);\n                ui.setStyleOnce('arr', `${i}`, {fill: 'yellow'});\n                yield {arr: s};\n            }\n            return {arr: s};\n        }\n        "}]},{"type":"text","value":"\n    "}]},{"type":"text","value":"\n    "},{"type":"element","tagName":"inputdata","properties":{"data":"{\"n\": 10}"},"children":[]},{"type":"text","value":"\n    "},{"type":"element","tagName":"indirectdisplay","properties":{"array":"","n":"10","fixedwidth":"","highlightdiff":"","varname":"arr"},"children":[]},{"type":"text","value":"\n"}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-html"]},"children":[{"type":"text","value":"<algorithm>\n    <generator><pre>\n"}]}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-javascript"]},"children":[{"type":"text","value":"        function*(input, ui) {\n            var n = input.n;\n            var i;\n            var s = [];\n            for (i = 0; i < n; i++) {\n                s.push(i);\n                ui.setStyleOnce('arr', `${i}`, {fill: 'yellow'});\n                yield {arr: s};\n            }\n            return {arr: s};\n        }\n"}]}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-html"]},"children":[{"type":"text","value":"        </pre>\n    </generator>\n    <inputdata\n        data='{\"n\": 10}'\n    ></inputdata>\n    <indirectdisplay\n        array\n        n='10'\n        fixedwidth\n        highlightdiff\n        varname='arr'\n    ></indirectdisplay>\n</algorithm>\n"}]}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"3. A simple grid."}]},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"display","properties":{"grid":"","data":"[\"...#.#\",\"..###.\",\"#...#.\"]"},"children":[]}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-html"]},"children":[{"type":"text","value":"<display grid\n    data='[\"...#.#\",\"..###.\",\"#...#.\"]'\n    ></display>\n"}]}]},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"display","properties":{"grid":"","notext":"","uistore":"{\n        styleRules: {\n            ruleZZ: {\n                apply_to: 'node',\n                pure_predicate_fn: (nodeProps) => { return nodeProps.content === '#'; },\n                options: { fill: 'black' },\n            }\n        }\n    }","data":"[\"...#.#\",\"..###.\",\"#...#.\"]"},"children":[]}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-html"]},"children":[{"type":"text","value":"<display grid\n    notext\n    uistore=\"{\n        styleRules: {\n            ruleZZ: {\n                apply_to: 'node',\n                pure_predicate_fn: (nodeProps) => { return nodeProps.content === '#'; },\n                options: { fill: 'black' },\n            }\n        }\n    }\"\n    data='[\"...#.#\",\"..###.\",\"#...#.\"]'\n    ></display>\n"}]}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"4. Random walk on a grid."}]},{"type":"element","tagName":"algorithm","properties":{},"children":[{"type":"text","value":"\n    "},{"type":"element","tagName":"generator","properties":{},"children":[{"type":"element","tagName":"pre","properties":{},"children":[{"type":"text","value":"\n        function*(input, ui) {\n            var n = input.n;\n            var s = [];\n            var i, j;\n            var x = Math.floor(Math.random()*n);\n            var y = Math.floor(Math.random()*n);\n            for (i = 0; i < n; i++) {\n                var t = [];\n                for (j = 0; j < n; j++) {\n                    if (Math.floor(Math.random()*10) !== 0)\n                        t.push('.');\n                    else\n                        t.push('#');\n                }\n                s.push(t);\n            }\n            s[x][y] = '*';\n            ui.setStyle('arr', JSON.stringify([x, y]), {fill: '#FFEE33'});\n            ui.setStyleOnce('arr', JSON.stringify([x, y]), {fill: 'blue'});\n            yield { arr: s };\n            //\n            while (true) {\n                var d = Math.floor(Math.random()*4);\n                if (d === 0 && x+1 < n && s[x+1][y] === '.') {\n                    s[x][y] = '.'\n                    s[x+1][y] = '*'\n                    x += 1\n                } else if (d === 1 && x > 0 && s[x-1][y] === '.') {\n                    s[x][y] = '.'\n                    s[x-1][y] = '*'\n                    x -= 1\n                } else if (d === 2 && y+1 < n && s[x][y+1] === '.') {\n                    s[x][y] = '.'\n                    s[x][y+1] = '*'\n                    y += 1\n                } else if (d === 3 && y > 0 && s[x][y-1] === '.') {\n                    s[x][y] = '.'\n                    s[x][y-1] = '*'\n                    y -= 1\n                }\n                ui.setStyle('arr', JSON.stringify([x, y]), {fill: '#FFEE33'});\n                ui.setStyleOnce('arr', JSON.stringify([x, y]), {fill: 'blue'});\n                yield { arr: s };\n            }\n        }\n        "}]},{"type":"text","value":"\n    "}]},{"type":"text","value":"\n    "},{"type":"element","tagName":"inputdata","properties":{"data":"{\"n\": 10}"},"children":[]},{"type":"text","value":"\n    "},{"type":"element","tagName":"indirectdisplay","properties":{"grid":"","uistore":"{\n            styleRules: {\n                ruleZZ: {\n                    apply_to: 'node',\n                    pure_predicate_fn: (nodeProps) => { return nodeProps.content === '#'; },\n                    options: { fill: 'black', fontColor: 'white' },\n                }\n            }\n        }","varname":"arr"},"children":[]},{"type":"text","value":"\n"}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-javascript"]},"children":[{"type":"text","value":"function*(input, ui) {\n            var n = input.n;\n            var s = [];\n            var i, j;\n            var x = Math.floor(Math.random()*n);\n            var y = Math.floor(Math.random()*n);\n            for (i = 0; i < n; i++) {\n                var t = [];\n                for (j = 0; j < n; j++) {\n                    if (Math.floor(Math.random()*10) !== 0)\n                        t.push('.');\n                    else\n                        t.push('#');\n                }\n                s.push(t);\n            }\n            s[x][y] = '*';\n            ui.setStyle('arr', JSON.stringify([x, y]), {fill: '#FFEE33'});\n            ui.setStyleOnce('arr', JSON.stringify([x, y]), {fill: 'blue'});\n            yield { arr: s };\n            //\n            while (true) {\n                var d = Math.floor(Math.random()*4);\n                if (d === 0 && x+1 < n && s[x+1][y] === '.') {\n                    s[x][y] = '.'\n                    s[x+1][y] = '*'\n                    x += 1\n                } else if (d === 1 && x > 0 && s[x-1][y] === '.') {\n                    s[x][y] = '.'\n                    s[x-1][y] = '*'\n                    x -= 1\n                } else if (d === 2 && y+1 < n && s[x][y+1] === '.') {\n                    s[x][y] = '.'\n                    s[x][y+1] = '*'\n                    y += 1\n                } else if (d === 3 && y > 0 && s[x][y-1] === '.') {\n                    s[x][y] = '.'\n                    s[x][y-1] = '*'\n                    y -= 1\n                }\n                ui.setStyle('arr', JSON.stringify([x, y]), {fill: '#FFEE33'});\n                ui.setStyleOnce('arr', JSON.stringify([x, y]), {fill: 'blue'});\n                yield { arr: s };\n            }\n        }\n"}]}]}]}}},{"node":{"frontmatter":{"title":"演算法中的四種解題思維","category":"algo","path":"/algo/algorithmic-thinking","date":"2018-11-27","_PARENT":"4a56ef36-1df5-56f6-b0bf-74d9f0d9ee3f","description":null,"link":null,"code":null,"difficulty":null,"oj":null},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%80%9D%E7%BB%B4"},"children":[{"type":"text","value":"運算思維"}]},{"type":"text","value":"（Computational Thinking）在近年來逐漸被關注資訊教育的人們提出來討論。而運算思維包含了"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"問題解構"}]},{"type":"text","value":"（Decomposition）、"},{"type":"element","tagName":"a","properties":{"href":"http://terms.naer.edu.tw/detail/1603992/"},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"型樣辨識"}]}]},{"type":"text","value":"（Pattern Recognition）、"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"模型抽象化"}]},{"type":"text","value":"（Abstraction）以及"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"演算法設計"}]},{"type":"text","value":"（Algorithm Design）。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"對我來說，演算法設計的世界裡面，解題的過程也可以大致分類成以下四種思考方式。而這些思考方式構建了大家在演算法教科書中提及的各種解題方法（又稱為 "},{"type":"element","tagName":"a","properties":{"href":"https://en.wikipedia.org/wiki/Algorithmic_paradigm"},"children":[{"type":"text","value":"Algorithmic Paradigm"}]},{"type":"text","value":"），比方說動態規劃或是分而治之等。大致可以表示成以下的圖片："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{"className":["has-text-centered"]},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"img","properties":{"src":"/algthinking-3a46181cc32653fb172ffd3d39e23591.png","style":"max-width:700px"},"children":[]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"枚舉 Enumeration"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"程式解題與數學解題其中一個不同之處，在於我們擁有運算資源，可以把複雜的、難以公式化的數學結論，用跑程式的方式輕鬆驗證。枚舉（Enumeration）就是其中一種很「資訊科學」的解題方式：如果我能夠證明我的答案在某個特定的範圍中，那麼我只要逐一考慮過所有可能的答案即可。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"簡而言之，若一道題目滿足以下兩個性質："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"若給定一個解 X，我們可以有效率地檢驗 X 是否正確。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"把可能的解所在的範圍，縮小到足以負擔的數量級。\n那麼通常我們可以寫出好寫又有效率的程式。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"迭代 Iteration"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"迭代法，通常是用於我們可以逐漸找出答案的演算法。最常見的應用是漸進演算法、數值方法、人工智慧等。在競賽之中，我們也可以利用迭代的概念，有效率地得出我們想要的解。最直白的應用就是 for 迴圈。對，還有 while 迴圈。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"遞推 Induction"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"在驗證程式邏輯的正確性的時候，我們很常會使用數學歸納法：「如果小測資是對的，那麼根據我們解題的思路，也可以推得大測資是對的。」P老師也曾經說過：「歸納」、「遞迴」跟「分而治之」其實是一體三面，對於有效率地寫程式解決問題是相當重要的。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"轉化 Reduction"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"轉化跟歸納其實是兩個不同的方向：如果說歸納是以建構的方式，由小範圍的測資組合出大範圍測資的答案，那麼轉化有點像是平行地把一個問題轉變成另一個已知解法問題。轉化在解題思維中無所不在，畢竟大家在面對一道新的題目時，總是會習慣搜尋自己曾經解決過的類似題目、並且利用以前的經驗，把思路稍作修改從而獲得真正的解法。"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"二分搜尋法的實作基礎","category":"algo","path":"/algo/binary-search","date":"2018-11-13","_PARENT":"9c22712b-826d-5476-b761-6245a830bbcc","description":null,"link":null,"code":null,"difficulty":null,"oj":null},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"前幾天有位朋友跟我反應，二分搜尋法好難寫啊。有的時候寫下去，甚至無法確定這樣寫會不會對，只能祈禱線上提交的時候會順利拿到 "},{"type":"element","tagName":"span","properties":{"style":"color:green"},"children":[{"type":"element","tagName":"b","properties":{},"children":[{"type":"text","value":"Accepted"}]}]},{"type":"text","value":"。這樣的想法是很危險的！你不應該仰賴評測系統給你的反饋，才能知道自己是不是對的。至少在上傳之前，思考一下正確性，讓自己更安心。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"先說結論"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"在繼續介紹各種二分搜的方法與證明之前，我想要先下個結論：每個人都應該要有一套屬於自己的二分搜尋法。而且 "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"只用"}]},{"type":"text","value":" 這套屬於自己的二分搜尋法。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"二分搜的概念"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"假想你有一個只有 0 和 1 兩種數字的陣列，然後所有的 0 都排在 1 的前面。 "}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"display","properties":{"array":"","fixedwidth":"","data":"[0, 0, 0, 0, 1, 1, 1, 1, 1, 1]"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"要如何找出第一個 1 的位置呢？想法很單純，我們戳一個中間的格子，如果這個格子是 0，代表「所有這個格子之前（包含這個格子）都不是答案」。如果這個格子是 1，則代表「所有這個格子之後（"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"不"}]},{"type":"text","value":"包含這個格子）也不是答案」。於是我們得到一個演算法："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"1. 戳一個中間的格子 X\n2. 如果 X = 1，那麼把這個格子右邊的所有格子丟掉\n3. 如果 X = 0，那麼把這個格子本身與其左邊所有格子丟掉\n4. 重複以上操作\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這個演算法什麼時候會停？它不會停，因為從上面的演算法描述，我們並沒有叫他停下來。那什麼時候應該要停下來？顯然每一次操作的過程中，左邊丟掉的格子們都是 0、右邊丟掉的格子們都是 1。我們可以把這個觀察寫成重要的"},{"type":"element","tagName":"a","properties":{"href":"https://en.wikipedia.org/wiki/Loop_invariant"},"children":[{"type":"text","value":"迴圈不變量"}]},{"type":"text","value":"。在迴圈結束後，如果只剩下一個格子，而這個格子是 1，那麼根據演算法來說我們永遠不會把這個格子丟掉。而根據迴圈不變量，我們就保證了這格就是我們要的第一個 1。反之，如果這個格子裡面的數字是 0，那麼根據演算法，下一步這格就會被丟掉，而我們也可以推斷出「這陣列不存在 1」。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"二分搜的實作"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"但是實際寫成程式碼就很怪了啊。到底我們要怎麼表示目前的邊界（或是紀錄被丟掉的格子）呢？因為剩餘的格子們是連續的一段，我們可以利用兩個變數 $\\ell$ 和 $r$ 來表示這個區間 $[\\ell, r]$。有些人喜歡半開半閉區間 $[\\ell, r)$，也就是說當我們存入兩個變數 $\\ell$ 和 $r$ 的時候，實際有效的陣列範圍是 $[\\ell, r-1]$。那樣寫沒什麼壞處，而且也巧妙地利用了當 $l+r$ 是奇數時 $(l+r)/2$ 向下取整的特性，讓中間值 $m$ 可以留在 $[\\ell, r-1]$ 這個區間裡面。不過我自己的習慣是使用閉區間。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"我自己的習慣"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我的寫法是閉區間的寫法，而且總是維護當前找到的"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"答案候選"}]},{"type":"text","value":"。引入一個變數 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"ans"}]},{"type":"text","value":"，一開始把它標記為「不存在」，如果我找到一個滿足條件的格子（比方說，這個格子必須是 1）那麼在找到的當下，我會更新 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"ans"}]},{"type":"text","value":" 的值。讓變數 $\\ell, r$ 永遠只用來表達邊界，不要賦予他們過多的意義。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"int lower_bound(int array[], auto predicate_fn) {\n    int l, r, ans = -1;\n    while(l <= r) {\n        int m = (l + r) / 2;\n        if (predicate_fn(array[m]) == true) {\n            // 如果滿足條件，就把右邊丟掉，並且把當前資料加入可能的答案裡。\n            ans = m;\n            r = m - 1;\n        } else {\n            // 如果不滿足條件，就把左邊丟掉。\n            l = m + 1;\n        }\n    }\n    return ans;\n}\n"}]}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"二分搜尋法的應用 1：答案仍在範圍裡","category":"algo","path":"/algo/binary-search-applications","date":"2018-11-14","_PARENT":"3d839906-7ed2-50ad-9428-1b2246a93759","description":null,"link":null,"code":null,"difficulty":null,"oj":null},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"前一篇文章 "},{"type":"element","tagName":"a","properties":{"href":"/algo/binary-search"},"children":[{"type":"text","value":"二分搜尋法的實作基礎"}]},{"type":"text","value":" 提及了關於二分搜的核心概念：每一次迭代都排除了一些不可能是答案的值。我們今天來看看二分搜尋法有哪些應用吧！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"勘根定理"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"對於一個連續函數 $f$，如果這個函數在 $[a, b]\\subseteq \\mathbb{R}$ 區間內有定義，而且 $f(a) < 0$、$f(b) > 0$，那麼"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"勘根定理"}]},{"type":"text","value":"告訴我們說，中間必定存在一個 $x\\in [a, b]$ 使得 $f(x)=0$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"上面這個定理只告訴我們存在"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"至少"}]},{"type":"text","value":"一個根，但其實它的證明就是利用二分搜尋法的概念！而且是反方向的概念："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"article","properties":{"className":["message","is-success"]},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{"className":["message-body"]},"children":[{"type":"text","value":"\n每一次迭代都保證了答案仍在剩下的值裡面。\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"考慮無窮序列 $\\{a_i\\}$ 以及 $\\{b_i\\}$。他們的定義如下：$a_0=a$ 且 $b_0=b$。接著我們依序定義，對所有正整數 $i$，令 $m_i = (a_{i-1}+b_{i-1})/2$，若 $f(m_i) = 0$，則我們找到了 $x=m_i$。否則的話，我們根據 $f(m_i)$ 之值定義新的一組 $(a_i, b_i)$："}]},{"type":"text","value":"\n$$\n(a_i, b_i) = \\begin{cases}\n(a_{i-1}, m_i) &\\text{ if } f(m_i) > 0,\\\\\n(m_i, b_{i-1}) &\\text{ if } f(m_i) < 0.\n\\end{cases}\n$$\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"二分在哪裡呢？我們可以發現每一次迭代，區間 $[a_i, b_i]$ 長度是前一次迭代的 $[a_{i-1}, b_{i-1}]$ 的一半！由於 $\\{a_i\\}$ 是遞增有上界、$\\{b_i\\}$ 遞減有下界、他們彼此之間距離又會趨近於 $0$，因此最終 $\\lim_{i\\to\\infty} a_i = x^* = \\lim_{i\\to\\infty} b_i$。由"},{"type":"element","tagName":"a","properties":{"href":"https://zh.wikipedia.org/wiki/%E5%A4%BE%E6%93%A0%E5%AE%9A%E7%90%86"},"children":[{"type":"text","value":"夾擠定理"}]},{"type":"text","value":"可得知 $f(x^*)=0$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"找出陣列中的極小點"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"給定一個陣列 $A[0..n-1]$，這個陣列的所有數字都不相同。假設這個陣列最左邊和最右邊的邊界都是無窮大，也就是 $A[-1]=A[n]=\\infty$。請找出任何一個"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"極小點"}]},{"type":"text","value":"的索引 $i$：滿足 $A[i-1] > A[i] < A[i+1]$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"找出任一個括弧組"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"給定一個僅包含小括弧 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"("}]},{"type":"text","value":" 或 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":")"}]},{"type":"text","value":" 的字串 $S$，已知字串左界是個左括弧 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"("}]},{"type":"text","value":"、右界是個右括弧 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":")"}]},{"type":"text","value":"。請設計一個演算法有效率地找出一個連續的一對括弧 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"()"}]},{"type":"text","value":" 子字串。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"參考資料"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"http://kc.kshs.kh.edu.tw/93kc/projectual/math9103/chp4-5/4-5-8.htm"},"children":[{"type":"text","value":"勘根定理 The location of roots theorem"}]}]},{"type":"text","value":"\n"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"枚舉法 1：試誤原則 Trial and Error","category":"algo","path":"/algo/enumeration-1","date":"2018-12-05","_PARENT":"9a9d9756-b822-5c33-9312-16d671c507ca","description":null,"link":null,"code":null,"difficulty":null,"oj":null},"htmlAst":{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"今天來聊聊四種解題方法之一：枚舉法。每一道題目都有一個解，當我們沒辦法立刻說出答案的時候，最原始的方法就是利用試誤(trial-error)的原則，考慮所有可能的答案，並一個一個判斷是否它滿足我們的需求。有時候這方法挺好用的。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"資訊與數學最大的不同是，我們可以利用有限的時間，讓電腦幫我們逐一檢驗可能的答案，進而省略一些繁雜的數學證明或更細緻的檢驗步驟。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"換句話說，如果我們能用"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"簡單的數學證明"}]},{"type":"text","value":"保證答案會出現在我們提出的許多數值之中，那麼就能夠證明演算法的正確性了。"}]},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"include-problem","properties":{"titlePrefix":"例題 1：","path":"/problem/isprime"},"children":[{"type":"text","value":"\n"}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"顯然，要「否定」$n$ 是否為質數這個敘述，只需要找出一個「反例」。而顯然這個反例 $x$ 會介於 $[2, n-1]$ 之間。逐一檢查 $2, 3, \\ldots, n-1$ 就可以知道答案是 Yes 還是 No 了。這個方法需要 $O(n)$ 次模運算。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"透過簡單觀察，我們發現：若 $n$ 是合數，可以表示成 $n=a\\times b$。那麼此時有 $\\min(a, b)\\le \\sqrt{n}$。也就是說，若存在反例，最小的反例一定會出現在 $[2, \\sqrt{n}]$ 之間。於是，我們就得到一個 $O(\\sqrt{n})$ 時間的演算法了。"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"bool isprime(int n) {\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0)\n            return false;\n    }\n    return true;\n}\n"}]}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"結論"}]},{"type":"element","tagName":"theorem","properties":{"c":"is-success"},"children":[{"type":"text","value":"\n本題透過枚舉「至少一個」 $n$ 可能的真因數，進而達到解題的目的。\n"}]},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"include-problem","properties":{"titlePrefix":"例題 2：","path":"/problem/leetcode/326"},"children":[]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"注意到 3 的次方其實數量不多，所以我們可以直接嘗試所有可能的次方數值，並且與 $x$ 進行比對。"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"bool isPowerOfThree(int n) {\n    for (long long i = 1; i <= n; i *= 3)\n        if (n == i)\n            return true;\n    return false;\n}\n"}]}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"結論"}]},{"type":"element","tagName":"theorem","properties":{"c":"is-success"},"children":[{"type":"text","value":"\n本題透過枚舉所有 3 的次方值，達到解題目的。\n"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"延伸思考"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這題其實不使用諸如 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"log()"}]},{"type":"text","value":" 函式的浮點數計算也可以做得到 $O(1)$ 時間唷，你能想得到嗎？"}]},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"include-problem","properties":{"titlePrefix":"例題 3：","path":"/problem/cf/233/B"},"children":[{"type":"text","value":"\n"}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"對於一個一元二次方程我們可以利用已知的公式 $x=\\frac{-b\\pm\\sqrt{b^2-4ac}}{2a}$ 來求出方程的根，但是 $s(x)$ 是一個與 $x$ 有關的函數，所以無法直接從公式下手。枚舉 $x$ 的範圍可以粗估是 $1\\le x\\le \\sqrt{n} \\approx 10^9$，但一個一個檢查會花太多時間。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"注意到 $s(x)$ 是 $x$ 的各位數字和，這個值的範圍相較於 $n$ 小了不少。可以估計的是當 $x\\le 10^{9}$ 時，有 $1\\le s(x)\\le 81$。因此若我們先"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"逐一枚舉 $s(x)$ 的值"}]},{"type":"text","value":"，就可以把題目當成一般的一元二次方程來解了！找到解以後，再驗證其各位數字和是否就是我們枚舉的值，就可以了。"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"#include <iostream>\n#include <cmath>\nusing namespace std;\n\n// 計算各位數字和。\nint s(long long x) {\n    int t=0;\n    while(x>0) { t+=x%10; x/=10; }\n    return t;\n}\n\n// 對於枚舉的 s(x) 值 t，找出合法的解，由於解會是一正一負，我們只回傳正的那個。\nlong long getsol(int t, long long n) {\n    long long r = t*t+n*4, v = 0;\n    v = sqrt(r);\n    while(v*v<r) v++; while(v*v>r) v--;\n    if(v*v!=r) return -1;\n    v-=t; if(v%2 || v<0) return -1;\n    v/=2;\n    return v;\n}\n\nint main(void) {\n    long long n, x, t, ans=-1;\n    cin >> n;\n    for (t = 1; t <= 81; t++) {\n        x = getsol(t, n);\n        if(x<0) continue;\n        if(s(x)==t && ( ans==-1 || ans > x)) ans = x;\n    }\n    cout << ans << endl;\n    return 0;\n}\n"}]}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"結論"}]},{"type":"element","tagName":"theorem","properties":{"c":"is-success"},"children":[{"type":"text","value":"\n本題透過觀察並枚舉 $s(x)$ 的值，來縮小可能的答案範圍。\n"}]},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"練習題"}]},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"include-problem","properties":{"path":"/problem/ural/1854","inline":""},"children":[]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"include-problem","properties":{"path":"/problem/cf/911/C","inline":""},"children":[]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"include-problem","properties":{"path":"/problem/cf/241/C","inline":""},"children":[]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"include-problem","properties":{"path":"/problem/icpc/ecna2018/B","inline":""},"children":[]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]}]}}},{"node":{"frontmatter":{"title":"枚舉法 2：利用相依性 Dependency [草稿]","category":"algo","path":"/algo/enumeration-2","date":"2018-12-16","_PARENT":"55979fb4-d07b-5c3d-b406-1411f1dfde6b","description":null,"link":null,"code":null,"difficulty":null,"oj":null},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"在考慮枚舉所有可行解的同時，若變數與變數之間有高度的相關性，那麼枚舉的順序就會變得相當重要。若我們用了錯誤的順序進行枚舉，很可能會浪費許多時間考慮根本不符合題目規定的解。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"include-problem","properties":{"titlePrefix":"例題 1：","path":"/problem/cf/161/E"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"因為 $p_i\\le 99999$ 因此密碼鎖的大小至多只有 $5\\times 5$。再加上對稱的關係，因此彼此不相關的格子只有對角線右上方的這 15 格："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"/CF161E-f6172dc8bf334e699603ab7606576a42.png"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"但是，因為第一排已經固定了 $p_i$，所以剩下下面的 10 格。注意到，如果我們枚舉了標記數字 1 到 6 的地方，則每一排恰好空下一個對角線上的格子，而且彼此不相關。我們只要解決：有多少質數滿足 $\\overline{aXbcd}$ 的形式，其中 $a,b,c,d$ 已知。而這一步可以預處理後 $O(1)$ 查詢。因此利用枚舉法的計算量約在 $10^6$，相當合理。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"// by tmt514\n#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// cnt[第k個位數被丟掉了][其他數字是多少] = 有幾個質數。\nint cnt[5][100000];\n\nvoid pre_compute() {\n  // 先用篩法求質數。\n  vector<int> sieved(99999, 0);\n  for (int i = 2; i*i <= 99999; i++)\n    for (int j = i*i; j <= 99999; j += i)\n      sieved[j] = 1;\n  // 對於找到的每一個質數，我們考慮中間每一個位數被挖空以後，剩下的數字，把他加進去。\n  for (int p = 2; p <= 99999; p++)\n    if (sieved[p] == 0)\n      for (int ten = 1, k = 0; ten <= 10000; ten *= 10, k++)\n        cnt[k][ p/(ten*10)*ten + p%ten ]++;\n}\n\nint ans, n;\nint a[6][6];\nint get_count(int x) {\n  int prefix = 0;\n  for (int i = 0; i < n; i++)\n    if (i != x)\n      prefix = prefix*10 + a[x][i];\n  return cnt[n-1-x][prefix];\n}\nvoid dfs(int x, int y, int total) {\n  if (x == n) {\n    ans += total;\n    return;\n  }\n  if (y == n) {\n    dfs(x+1, 0, total * get_count(x));\n    return;\n  }\n\n  if (x >= y) {\n    a[x][y] = a[y][x];\n    dfs(x, y+1, total);\n  } else {\n    for (int i = 0; i <= 9; i++) {\n      a[x][y] = i;\n      dfs(x, y+1, total);\n    }\n  }\n}\n\nvoid solve() {\n  string s;\n  cin >> s;\n  n = s.size();\n  for (int i = 0; i < n; i++) a[0][i] = (s[i]-'0');\n  ans = 0;\n  dfs(1, 0, 1);\n  cout << ans << endl;\n}\n\nint main() {\n  int T;\n  pre_compute();\n  cin >> T;\n  while (T--) solve();\n  return 0;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"結論"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"先枚舉一部分的數值，並試圖留下一些完全不互相影響的待枚舉部分。如此一來，每一個獨立的部分可以各自用預處理的技巧快速找出答案。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"include-problem","properties":{"titlePrefix":"例題 2：","path":"/problem/cf/217/B"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"在第一個例題中，我們試圖降低未枚舉的格子之間的依賴關係。而在第二個例題中，我們試圖找出下一個要枚舉的操作與目前已枚舉部分的關聯，是為增加依賴關係。兩種方法的目的都是為了保證枚舉所花的時間大致與枚舉出的結果總數成正比，減少浪費的時間。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"練習題"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"最小費用流的最短路徑增廣法 [草稿]","category":"algo","path":"/algo/min-cost-max-flow-successive-shortest-path","date":"2018-11-22","_PARENT":"f87bfdb6-508e-52a6-b79f-a0ef73b2a3c3","description":null,"link":null,"code":null,"difficulty":null,"oj":null},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"讓我們首先"},{"type":"element","tagName":"a","properties":{"href":"/algo/min-cost-max-flow"},"children":[{"type":"text","value":"回顧"}]},{"type":"text","value":"一下最小費用循環的線性規劃主模型（Primal Problem）、以及其對偶模型（Dual Problem）。令 $f(u, v)$ 為線性規劃模型的變數、$y(u, v)$ 以及 $d(v)$ 為其對偶模型的變數名。我們定義以下三種條件："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"P 條件：$f$ 滿足線性規劃模型的條件，即 $f$ 是一個合法的網路流。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"D 條件：$y, d$ 滿足對偶模型的條件，即 $y(u, v)-d(u)+d(v) \\le cost(u, v)$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"CS 條件：$f, y, d$ 滿足"},{"type":"element","tagName":"a","properties":{"href":"http://terms.naer.edu.tw/detail/559045/"},"children":[{"type":"text","value":"互補差餘"}]},{"type":"text","value":"條件，即"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n$$\n\\begin{cases}\nf(u, v) > 0 & \\implies y(u, v) = d(u) + cost(u, v) - d(v)\\\\\nf(u, v) < cap(u, v) & \\implies y(u, v) = 0\n\\end{cases}\n$$\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"由線性規劃的各種性質我們可以知道，只要 $f, y, d$ 這三組變數同時滿足 P條件、D條件以及 CS條件的話，保證 $f, y, d$ 分別是主模型和對偶模型的最佳解。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"theorem","properties":{"title":"最小費用流的最佳條件定理"},"children":[{"type":"text","value":"設 $f$ 是一個圖 $G$ 上面的網路流。若存在剩餘網路 $G_f$ 上面的距離函數 $d^*$ （即，滿足 $\\forall (u, v)\\in G_f, \\ d^*(u) + cost(u, v) \\ge d^*(v)$），那麼 $f$ 是主模型的最佳解。\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"證明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我們只需要證明「存在滿足條件的 $d^*$ 函數」等價於「存在滿足 D 條件和 CS 條件的 $y, d$」即可。"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"最小費用流 Min-Cost Max-Flow","category":"algo","path":"/algo/min-cost-max-flow","date":"2018-11-16","_PARENT":"efd6f89a-55c8-547e-9aae-3885ac0ebc91","description":null,"link":null,"code":null,"difficulty":null,"oj":null},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這篇文章是線性規劃章節的延伸，但目前還沒有寫線性規劃相關文章。還請大家先行理解"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"線性規劃"}]},{"type":"text","value":"與"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"對偶性質"}]},{"type":"text","value":"XD"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"最小費用流 Min-Cost Max-Flow"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{"className":["message","is-info"]},"children":[{"type":"element","tagName":"div","properties":{"className":["message-body"]},"children":[{"type":"text","value":"\n給定一個圖 $G=(V, E, cap: E\\to \\mathbb{R}_{\\ge 0}, cost: E\\to \\mathbb{R})$，每一條邊都有一個流量上限 $cap$ 和單位流量花費 $cost$。試問，從 $s$ 到 $t$ 的所有最大流之中，最小的花費為何？\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這個問題由於有 $s$ 和 $t$ 兩個特殊點，實際處理起來可能稍微麻煩些，所以我們先把它轉化成最小費用循環問題（Min-Cost Circulation）。轉化方法很簡單，其實只是加一條額外的邊 $t\\to s$，容量為無窮大、單位流費用為一個負很大的數字 $-\\mathit{big}$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"最小費用循環 Min-Cost Circulation"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{"className":["message","is-info"]},"children":[{"type":"element","tagName":"div","properties":{"className":["message-body"]},"children":[{"type":"text","value":"\n給定一個圖 $G=(V, E, cap: E\\to \\mathbb{R}_{\\ge 0}, cost: E\\to \\mathbb{R})$，每一條邊都有一個流量上限 $cap$ 和單位流量花費 $cost$。找一個 Circulation（沒有起點和終點的網路流） 使得總花費最小。\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果所有的花費都是正的，顯然一個空的流（總花費是 0）是最佳解。如果我們把這個問題的條件寫成線性規劃的形式，令 $f(u, v)$ 表示該條邊上面的流量，那麼它會長得像這樣："}]},{"type":"text","value":"\n$$\n\\begin{align*}\n\\text{minimize}\\ \\ & \\sum f(u, v) \\cdot cost(u, v)\\\\\n\\text{subject to}\\ \\ & {\\color{green}{\\forall (u, v),\\ \\ f(u, v) \\le cap(u, v)}} & {\\color{green}{\\text{ (容量限制)}}}\\\\\n& {\\color{brown}{\\forall v\\in V, \\ \\ \\sum_u f(u, v) - \\sum_u f(v, u) = 0}} & {\\color{brown}{\\text{ (流量守恆)}}}\\\\\n\\text{variables}\\ \\ & f(u, v) \\ge 0\n\\end{align*}\\\\\n$$\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果我們試圖找出他的對偶問題，那麼每一個條件會變成對偶問題的變數、而每一個變數也會對應到對偶問題的一個條件：對於每一個容量限制，我們用 $y(u, v)$ 作為容量限制條件的對應變數、令 $d(v)$ 作為流量守恆條件的對應變數。"}]},{"type":"text","value":"\n$$\n\\begin{align*}\n\\text{maximize}\\ \\ & \\sum {\\color{green}{y(u, v)}} \\cdot cap(u, v)\\\\\n\\text{subject to}\\ \\ & \\forall (u, v), \\ \\ {\\color{green}{y(u, v)}} - {\\color{brown}{d(u)}} + {\\color{brown}{d(v)}} \\le cost(u, v)\\\\\n\\text{variables}\\ \\ & {\\color{green}{y(u, v)}} \\le 0\n\\end{align*}\\\\\n$$\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"由於 ${\\color{green}{y(u, v)}}$ 值永遠非正的，而每一個值又只會出現在恰好一個對偶條件裡面，外加上 $cap(u, v) \\ge 0$。我們可以知道，當 ${\\color{brown}{d(v)}}$ 的所有值固定以後，永遠可以找到一組 ${\\color{green}{y(u, v)}}$ 滿足對偶條件：只要令"}]},{"type":"text","value":"\n$$\n{\\color{green}{y(u, v)}} = \\min\\{0, {\\color{brown}{d(u)}} + cost(u, v) - {\\color{brown}{d(v)}}\\}\n$$\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"就可以了。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"正確地寫下最小費用循環的線性規劃模型以後，我們就可以利用線性規劃的最佳解性質，幫助我們判斷找到的網路流是不是最佳解。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"最佳解的性質"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"線性規劃的對偶觀念中，最重要的三件事情「弱對偶性」、「強對偶性」以及「"},{"type":"element","tagName":"a","properties":{"href":"http://terms.naer.edu.tw/detail/559045/"},"children":[{"type":"text","value":"互補差餘"}]},{"type":"text","value":"」（這詞﹍）。假設我們今天已經找到了圖 $G$ 上面的網路流 $f$，我們要怎麼檢驗或確認這個 $f$ 是最佳解呢？"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{"className":["message","is-warning"]},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{"className":["message-header"]},"children":[{"type":"text","value":"\n弱對偶性（Weak Duality）\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{"className":["message-body"]},"children":[{"type":"text","value":"\n若 $f$ 是最小費用流線性規劃的一個可行解，且 $y, d$ 是滿足對偶條件的對偶問題可行解。那麼必定有\n$$\n\\sum f(u, v)\\cdot cost(u, v) \\ge \\sum y(u, v)\\cdot cap(u, v)。\n$$\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"弱對偶性（Weak Duality）告訴我們，如果存在一組對偶可行解 $y(u, v)$、$d(v)$ 滿足 $\\sum f(u, v)\\cdot cost(u, v) = \\sum y(u, v)\\cdot cap(u, v)$，那麼 $f, y, d$ 同時都是最佳解。如果我們的演算法可以正確地輸出 $f, y, d$，那麼從這個輸出就可以得知正確性。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"最小費用流的演算法"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"基於以上論述，綜觀歷來的最小費用流解法們，可以大致分成兩個門派："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"消圈演算法（Cycle-Cancellation Algorithms）"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"主要的概念是在每一次迭代的過程中，永遠保證 $f$ 是一個可行解（feasible solution，也就是一個合法的網路流），在對偶空間中試圖搜尋滿足條件的 $d$ 值。如果找不到滿足條件的 $d$ 值，代表剩餘網路 $G_f$ 上不存在距離函數（有負圈！），也因為有負圈，我們可以在這個負圈上推一個流，讓其中一條邊流滿。這個動作可以讓負圈消失、也因為找到這個負圈，推流後可以讓整體費用下降。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"最短路徑增廣法（Successive-Shortest-Path Algorithms）"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"主要的概念是在每一次迭代的過程中，永遠保證 $d$ 是一組滿足對偶條件的距離函數，並且我們維護一個假想流 $f$（pseudo flow：只滿足"},{"type":"element","tagName":"span","properties":{"style":"color:green"},"children":[{"type":"text","value":"容量限制"}]},{"type":"text","value":"但可能無法"},{"type":"element","tagName":"span","properties":{"style":"color:brown"},"children":[{"type":"text","value":"流量守恆"}]},{"type":"text","value":"）。然後試圖更新這個假想流，一旦更新後滿足了流量守恆，我們就得到解了（因為隨時保證 $d$ 以及從 $d$ 推導出的 $y$ 永遠是合法的對偶問題可行解）。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我們會在未來的文章介紹這兩種演算法的細節與簡單版的實作。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"習題"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"我們用加了一條邊（$cap=\\infty, cost=-big$）的方法把「Min-Cost Max-Flow」轉化成「Min-Cost Circulation」。如果我們今天不要求「最大流」，只要找一個流，讓總花費最小，應該要如何進行轉化呢？"}]},{"type":"text","value":"\n"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"A+B Problem","category":"cp","path":"/cp/a-plus-b","date":"2018-11-14","_PARENT":"82b59ce0-6f12-5e4f-8918-3c55f9d738e6","description":"給定兩個整數 $A$ 以及 $B$，請輸出 $A+B$ 之值。\n","link":"https://oj.icpc.tw/problem/1","code":null,"difficulty":null,"oj":null},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"題目敘述"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ連結"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://oj.icpc.tw/problem/1"},"children":[{"type":"text","value":"競程日記 Problem 1. A+B Problem"}]}]},{"type":"text","value":"\n"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"強指數時間假說 Strong Exponential Time Hypothesis","category":"algo complexity","path":"/algo/strong-exponential-time-hypothesis","date":"2018-12-04","_PARENT":"3c12ca69-a148-5b10-96be-f391c6f9781f","description":null,"link":null,"code":null,"difficulty":null,"oj":null},"htmlAst":{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"關於 P vs NP 這個計算機學界最重要的問題之一，至今仍是懸而未解。1990年代，大量 NP-Complete 的證明興起，也讓研究計算理論領域的人們對於 NP-完備的概念有著比較深刻的理解。對於一個問題，究竟是多項式時間可解、或是它比任何一個 NP-Complete 的問題還要難，往往也有跡可循。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"許多演算法的分支：近似演算法（Approximation Algorithms）、指數時間演算法（Exponential Time Algorithms）等，利用搜索與剪枝、貪婪法、模擬退火等各種技巧，無所不用其極，都是因應傳統演算法所需要耗費的時間或空間嚴重不足而產生的。而 NP-Complete 是一個很好的 \"hint\"：在這個大多數的人們相信著 P $\\neq$ NP 的世界裡，要找出又快又最好的解往往是不可能的事情。一旦我們能夠證明一個問題是 NP-Hard 的，那麼在現實生活中，如果要有效率的解決這個問題，恐怕只能仰賴搜索或近似解了。"}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"$k$-CNF-SAT"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"先跟大家介紹一個 NP-Complete 當中的指標性問題："}]},{"type":"element","tagName":"theorem","properties":{"title":"$k$-CNF-SAT 問題","c":"is-info"},"children":[{"type":"text","value":"\n**輸入**：給定 $n$ 個變數 $x_1, x_2, \\ldots, x_n$ 以及一個 k-CNF $\\Phi$。其中 $\\Phi = C_1\\land C_2\\land \\cdots \\land C_m$，$m=O(n)$。每一個 clause 可以被許多 literals 描述 $C_i = (\\ell_{i1}\\lor \\ell_{i2}\\lor \\cdots \\lor \\ell_{ik})$，其中每一個 literal 就是任何一個變數 $x$ 或其 negation $\\lnot x$。\n  \n**問題**：是否存在一個合法的賦值方式，使得 $\\Phi$ 為真？\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"目前世界上最快的精確演算法（Exact Algorithm），在最壞情形下得跑 $2^{(1-o(1/k))n}$ 時間。也就是說，當 $k$ 真的超大的時候，這些演算法在最壞情形下都得花到扎扎實實 $2^n$ 的時間。於是乎，大家逐漸提出了以下的想法："}]},{"type":"element","tagName":"theorem","properties":{"title":"強指數時間假說 Strong Exponential Time Hypothesis (SETH)"},"children":[{"type":"text","value":"\n對於任意的常數 $\\epsilon > 0$，任何精確演算法皆無法在 $2^{(1-\\epsilon)n}$ 時間內同時對任意 $k$ 解決 $k$-CNF-SAT 問題。\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這個想法看起來很直覺，但是目前也還沒有人能夠真的證明或否定它。有趣的事情是，這個假說提供了厲害的基礎，如果這個假說是對的，那麼有很多演算法就會變成了「理論上最優」的演算法了！"}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"證明 NP-完備性的一貫方法"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果要證明一個題目 $X$ 是 NP-完備（NP-Complete）的，那麼我們需要從一個 NP-完備問題 $Y$ 出發，然後試圖將它的輸入在多項式時間內轉化成 $X$。然後斷定結論說「如果我們能在多項式時間內解決 $X$，那麼我們就可以在多項式時間內解決 $Y$。但是因為 $Y$ 是 NP-完備的，可以在多項式時間內解決 $Y$ 就代表可以在多項式時間內解決所有 NP 裡面的問題，於是 NP $=$ P。」"}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"P 的細分"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"很久很久以前大家就知道洋蔥定理 "},{"type":"element","tagName":"a","properties":{"href":"https://en.wikipedia.org/wiki/Time_hierarchy_theorem"},"children":[{"type":"text","value":"Time Hierarchy Theorem"}]},{"type":"text","value":" 了（我一直很喜歡隨機客老師稱呼這個定理的說法）。簡而言之，洋蔥定理描述的事情是：在所有 P 裡面的問題，不存在常數 $c$ 使得所有的問題都能在 $n^c$ 的時間被解掉。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"但這些定理所描述的一些 hardness problems 或反例與現實世界中的問題相距甚遠。2005 年由 Ryan Williams 提出了以下的「正交向量問題」，建立了指數時間演算法與多項式時間演算法之間的關聯。有趣的是，這個正交向量問題能夠轉化(reduce)成更多大家熟知的題目，包含最長共同部分子序列(LCS)等問題。也就是說，這一連串的轉化得到以下結論：如果存在更有效率的某某多項式演算法，就能夠推翻強指數時間假說。"}]},{"type":"comment","value":"\n2001 年的 Impagliazzo, Paturi & Zane 提出了重要的引理。然後在 \n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我們先來看看正交向量問題吧："}]},{"type":"element","tagName":"theorem","properties":{"title":"正交向量問題 Orthogonal Vector Problem (OV)","c":"is-info"},"children":[{"type":"text","value":"\n**輸入**: 給定 $d$ 維布林空間中的兩個向量集合 $A, B\\subset \\{0, 1\\}^d$，而集合大小 $|A|=|B|=N$。我們不妨假設 $d=\\Theta(\\log N)$。\n  \n**問題**: 是否存在 $a\\in A, b\\in B$ 使得 $\\langle a, b\\rangle = 0$？\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"看起來樸實無華的問題，如果要跟時下最夯的 Document Similarity 扯上邊好像也是可以齁（我就不多言了。）重點是，我們可以把 CNF-SAT 問題轉化成 Orthogonal Vector 問題，進而得到以下定理："}]},{"type":"element","tagName":"theorem","properties":{"title":"定理：$\\textsf{CNF-SAT}\\le_p \\textsf{OV}$"},"children":[{"type":"text","value":"\n若存在一個常數 $\\epsilon>0$ 以及一個演算法能在 $N^{2-\\epsilon}$ 時間內解決正交向量問題，那麼就存在一個常數 $\\epsilon' > 0$，以及一個演算法能在 $2^{(1-\\epsilon')n}$ 時間內解出 CNF-SAT 問題。\n"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"證明"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"不妨假設在 CNF-SAT 問題裡面的 $n$ 是偶數。我們把變數分成兩群：\n$S_1=\\set{x_1, x_2, \\ldots, x_{n/2}}$ 以及 $S_2 = \\set{x_{n/2+1}, \\ldots, x_{n-1}, x_n}$。枚舉這兩群變數所有可能的賦值情形，分別有 $2^{n/2}$ 種。（這個概念有點像是拆兩半的枚舉。）"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"讓我們來考慮 $S_1$：對於第 $i$ 種賦值情形，我們可以拿它來對照所有的 $m$ 個 clause，然後用這個資訊構造出一個長度為 $m$ 的 0-1 字串 $a_1a_2\\cdots a_m\\in\\set{0,1}^m$：考慮第 $j$ 個子句 $C_j$，如果目前對於 $x_1, \\ldots, x_{n/2}$ 的賦值能保證 $C_j$ 為真，我們就令 $a_j=0$，否則令 $a_j=1$。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"同理而言，我們也能夠針對後半段 $S_2$ 所有可能的變數賦值，構造出集合 $B$：若 $C_j$ 能被後半段的賦值給滿足，那麼就讓 $b_j=0$，否則令 $b_j=1$。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"行文至此，我們可以想像一下，如果我們拿構造出來的 $a_1a_2\\cdots a_m$ 與 $b_1b_2\\cdots b_m$ 計算其內積，得到的值代表什麼意思？如果內積的值為 $0$，則代表對於所有 $j$，要嘛 $a_j=0$ 要嘛 $b_j=0$，這代表我們找出來的 $S_1$ 賦值與 $S_2$ 賦值剛好可以滿足所有的子句！也就是說存在一個 $\\Phi=\\mathsf{true}$ 的一個解，若且唯若存在一組 $a\\in A, b\\in B$ 使得 $\\langle a, b\\rangle = 0$。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"現在讓我們來檢視集合大小，也就是 $n, m, N, d$ 之間的關係。集合 $A$ 與 $B$ 分別對應到 $S_1$ 與 $S_2$ 的賦值方式，所以 $N=|A|=|B|=2^{n/2}$。每一個構造出來的字串長度為 $m=O(n)$，因此 $d=m=n=\\Theta(\\log N)$ 滿足題目要求。所以囉，如果有一個 $N^{2-\\epsilon}$ 時間複雜度的方法可以解 OV，那麼就有一個 $\\left(2^{n/2}\\right)^{2-\\epsilon} = 2^{(1-\\epsilon/2)n}$ 時間複雜度的方法可以解 CNF-SAT 問題，與強指數時間假說(SETH)矛盾。"}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"參考資料"}]},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://en.wikipedia.org/wiki/Exponential_time_hypothesis"},"children":[{"type":"text","value":"維基百科: Exponential Time Hypothesis"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://people.csail.mit.edu/rrw/2-csp-final.pdf"},"children":[{"type":"text","value":"Ryan Williams, A new algorithm for optimal constraint satisfaction and its implications, 2005."}]}]},{"type":"text","value":"\n"}]}]}}},{"node":{"frontmatter":{"title":"判斷質數","category":"prob","path":"/problem/isprime","date":null,"_PARENT":"360b3e2f-13a8-57d2-9e82-34cfa2090568","description":"若一個正整數恰有兩個正因數，那我們稱它是一個質數。給定正整數 $n$，請判斷 $n$ 是否為質數。\n","link":null,"code":"ISPRIME","difficulty":null,"oj":null},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"Orthogonal Vectors","category":"prob","path":"/problem/orthogonal-vectors","date":null,"_PARENT":"21cce14b-c4a8-5af8-b969-25eebb87b521","description":"Given two sets $A, B\\subseteq \\set{0, 1}^d$, where $|A|=|B|=N$ and $d=\\Theta(\\log N)$. Then there exists $a\\in A$ and $b\\in B$ so that $\\langle a, b\\rangle = 0$.\n","link":null,"code":"OV","difficulty":null,"oj":null},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"[CF161E] Polycarpus the Safecracker","category":"prob","path":"/problem/cf/161/E","date":null,"_PARENT":"9e7b2aaf-410e-5f8c-8a83-3b2a59a94ace","description":"Polycarpus 有 $t$ 個保險箱，每一個保險箱的密碼都是一個上面填了 $0$ 到 $9$ 之間數碼的方陣。由於 Polycarpus 實在太喜歡質數了，他把密碼設定成每一列都是質數。令他感到驚奇的是，每一組他設定的密碼都是對稱矩陣。事隔多年， Polycarpus 只記得每組密碼的第一列的數字 $p_i$，請你幫他算算，有多少種可能的密碼？除了第一列以外，其他列允許有前導 $0$ 的出現。第一列數字 $10\\le p_i\\le 99999$，總共有 $1\\le t\\le 30$ 組詢問。 \n","link":"https://codeforces.com/problemset/problem/161/E","code":"CF161E","difficulty":null,"oj":"codeforces"},"htmlAst":{"type":"root","children":[],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"[CF233B] Non-square Equation","category":"prob","path":"/problem/cf/233/B","date":null,"_PARENT":"60a88f0e-01ab-54aa-a487-aa67d8d005b7","description":"對於正整數 $x$，我們定義 $s(x)$ 為其十進制表示法的各位數字和。現在給定 $n$ $(1\\le n\\le 10^{18})$，請你找出滿足下列方程 $$x^2+s(x)\\cdot x = n$$ 的最小正整數解 $x$ 或指出解不存在。\n","link":"https://codeforces.com/problemset/problem/233/B","code":"CF233B","difficulty":null,"oj":"codeforces"},"htmlAst":{"type":"root","children":[],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"[CF217B] Blackboard Fibonacci","category":"prob","path":"/problem/cf/217/B","date":null,"_PARENT":"986fc26d-251a-5587-a10c-a0fee14e0931","description":"費氏數列的定義為 $f_0=0, f_1=1, f_n=f_{n-2}+f_{n-1}$。Bajtek 發明了一種在黑板上計算費氏數列的方法：首先在黑板寫下數字 $0$，然後在它下面緊接著寫下數字 $1$。接著，每一次他進行下列其中之一的操作：\n\n* 操作 `T`：把上面的數字擦去，並換成兩個數字的總和。\n* 操作 `B`：把下面的數字擦去，並換成兩個數字的總和。\n\n如果一切順利，進行了 $n$ 次操作而且從 `T` 開始，將兩種操作交錯進行，那麼最後寫到黑板的數字就會是 $f_{n+1}$。\n\n問題是，Bajtek 在進行操作的時候，常常不小心重複了同一種操作許多次。例如，如果 $n=6$，原本應該要進行的操作順序是 `TBTBTB`，但如果 Bajtek 進行的操作是 `TTTBBT`，那麼會得到 $10$ 這個數字。我們定義「出錯的次數」為序列中該次操作與前一次操作相同的次數。即 `TT` 或 `BB` 出現的總次數。\n\n現在，已知 Bajtek 經過了恰好 $n$ 次操作後計算出了 $r$ 這個數字。請找出「出錯的次數」最少的操作序列，或者輸出無解。$(1\\le n, r\\le 10^6)$\n","link":"https://codeforces.com/problemset/problem/217/B","code":"CF217B","difficulty":null,"oj":"codeforces"},"htmlAst":{"type":"root","children":[],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"[CF233B] Non-square Equation","category":"prob","path":"/problem/cf/241/C","date":null,"_PARENT":"84e22adf-2ef9-5f8c-b91a-a2165911c298","description":"有一個長 $10^5$ 公分、高 $100$ 公分的木頭箱子，箱子下方與上方各有一些水平擺放的鏡子、以及箱子左右兩端分別有一個可以讓光線進入的小孔，分別在高度 $h_l$ 以及 $h_r$ 公分處。下面的圖表示了箱子的情形：\n\n![](https://codeforces.com/predownloaded/58/b3/58b3e544e19da6e84c3667e027ccef48dd955657.png)\n\n在遊戲中，你必須要從左方的小孔中發射一束雷射光，然後讓這束光從右方小孔鑽出。每一面鏡子都有一個分數 ，若射中該面鏡子，則得到對應之分數。為了增加遊戲的趣味性，規定**雷射光只能打到每一面鏡子至多一次**。請找出最高的可能得分。鏡子數 $0\\le n\\le 100$。保證輸入的鏡子位置彼此不會重疊。\n","link":"https://codeforces.com/problemset/problem/241/C","code":"CF241C","difficulty":null,"oj":"codeforces"},"htmlAst":{"type":"root","children":[],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"[CF911C] Three Garlands","category":"prob","path":"/problem/cf/911/C","date":null,"_PARENT":"b20e3ef4-86e1-515a-88e2-0762b43603ec","description":"Mishka 買了三個聖誕樹的裝飾燈品，第 $i$ 個燈從開啟的那一剎那每間隔 $k_i$ 秒就會亮燈一下 $(1\\le k_i\\le 1500)$。Mishka 想知道是否存在三個開啟燈泡的時間 $x_1, x_2, x_3$，使得三個燈都打開以後，每一秒鐘都至少有一個燈泡亮著？\n","link":"https://codeforces.com/problemset/problem/911/C","code":"CF911C","difficulty":null,"oj":"codeforces"},"htmlAst":{"type":"root","children":[],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"鏈結串列 Linked Lists","category":"guide","path":"/leetcode-guide/linked-lists","date":"2018-12-21","_PARENT":"4a72e81b-fc86-52f9-bf04-419a324c9c5a","description":null,"link":null,"code":null,"difficulty":null,"oj":null},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Linked list 是一種資料結構，它利用了指標，讓在記憶體內距離很遠的資料也可以連結起來。根據每一個節點可以連結到的其他節點，大致可以分成以下兩種類型："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Singly Linked List"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"display","properties":{"linkedList":"","data":"[\"value: 1\", \"value: 2\", \"value: 3\"]"},"children":[{"type":"text","value":"\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"typedef struct Node {\n    int value;\n    Node* next;\n};\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Doubly Linked List"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"display","properties":{"linkedList":"","double":"","data":"[\"node 1\", \"node 2\", \"node 3\", \"node 4\", \"node 5\"]"},"children":[{"type":"text","value":"\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"typedef struct Node {\n    Node* prev;\n    int value;\n    Node* next;\n};\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"每一個 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"struct"}]},{"type":"text","value":" 在記憶體中會是連續的一塊空間。一般來說，我們會額外儲存一個指標 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"head"}]},{"type":"text","value":" 指向這個鍊結串列的開頭（不然就沒辦法存取了）。進行大部分的操作都是從這個 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"head"}]},{"type":"text","value":" 開始。"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"[LC326] Power of Three","category":"prob","path":"/problem/leetcode/326","date":null,"_PARENT":"e74bc4dd-45a4-545e-8b25-d5461fafc9cc","description":"給定一個整數 $x$，若這個整數是 3 的次方則回傳 `true`，否則回傳 `false`。\n","link":"https://leetcode.com/problems/power-of-three/","code":"LC326","difficulty":null,"oj":"leetcode"},"htmlAst":{"type":"root","children":[],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"[TIOJ 1010] Prefix and Postfix","category":"my-problem","path":"/cp/tioj/1010","date":"2018-11-22","_PARENT":"9838c9ad-c2e8-5e05-b7f6-53ba22d75d58","description":"我們說字串 $A$ 是字串 $B$ 的Prefix（前綴字串），若且唯若字串 $B$ 的前 $len(A)$ 個字母與 $A$ 完全相同，其中 $len(A)$ 指的是字串 $A$ 的長度。例如： “Exam” 和 “Example”都是 “Example” 的 Prefix，但是 “Ample”和 “Exapple” 都不是 “Example” 的 Prefix。同樣的，當 $B$ 的後 $len(A)$ 個字母與 $A$ 完全相同的時候，我們稱 $A$ 是 $B$ 的 Suffix (後綴字串)。給定兩個字串 $P$, $Q$，請你找出最長的字串 $S$ 使得 $S$ 是 $P$ 的 Prefix，同時也是 $Q$ 的 Suffix。\n","link":"https://tioj.ck.tp.edu.tw/problems/1010","code":null,"difficulty":1,"oj":"TIOJ"},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"題目敘述"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"兩個字串 $P$, $Q$ 各佔一行，只包含小寫英文字母，長度皆不超過 1000 字元。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸出說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"輸出最長的字串 $S$ 的長度 $len(S)$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Sample Input"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"example\nexam\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Sample Output"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"4\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"出處"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"95建中資訊培訓模擬試題一（Prob 2）"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ連結"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://tioj.ck.tp.edu.tw/problems/1010"},"children":[{"type":"text","value":"TIOJ 1010 - Prefix and Postfix"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"題解"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"注意到輸入的字串長度不超過 1000 個字元，所以我們只要逐一枚舉所有第一個字串的 prefix，看看它是不是第二個字串的 suffix 就好了～"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"要取出子字串，可以利用 C++ 的 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"<string>"}]},{"type":"text","value":" 函式庫。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"/* by tmt514 */\n#include <algorithm>\n#include <string>\n#include <iostream>\nusing namespace std;\n\nint main() {\n    string P, Q;\n    cin >> P >> Q;\n    int ans = min(P.size(), Q.size());\n    while (ans > 0 && (P.substr(0, ans) != Q.substr(Q.size()-ans)))\n        --ans;\n    cout << ans << endl;\n    return 0;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"關於這題"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這題顯然是個字串匹配的問題，而且是 KMP 演算法的直接應用。但是根據輸入規模，找出能夠通過測試的最單純演算法，才是取得先機的關鍵。"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"[TIOJ 1011] Edit Distance In Numbers","category":"my-problem","path":"/cp/tioj/1011","date":"2018-11-23","_PARENT":"0d9a2cdc-4430-5ce8-8ffa-60d7ce91d55a","description":"對於字串來說，Edit Distance是一個著名的DP問題。現在我們把這個問題弄得簡單一點，例如：把字串換成數字。對於一個數字$A$，我們想要藉由某些操作換成數字$B$。而對於整數$K$的一個合法的操作包括以下三種情形：\n\n* 乘以 $2$ 加 $1$，即 $K=2K+1$\n* 乘以 $2$，即 $K=2K$\n* 除以 $2$，即 $K=\\lfloor K/2\\rfloor$\n\n給定整數 $A$ 和 $B$，請你求出最小的操作次數 $N$使得從 $A$ 開始操作 $N$ 次可以換成 $B$。\n","link":"https://tioj.ck.tp.edu.tw/problems/1011","code":null,"difficulty":1,"oj":"TIOJ"},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"題目敘述"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"包含兩個數字 $A, B$ ($0 \\leq A, B \\leq 2^{31}$)。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸出說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"請輸出最小操作次數 $N$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Sample Input"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"17\n15\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Sample Output"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"7\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"出處"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"95建中資訊培訓模擬試題一（Prob 3）"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ連結"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://tioj.ck.tp.edu.tw/problems/1011"},"children":[{"type":"text","value":"TIOJ 1011 - Edit Distance In Numbers"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"題解"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"把輸入的數字表示成二進位以後，所有的操作都會變成在當前的二進位字串後面加上一位數、或刪除一位數。考慮 $A$ 和 $B$ 的二進位值之後，他們的最長共同前綴（Longest Common Prefix）$S$，而最佳解就會是一路把 $A$ 除到變成 $S$，然後再一路加上末尾的位元變成 $B$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"要把數字轉換成二進位的字串、再找出他們的最長共同前綴是一件好像有點麻煩的事情（雖然也不是太麻煩）。我們可以把「加上末尾的位元變成 $B$」的步驟反過來，變成從 $B$ 開始逐一刪除末尾的 0。這樣可以得到一個單純的演算法，重複比較 $A$ 和 $B$ 誰比較大，比較大的數字除以 2，直到相同為止。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"/* by tmt514 */\n#include <iostream>\nusing namespace std;\n\nint main() {\n    int A, B, ans = 0;\n    cin >> A >> B;\n    while (A != B) {\n        (A > B? A : B) /= 2;\n        ++ans;\n    }\n    cout << ans << endl;\n    return 0;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"關於這題"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這題的概念是二進位思考，如果把輸入的數字用不同的表示方法（比方說二進位）表示出來，那麼看似麻煩的操作就會變得很直觀。"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"[TIOJ 1009] In No Time!","category":"my-problem","path":"/cp/tioj/1009","date":"2018-11-21","_PARENT":"39582c96-0d5c-518d-8d7f-b5a38f189009","description":"考試時間所剩不多，你能夠把握剩下時間完成所有題目嗎？ 給你現在時間以及考試終止時間，請你判斷還剩下多少時間可以做題目。\n","link":"https://tioj.ck.tp.edu.tw/problems/1009","code":null,"difficulty":1,"oj":"TIOJ"},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"題目敘述"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"輸入有兩行，第一行表示現在時間，第二行表示考試終止時間。時間的格式為 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"HH:MM:SS"}]},{"type":"text","value":" (時：分：秒)，終止時間永遠比現在時間晚，但兩者時間差不會超過一天(24小時)。(請注意：兩者的時間點不一定都在同一日。)"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸出說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"請輸出距離考試結束還有多久時間，以 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"HH:MM:SS"}]},{"type":"text","value":" 表示。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Sample Input"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"14:00:00\n10:00:00\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Sample Output"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"20:00:00\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"出處"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"95建中資訊培訓模擬試題一（Prob 1）"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ連結"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://tioj.ck.tp.edu.tw/problems/1009"},"children":[{"type":"text","value":"TIOJ 1009 - In No Time!"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"題解"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這題基本上就是考驗大家怎麼把輸入讀進來，如果是傳統的 C 語言的話，由於有格式化輸入 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"scanf"}]},{"type":"text","value":" 世界會變得比較輕鬆些。如果把所有時間都轉換成秒來計算的話，會比較簡單。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"/* by tmt514 */\n#include <cstdio>\n\nint read_input() {\n    // 讀取輸入並且轉換成秒數。\n    int h, m, s;\n    scanf(\"%d:%d:%d\", &h, &m, &s);\n    return (h*60+m)*60+s;\n}\n\nvoid output(int sec) {\n    printf(\"%02d:%02d:%02d\\n\", sec/3600, sec/60%60, sec%60);\n}\n\nint main() {\n    int A = read_input();\n    int B = read_input();\n    if (A >= B) {\n        // 隔天了。\n        B += 86400;\n    }\n    output(B-A);\n    return 0;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"後記"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這個時間序應該是高三上學期的時候，當時高二進了選訓營，學了很多很多東西。\n高三校內初選以後，在彭天健老師和林淑玲老師的協助下，參與了資訊校隊培訓的工作。\n剛好那個時候，北大的 OJ 有釋出版可以玩。我就下載了一套拿來架在自己家裡的主機裡面，並嘗試放了一些題目，邀請大家一起來寫。印象中當年校內預賽的題目是彭天健老師出的，在第一場練習賽之前就先放了預賽題目（TIOJ 1003~1008）讓大家練習。而這題 TIOJ 1009 應該就是正式放上的第一題了吧哈哈～"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"更早之前應該還有出過一套資訊社高二選幹部的演算法考試。那時候還沒有 OJ 可以用，克難地跟 ianchou 用 PHP 架了簡單的評分系統（從現在看起來應該到處都是漏洞哈哈）。可惜我現在一時之間找不到資料。以後有機會再補上當年那套題目吧～"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"[TIOJ 1012] Rails","category":"my-problem","path":"/cp/tioj/1012","date":"2018-11-25","_PARENT":"af6dddda-da3c-59a0-8740-3b9e6f2e1a95","description":"在一個叫「堆疊市」的城市中有一個著名的火車站。由於地形限制以及經費關係，火車站及唯一的鐵路的樣子如下圖：\n\n![](https://tioj.ck.tp.edu.tw/pimgs/1012_1.jpg)\n\n現在火車從A方向來，預定從B方向離開。火車共有N節車廂，並且各車廂依次以1到N來編號。你可以假設各車廂在進站之前可以單獨與其他車廂分離，也可以單獨離開車站到往B方向的鐵軌或是車站北方的「維修鐵路」上。維修鐵路是一小段至多只能容納M節車廂的鐵軌，可以從車站依照順序將車廂移至維修鐵路，或者將車廂從維修鐵路（如果有的話）駛進車站，但是在把車廂從A開進車站的時候，維修鐵路不能有任何車廂。你可以假設在任何時間火車站都可以容納所有的車廂。但是一旦一節車廂進站後，就不能再回到A方向的鐵軌上了，並且一旦離開車站往B方向後，也不能再回到車站。\n\n現在你的任務是寫一個程式，判斷火車能否以一特定的排列方式在B方向的鐵軌上。\n","link":"https://tioj.ck.tp.edu.tw/problems/1012","code":null,"difficulty":1,"oj":"TIOJ"},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"題目敘述"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"第一行有兩個正整數 $N, M$。($1\\le N\\le 1000, 0\\le M\\le 9$)"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"第二行有 $N$ 個正整數，為 $1, 2, \\ldots, N$ 的一個排列。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸出說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"若能在 B 鐵軌上排出特定排列，請輸出 yes，否則請輸出 no。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Sample Input"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"5 1\n3 2 5 1 4\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Sample Output"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"yes\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"出處"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"95建中資訊培訓模擬試題一（Prob 4）"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ連結"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://tioj.ck.tp.edu.tw/problems/1012"},"children":[{"type":"text","value":"TIOJ 1012 - Rails"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"題解"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這題有個決定性的觀察：基本上，當一節火車從 A 進入車站時，他所排列的位置必須在所有已經進入車站的車廂最上面。也就是說，無論哪些車廂已經被送到鐵軌 B 處，從上到下的順序永遠是遞減的（與進入車站的順序相反），剛好是一個堆疊的樣子。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"於是這讓我們能用基於貪婪法的模擬來解題：如果要駛出的車廂出現在目前堆疊頂端 $M+1$ 節車廂裡面，那我們就直接把他開走。如果想要的車廂還沒有進到車站，就不斷放車廂進來，直到該節車廂一進站立馬停下來。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"/* by tmt514 */\n#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n    int N, M, x, now = 0;\n    vector<int> station;\n    cin >> N >> M;\n    for (int i = 0; i < N; i++) {\n        cin >> x;\n        // 不斷把新的車廂放進來，直到目標車廂出現為止。\n        while (now < x) station.push_back(++now);\n        // 計算目標車廂的位置。\n        auto it = find(station.begin(), station.end(), x);\n        int dist = station.end() - it;\n\n        if (dist > M+1) {\n            // 距離過遠代表得放超過 M 個車廂到上面，做不到。\n            cout << \"no\" << endl;\n            return 0;\n        } else {\n            // 否則就模擬把這節車廂開走。\n            station.erase(it);\n        }\n    }\n    cout << \"yes\" << endl;\n    return 0;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"關於這題"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這一題的原始構想是來自於 "},{"type":"element","tagName":"a","properties":{"href":"https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=455"},"children":[{"type":"text","value":"[UVa 514] Rails"}]},{"type":"text","value":"，只不過加上了一條維修鐵路，所以變得有一點不太相同，但解法還是差不多。"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"[TIOJ 1014] 打地鼠","category":"my-problem","path":"/cp/tioj/1014","date":"2018-12-05","_PARENT":"2c5736c7-325e-57f3-a04e-fa4b44051a5b","description":"隨著時間的腳步前進，打地鼠遊戲也不斷的翻新，最新一代的打地鼠遊戲不只測試你的反應能力，同時也考驗著你的體力和智力。地鼠基地是一個長型的基座，基座上每隔一公尺就會有一個地鼠洞，由左至右編號為 $1,2,\\ldots,n$。玩家站在這個基地的最左邊，與第一個地鼠洞相距 $1$ 公尺；拿著一根鎚子，準備開始這個遊戲。編號為 $i$ 的地鼠洞每 $T_i$ 秒地鼠會出現一次。被打的地鼠不再出現，只要將所有地鼠打完，就結束遊戲，並且紀錄從開始到結束遊戲的秒數，越快越好。現在問題來了，負責製造這個地鼠基地的遊戲廠商想要知道結束遊戲所需的最少秒數，於是拜託你幫忙寫個程式來解決它。\n\n假定玩家們的體力很好，隨時以每秒 $1$ 公尺的速度移動，並且不受移動方向改變的影響，打地鼠所花的時間也可以忽略不計。\n","link":"https://tioj.ck.tp.edu.tw/problems/1014","code":null,"difficulty":3,"oj":"TIOJ"},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"題目敘述"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"第一行有一個數字 $n$，代表地鼠洞的數量 $(1\\le n\\le 16)$。第二行有 $n$ 個數字。所有數字皆不大於 $100,000,000$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸出說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"請輸出結束遊戲所需的最少秒數 $S$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Sample Input"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"3\n3 2 5\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Sample Output"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"5\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"出處"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"95建中資訊培訓模擬試題一（Prob 6）"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ連結"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://tioj.ck.tp.edu.tw/problems/1014"},"children":[{"type":"text","value":"TIOJ 1014 - 打地鼠"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"題解"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這個題目是動態規劃，我們定義狀態 $\\dp(S, i)$ 表示玩家已經打掉集合 $S\\subseteq [n]$ 的地鼠，而且目前玩家所在位置是 $i$ 所需的最少秒數。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"/* by tmt514 */\n#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nvector<string> forest = {\n  \"*****************\",\n  \"*...*.......**..*\",\n  \"**..*....*.*.*..*\",\n  \"*......*.**.**.**\",\n  \"*..**...**..**.**\",\n  \"**.....**..*.*..*\",\n  \"*....*..........*\",\n  \"*.....****.*...**\",\n  \"****.*.*........*\",\n  \"*****************\",\n};\n\nconst int dx[4] = {0, 1, 0, -1};\nconst int dy[4] = {1, 0, -1, 0};\nint onFire[10][17];\nint onEscape[10][17];\n\nvoid bfs(int mark[10][17], int hasFire[10][17], int sx, int sy, int T) {\n  queue<int> q;\n  // 如果一開始就著火了，就應該直接死掉。\n  if (hasFire && hasFire[sx][sy] <= T) return;\n  mark[sx][sy] = T;\n  q.push(sx);\n  q.push(sy);\n  while (!q.empty()) {\n    int x = q.front(); q.pop();\n    int y = q.front(); q.pop();\n    int t = mark[x][y];\n    // 依序考慮四個方向是否可通行，如果可通行的話加到佇列裡面。\n    for (int dir = 0; dir < 4; dir++) {\n      int nx = x + dx[dir];\n      int ny = y + dy[dir];\n      if (forest[nx][ny] == '.' && \n          mark[nx][ny] == 0 &&\n          (!hasFire || hasFire[nx][ny] == 0 || hasFire[nx][ny] > t+1)) {\n        mark[nx][ny] = t+1;\n        q.push(nx);\n        q.push(ny);\n      }\n    }\n  }\n}\n\nint main() {\n  int fx, fy, sx, sy, ex, ey, T;\n  cin >> fx >> fy >> T;\n  cin >> sx >> sy >> ex >> ey;\n  // 由於火勢不會燒到避難處，所以一開始要取巧把這格改掉。\n  forest[ex][ey] = 'E';\n  bfs(onFire, NULL, fx, fy, 1);\n  // 然後把它改回變成可以通行。\n  forest[ex][ey] = '.';\n  bfs(onEscape, onFire, sx, sy, T);\n  if (onEscape[ex][ey] > 0) {\n    cout << onEscape[ex][ey]-T << endl;\n  } else {\n    cout << \"Help!\" << endl;\n  }\n  return 0;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"關於這題"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"第一次嘗試出的位元壓縮 DP，相當地有趣呢。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"其他推薦題解"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://polarischiba.blogspot.com/2018/02/tioj-1014.html"},"children":[{"type":"text","value":"PolarisChiba 的 code 收藏區：[TIOJ] 1014打地鼠"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"http://snowyojworld.blogspot.com/2014/10/tioj-1014.html"},"children":[{"type":"text","value":"藍雪的Online Judge日誌：TIOJ 1014 . 打地鼠"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"http://colistar.blogspot.com/2009/10/tioj-1014.html"},"children":[{"type":"text","value":"A Coding E. Coli：TIOJ 1014 打地鼠"}]}]},{"type":"text","value":"\n"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"[URAL1854] Negotiations with Parthians","category":"prob","path":"/problem/ural/1854","date":null,"_PARENT":"2a91e8fd-4d01-5c41-8a51-1d86c9237447","description":"古希臘以及古羅馬人不喜歡偶數。現在 Andrian 有 $n$ $(1\\le n\\le 10^{18}-1)$ 隻羊(奇數隻)要獻給神明，為了公平，每一位神明都要得到數量相同的羊。為了更吉利，Andrian 決定將羊群獻給奇數位神明、並且這個數量也要有奇數個正因數。請問 Andrian 至多可以將羊獻給多少位神明呢？\n","link":"http://acm.timus.ru/problem.aspx?space=1&num=1854","code":"URAL1854","difficulty":null,"oj":"ural"},"htmlAst":{"type":"root","children":[],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"ICPC 2018 Asia Jakarta Regional","category":"cp","path":"/problem/icpc/asia_jakarta_2018","date":"2018-12-26","_PARENT":"defe522f-c0a5-5364-be70-eaeecc05e501","description":null,"link":null,"code":null,"difficulty":null,"oj":null},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"include-problem","properties":{"titlePrefix":"Problem A. ","path":"/problem/icpc/asia_jakarta_2018/A"},"children":[{"type":"text","value":"\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"include-problem","properties":{"titlePrefix":"Problem B. ","path":"/problem/icpc/asia_jakarta_2018/B"},"children":[{"type":"text","value":"\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"include-problem","properties":{"titlePrefix":"Problem C. ","path":"/problem/icpc/asia_jakarta_2018/C"},"children":[{"type":"text","value":"\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"include-problem","properties":{"titlePrefix":"Problem D. ","path":"/problem/icpc/asia_jakarta_2018/D"},"children":[{"type":"text","value":"\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"include-problem","properties":{"titlePrefix":"Problem E. ","path":"/problem/icpc/asia_jakarta_2018/E"},"children":[{"type":"text","value":"\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"include-problem","properties":{"titlePrefix":"Problem F. ","path":"/problem/icpc/asia_jakarta_2018/F"},"children":[{"type":"text","value":"\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"include-problem","properties":{"titlePrefix":"Problem G. ","path":"/problem/icpc/asia_jakarta_2018/G"},"children":[{"type":"text","value":"\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"include-problem","properties":{"titlePrefix":"Problem H. ","path":"/problem/icpc/asia_jakarta_2018/H"},"children":[{"type":"text","value":"\n"}]}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"[TIOJ 1013] Fire in the forest","category":"my-problem","path":"/cp/tioj/1013","date":"2018-12-01","_PARENT":"c77056bb-0038-57fc-81b5-f6a00f3fe273","description":"中秋節的時候有人在森林中烤肉，一不小心就釀成了火災，火勢非常猛烈，如果某個區域原本沒有著火，但是相鄰的區域著火了，那麼下一分鐘這個區域也會被火勢波及。你很不幸的身處於著火的森林中，不過好加在你隨身帶了筆記型電腦，而且你恰好有這個森林地圖的資料。由廣播得知，火勢於第 $1$ 分鐘發生於起火點 $F$，而現在已經是第 $T$ 分鐘了。你的位置在 $S$ 處，標記 $E$ 的位置代表安全的避難所，並且有直升機場可以搭乘直升機避難。地圖上標著 `*` 的地方代表不可通行的區域，`.` 則是代表可以通過的區域。時間緊迫！你得趕緊找安全的逃生路線！\n\n座標化的森林的地圖是一個長 $17$ 單位、寬 $10$ 單位的一片土地，詳細狀況如下：\n\n```\n*****************\n*...*.......**..*\n**..*....*.*.*..*\n*......*.**.**.**\n*..**...**..**.**\n**.....**..*.*..*\n*....*..........*\n*.....****.*...**\n****.*.*........*\n*****************\n```\n\n左上角的位置為 $(0,0)$，右下角的位置為 $(9,16)$。你每分鐘可以從一個區域移動至相鄰的區域(在這裡所有的相鄰都不包含對角線方向)。現在給定 $F,T$ 之值以及 $S,E$ 的位置，請你求出從 $S$ 到 $E$ 的最短時間。\n","link":"https://tioj.ck.tp.edu.tw/problems/1013","code":null,"difficulty":2,"oj":"TIOJ"},"htmlAst":{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"題目敘述"}]},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"第一行有兩個正整數 $FX$, $FY$，代表起火點F的座標。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"第二行有一個正整數 $T (1\\le T\\le 1000)$，代表已經歷時間。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"第三行有四個正整數 $SX$, $SY$, $EX$, $EY$，代表你所在的位置以及安全避難所的位置。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"你可以假設 $F,S,E$ 皆位於可通行處。且避難所不會著火，$F,S,E$ 互不重疊。"}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸出說明"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"若可以安全逃離，請輸出從 $S$ 到 $E$ 的最短時間。若你發現身陷火場，或者你根本無法到達避難所的時候，請輸出 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"Help!"}]},{"type":"text","value":"。"}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Sample Input"}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"1 1 \n3 \n4 1 3 3 \n"}]}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Sample Output"}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"9\n"}]}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"出處"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"95建中資訊培訓模擬試題一（Prob 5）"}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ連結"}]},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://tioj.ck.tp.edu.tw/problems/1013"},"children":[{"type":"text","value":"TIOJ 1013 - Fire in the forest"}]}]},{"type":"text","value":"\n"}]},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"題解"}]},{"type":"element","tagName":"algorithm","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"generator","properties":{},"children":[{"type":"element","tagName":"pre","properties":{},"children":[{"type":"text","value":"\nfunction*(input, ui) {\n    var forest = [\n        \"*****************\",\n        \"*...*.......**..*\",\n        \"**..*....*.*.*..*\",\n        \"*......*.**.**.**\",\n        \"*..**...**..**.**\",\n        \"**.....**..*.*..*\",\n        \"*....*..........*\",\n        \"*.....****.*...**\",\n        \"****.*.*........*\",\n        \"*****************\",\n    ];\n    forest = forest.map((e) => e.split(\"\"));\n    var fx = input.fx;\n    var fy = input.fy;\n    var T = input.T;\n    var sx = input.sx;\n    var sy = input.sy;\n    var ex = input.ex;\n    var ey = input.ey;\n    forest[fx][fy] = 'F';\n    forest[ex][ey] = 'E';\n    yield {forest: forest};\n    var t, i, j, f;\n    var d = [[0, 1], [1, 0], [0, -1], [-1, 0]];\n    for (t = 0; t < 24; t++) {\n        var newforest = JSON.parse(JSON.stringify(forest));\n        for (i = 0; i < forest.length; i++) {\n            for (j = 0; j < forest[0].length; j++) {\n                if (forest[i][j] === 'F') {\n                    for (f = 0; f < 4; f++) {\n                        var ni = i+d[f][0];\n                        var nj = j+d[f][1];\n                        if (forest[ni][nj] === '.') {\n                           newforest[ni][nj] = 'F';\n                           ui.setStyleOnce('forest', JSON.stringify([ni, nj]), {fill: 'yellow'}); \n                        }\n                    }\n                }\n            }\n        }\n        console.log(newforest);\n        forest = newforest;\n        yield {forest: forest};\n    }\n    return {forest: forest};\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"inputdata","properties":{"data":"{\"fx\":1, \"fy\":1, \"T\": 3,\n    \"sx\":4, \"sy\": 1, \"ex\": 3, \"ey\": 3}"},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"indirectdisplay","properties":{"grid":"","uihelperNodeStyle":"{stroke: \"none\"}","uihelperContentMap":"{\n        F:{fill: \"#FA8\", font: \"bold 24px Courier New\"},\n        \"*\":{fill: \"#555\"}\n    }","varname":"forest"},"children":[]},{"type":"text","value":"\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"可以利用 BFS 來模擬森林中的火勢蔓延的狀況。用 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"onFire"}]},{"type":"text","value":" 陣列記錄下每個格點第一次著火的時間。然後根據這個表格在 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"onEscape"}]},{"type":"text","value":" 陣列記錄下從 $S$ 出發不踩過火到該點的所有時間。在這裡分享一些有趣的實作小細節："}]},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"使用方向陣列："},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"dx[]"}]},{"type":"text","value":" 和 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"dy[]"}]},{"type":"text","value":" 分別儲存四個方向所需要的位移數值。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"在把座標放進 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"queue"}]},{"type":"text","value":" 的時候，依序放入 $x$ 和 $y$ 座標。取出時也按照這個順序取，就不需要寫麻煩的 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"pair<int, int>"}]},{"type":"text","value":" 了。"}]},{"type":"text","value":"\n"}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"/* by tmt514 */\n#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nvector<string> forest = {\n  \"*****************\",\n  \"*...*.......**..*\",\n  \"**..*....*.*.*..*\",\n  \"*......*.**.**.**\",\n  \"*..**...**..**.**\",\n  \"**.....**..*.*..*\",\n  \"*....*..........*\",\n  \"*.....****.*...**\",\n  \"****.*.*........*\",\n  \"*****************\",\n};\n\nconst int dx[4] = {0, 1, 0, -1};\nconst int dy[4] = {1, 0, -1, 0};\nint onFire[10][17];\nint onEscape[10][17];\n\nvoid bfs(int mark[10][17], int hasFire[10][17], int sx, int sy, int T) {\n  queue<int> q;\n  // 如果一開始就著火了，就應該直接死掉。\n  if (hasFire && hasFire[sx][sy] <= T) return;\n  mark[sx][sy] = T;\n  q.push(sx);\n  q.push(sy);\n  while (!q.empty()) {\n    int x = q.front(); q.pop();\n    int y = q.front(); q.pop();\n    int t = mark[x][y];\n    // 依序考慮四個方向是否可通行，如果可通行的話加到佇列裡面。\n    for (int dir = 0; dir < 4; dir++) {\n      int nx = x + dx[dir];\n      int ny = y + dy[dir];\n      if (forest[nx][ny] == '.' && \n          mark[nx][ny] == 0 &&\n          (!hasFire || hasFire[nx][ny] == 0 || hasFire[nx][ny] > t+1)) {\n        mark[nx][ny] = t+1;\n        q.push(nx);\n        q.push(ny);\n      }\n    }\n  }\n}\n\nint main() {\n  int fx, fy, sx, sy, ex, ey, T;\n  cin >> fx >> fy >> T;\n  cin >> sx >> sy >> ex >> ey;\n  // 由於火勢不會燒到避難處，所以一開始要取巧把這格改掉。\n  forest[ex][ey] = 'E';\n  bfs(onFire, NULL, fx, fy, 1);\n  // 然後把它改回變成可以通行。\n  forest[ex][ey] = '.';\n  bfs(onEscape, onFire, sx, sy, T);\n  if (onEscape[ex][ey] > 0) {\n    cout << onEscape[ex][ey]-T << endl;\n  } else {\n    cout << \"Help!\" << endl;\n  }\n  return 0;\n}\n"}]}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"關於這題"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"很久很久以前的北市賽（在還沒有使用 CMS 系統和使用隨身碟/磁碟輸入以前），評分的時候都是手動輸入測試資料的。當時出的模擬練習，就有點想要效法這樣的出題風格，所以森林的地圖就變成這樣 hard-code 的風格了。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"註：以前是紙本題目，所以連地圖也要在比賽進行時手刻上去 QAQ"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"其他推薦題解"}]},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://blog.ototot.tk/2017/01/tioj-1013-fire-in-forest.html"},"children":[{"type":"text","value":"oToToT 的 code 收藏區：TIOJ 1013"}]}]},{"type":"text","value":"\n"}]}]}}},{"node":{"frontmatter":{"title":"Edit Distance","category":"prob","path":"/problem/icpc/asia_jakarta_2018/A","date":"2019-01-01","_PARENT":"5c3e54f2-98d2-55ad-9371-2e966b37e556","description":"對於兩個給定的字串 $S$ 和 $T$，我們定義 $edit(S, T)$ 為從 $S$ 經過若干插入字元、修改字元、刪除字元等操作後得到 $T$ 所需要的最少步數。\n\nAyu 有一個二元字串 $S$（$1\\le |S|\\le 2000$），她想要找到另一個字串 $T_{max}$ 使得 $edit(S, T_{max})$ 最大。即對於所有與 $S$ 等長的 $T$，$edit(S, T_{max})\\ge edit(S, T)$。不過呢，為了讓事情變得簡單些，她希望你能夠幫她的忙，找到任何一個與 $S$ 長度相同的字串 $T$，只要 $edit(S, T) > |S|/2$ 即可。\n\n當然，你也可以選擇輸出 $T_{max}$，事實上我們可以證明 $edit(S, T_{max}) > |S|/2$。這也保證了對於任意輸入一定有解。\n","link":"https://codeforces.com/gym/102001/problem/A","code":"ICPC-JAKARTA-2018-A","difficulty":3,"oj":"codeforces-gym"},"htmlAst":{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"題目敘述"}]},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"輸入僅有一行包含二元字串 $S$（$1\\le |S|\\le 2000$）。"}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸出說明"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"輸出一個與 $S$ 長度相等的二元字串 $T$，滿足 $edit(S, T) > |S|/2$。"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 1"}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"0011\n"}]}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 1"}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"1100\n"}]}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 2"}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"1100101\n"}]}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 2"}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"0011010\n"}]}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ 連結"}]},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://codeforces.com/gym/102001/problem/A"},"children":[{"type":"text","value":"Codeforces Gym 102001 - A"}]}]},{"type":"text","value":"\n"}]},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果單純把所有數字都反過來，可能不太行。比方說以下的反例："},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"01010101"}]},{"type":"text","value":"，反過來就變成 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"10101010"}]},{"type":"text","value":"，顯然我們只要刪掉第一個字元並且補到後面去就行了。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"換一個想法想，如果字串長度 $n$ 是奇數，那麼根據 $edit({\\tt{000\\cdots 0}}, S) + edit(S, {\\tt{111\\cdots 1}}) \\ge edit({\\tt{000\\cdots 0}}, {\\tt{111\\cdots 1}}) = n$，我們知道其中一個一定會超過 $n/2$，因為 $n$ 是奇數，所以一定有一個會嚴格大於 $n/2$。換句話說，$n$ 是奇數的時候很好解決！"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"那 $n$ 是偶數的時候怎麼辦？考慮 $S$ 的前 $n-1$ 個 bit（此時 $n-1$ 是奇數）我們稱這個前綴為 $S_0$。根據前一段的論述，我們可以找出一個"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"等長的"}]},{"type":"text","value":" $T_0$ 滿足 $edit(S_0, {T_0})\\ge \\lceil \\frac{n-1}{2}\\rceil = n/2$。此時顯然有 $edit(S, {T_0}), edit(S_0, \\red{T_0{\\tt{0}}}), edit(S_0, \\red{T_0{\\tt{1}}}) \\ge n/2$。還記得計算 edit distance 的動態規劃嗎？無論我們在 $T_0$ 後面補哪個字元 $x$，總能夠有"}]},{"type":"text","value":"$$\n    edit(S, \\red{T_0x}) = \\min \\begin{cases}\n    edit(S_0, T_0) + (S[n-1] {\\tt{==}} x) & \\text{修改字元}\\\\\n    edit(S_0, \\red{T_0x}) + 1 & \\text{刪除字元}\\\\\n    edit(S, T_0) + 1 & \\text{插入字元}\n    \\end{cases}\n$$"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這時候注意到：如果我們選定 $x\\neq S[n-1]$，無論是哪種 case 都至少保證此時 $edit(S, \\red{T_0x}) > n/2$，達到目標！"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"為了實作方便，我們考慮的是 $S$ 的末 $n-1$ 個字元，然後找到 $T$ 以後再根據 $S[0]$ 把相對應的字元放到前面。"}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"#include <iostream>\n#include <string>\nusing namespace std;\n\nint main() {\n  string s, t;\n  cin >> s;\n  \n  // 計算字串中 0 和 1 出現的個數。\n  int b[2] = {};\n  for (int i = 1; i < s.size(); i++) b[s[i]=='1']++;\n  \n  // 構造出距離比較遠的全 0 或全 1 字串。\n  t = string(s.size(), '0' + (b[0] > b[1]));\n  \n  // 然後把第一個字元改成與 s[0] 不同的字元，並且輸出。\n  t[0] = '0' + '1' - s[0];\n  cout << t << endl;\n  return 0;\n}\n"}]}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"備註 1"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Edit Distance 好像又被稱為 "},{"type":"element","tagName":"a","properties":{"href":"https://en.wikipedia.org/wiki/Levenshtein_distance"},"children":[{"type":"text","value":"Levenshtein Distance"}]},{"type":"text","value":"，是一種衡量兩個字串是否有多接近的指標（metric，不是 pointer XD）。"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"備註 2"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Edit Distance 滿足三角不等式：$edit(A, B)+edit(B, C) \\ge edit(A, C)$，白話文解釋就是從 $A$ 換到 $C$ 的方法，至少有先從 $A$ 變成 $B$ 再從 $B$ 變成 $C$ 來得好。"}]},{"type":"element","tagName":"theorem","properties":{"title":"演算法豆知識","c":"is-primary"},"children":[{"type":"text","value":"\n在[強指數時間假說](/algo/strong-exponential-time-hypothesis)為真的前提之下，計算兩個長度為 $n$ 字串的 Edit Distance (exact) 至少得花 $\\Omega(n^{2-\\epsilon})$ 的時間。但是就近似演算法 (Approximation Algorithms) 而言， 2018 年 FOCS 的一篇最佳論文 [_Approximating Edit Distance Within Constant Factor in Truly Sub-Quadratic Time_](https://arxiv.org/abs/1810.03664)，在 $\\tilde{O}(n^{12/7})$ 時間內保證得到 $1680$-approxmation 的近似解，是為近期的一個重大突破。（作者們相信稍微用他們的方法再努力一下就可以做到 $(3+\\epsilon)$-approximation）\n"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"備註 3"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"解答上面有一句話：此時顯然有 $edit(S, {T_0}), edit(S_0, \\red{T_0{\\tt{0}}}), edit(S_0, \\red{T_0{\\tt{1}}}) \\ge n/2$。這句話必須在 $|S_0|= |T_0|$ 的時候才成立。當 $|S_0|\\neq|T_0|$ 的時候，你能找到反例嗎？"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"關於競程日記"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"🍅 如果您想到更多有趣漂亮簡單乾淨的解法話歡迎留言給競程日記小編群！"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"ℹ️ 這是一篇投稿給"},{"type":"element","tagName":"a","properties":{"href":"https://www.facebook.com/%E7%AB%B6%E7%A8%8B%E6%97%A5%E8%A8%98-1514973425463954/"},"children":[{"type":"text","value":"競程日記"}]},{"type":"text","value":"的文章，歡迎大家投稿、交流與分享程式解題競賽的點點滴滴！"}]}]}}},{"node":{"frontmatter":{"title":"最小費用流的消圈演算法","category":"algo","path":"/algo/min-cost-max-flow-cycle-cancellation","date":"2018-11-20","_PARENT":"9f394bd1-5ad6-544c-9714-9f4d7851f260","description":null,"link":null,"code":null,"difficulty":null,"oj":null},"htmlAst":{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"剩餘網路 Residual Networks"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"要討論網路流，就必須要討論剩餘網路（residual networks）。如果我們在圖 $G$ 上面有一個流 $f$，那我們可以定義一個剩餘網路 $G_f$，代表有哪些地方還有空間推進更多的網路流。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"最小費用流在剩餘網路上會長什麼樣子呢？很幸運地，Klein 在 1967 年為我們證明了以下定理："}]},{"type":"element","tagName":"theorem","properties":{"title":"負圈定理"},"children":[{"type":"text","value":"\n$f$ 是最佳解若且唯若 $G_f$ 上面定義 cost 為權重時，不存在一個負圈。\n"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"證明"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"\"$\\Rightarrow$\":"},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"\n如果 $G_f$ 上面存在一個負圈，那麼沿著這個負圈增廣，會得到總花費更小的解，與 $f$ 最佳解的假設矛盾。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"\"$\\Leftarrow$\":"},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"\n如果 $f$ 不是最佳解，那我們考慮真正的最佳解 $f^\\star$。考慮兩個解的差異 $f'=f^\\star - f$，不難推敲得知 $f'$ 的所有邊都會出現在 $G_f$ 上面。由於 $f'$ 是一個可行流，我們可以將 $f'$ 拆成許多圈的疊加。但是因為 $cost(f')$ 帶來的總花費是負的（因為 $cost(f') = cost(f^\\star) - cost(f) < 0$），所以至少有一個圈帶來的花費也是負的。得證。"}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"消圈演算法 Cycle Cancellation Algorithms"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這個演算法是由 Klein [1967] 從 Ford-Fulkerson 網路流演算法得來的想法，以迭代的方式不斷地更新當前找到的解，直到滿足最佳解條件為止。"},{"type":"element","tagName":"sup","properties":{"id":"fnref-2"},"children":[{"type":"element","tagName":"a","properties":{"href":"#fn-2","className":["footnote-ref"]},"children":[{"type":"text","value":"2"}]}]}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"f = 空的網路流\nwhile 剩餘網路 G_f 上面存在負圈:\n    令 C 為任何一個負圈\n    令 Δ 為這個負圈上能推的最大流量\n    更新 f = f + CΔ\n"}]}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"時間複雜度"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如同 Ford-Fulkerson 演算法一般，在所有 cost 和 capacity 都是整數的時候，每一次消圈，只能夠保證總花費至少降低了 1 單位。顯然最小的總花費值比 $-mCU$ 來得大，所以我們可以得知迭代消圈的次數至多為 $O(mCU)$。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"而找負圈的演算法則可以使用 Bellman-Ford 演算法，所需時間為 $O(nm)$。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"因此整體的時間複雜度是 $O(nm^2CU)$，由於 $C$ 和 $U$ 僅是數值，相對於輸入規模而言是指數級別的，在數值較大時效率不甚理想。"}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"更快的消圈算法"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"從計算最大網路流的演算法當中，當我們每次找出剩餘網路圖上最寬的增廣路徑時，這條增廣路徑至少可以推進 ${\\mathbf{MaxFlow}}(G_f)/m$ 的流量。這麼一來，在所有容量限制都是整數的情況下，增廣的次數上界可以從原本 Ford-Fulkerson 演算法的 ${\\mathbf{MaxFlow}}(G)$ 降低至 $O(m\\log_2 {\\mathbf{MaxFlow}}(G))$。這個值以輸入的資料量而言，就是多項式了。"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"最負圈 Most Negative Cycle"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"消圈算法是否也有同樣的特性呢？答案是有的，我們可以用一模一樣的方式證明，如果每一次我們找出那個「最負的負圈」，那麼總 cost 會向目標邁進至少 $O(1/m)$ 的比例。採用了這個方法的話，我們就可以讓消圈次數限制在 $O(m\\log_2|{\\mathbf{MinCost}}(G)|)$，是為多項式。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"但是，找出「最負的負圈」對於輸入是任意圖的情形下，是 NP-Hard 的。目前我們仍不知道有沒有有效率的多項式演算法來找出它。於是 Goldberg 跟 Tarjan 於 1989 年發現，每一次不見得要找「最負的負圈」，只要「足夠負」就可以有一樣的效果！他們利用了 Karp 在 1978 年提出的「最小均值圈」演算法，每一次找出「平均花費最負的圈」進行增廣，就可以達到一樣的效果啦。"}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"最小均值圈"}]},{"type":"element","tagName":"theorem","properties":{"title":"最小均值圈 [Karp 1978]"},"children":[{"type":"text","value":"\n設 $G$ 為有向有權圖。定義 $\\hat{G}$ 為 $G$ 外加上一點 $s$ 並從 $s$ 到每一點分別加上一條權重為 0 的邊。令 $d_k(v)$ 為從 $s$ 出發經過恰好 $k$ 條邊抵達點 $v$ 的最小總權重和。則最小均值圈的平均值 $\\lambda^*$ 滿足\n$$\n\\lambda^* = \\min_v \\max_{1\\le k \\le n-1} \\frac{d_n(v) - d_k(v)}{n-k}\n$$\n"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Karp 的證明"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"首先我們先證明，如果 $\\lambda^*=0$，那麼上面這個式子右半邊的值恰好會是 $0$："}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果 $\\lambda^*=0$，那麼這個圖一定不存在負圈。既然不存在負圈，我們就可以定義最短路徑（可以參考 Edmonds-Karp）。定義 $\\mathrm{dist}(s, v)$ 為 $s$ 到 $v$ 的最短路徑長度。顯然對於所有點 $v$ 和正整數 $k$，$d_n(v) \\ge d_k(v)$。此外必定存在某個 $k$ 使得 $d_k(v) = \\mathrm{dist}(s, v)$。因此，對所有 $v$ 來說，$\\max_{1\\le k \\le n-1} \\frac{d_n(v) - d_k(v)}{n-k} \\ge 0$。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"得知右半邊的式子永遠非負以後，剩下的任務就是要證明真的存在一組 $v, k$ 使得 $d_n(v) = d_k(v)$。令 $C$ 為總和是 $0$ 的圈，由於 $\\lambda^*=0$，在這個圈上任何兩點之間的最短路徑，必定等於這個圈上從一點走到另一點的距離（如果更短的話就有負圈啦）。考慮 $s$ 到這個 $C$ 上面任一點 $x$ 的最短路徑，這條路徑必定用掉不超過 $n-1$ 條邊。然後我們從 $x$ 開始沿著這個圈 $C$ 走，直到補足 $n$ 條邊為止。假設最後停在 $y$ 這個點。那麼，我們要說的是 $d_n(y) = \\mathrm{dist}(s, y)$，因為："}]},{"type":"text","value":"$$\n\\begin{align*}\n\\mathrm{dist}(s, y) & \\le d_n(y) \\\\\n& \\le \\mathrm{dist}(s, x) + \\mathrm{dist}(x, y) \\\\\n& \\le \\mathrm{dist}(s, y) + \\mathrm{dist}(y, x) + \\mathrm{dist}(x, y) \\\\\n& \\le \\mathrm{dist}(s, y) + 0\n\\end{align*}\n$$"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"所以，$y$ 這個點達到了最小值 $0$。於是當 $\\lambda^*=0$ 時等式成立。\n要怎利用這個證明推導出對所有的 $\\lambda^*$ 都正確呢？注意到我們可以同時對所有的邊「平移」（同時加上一個常數 $c$）而這件事情會使得所有圈的平均值都一起「平移」$c$，同時也讓式子右邊「平移」了 $c$。因此對於任意 $\\lambda^*$ 我們只要平移它到 $0$，再運用上述的證明，再平移回來，就行啦！證明完畢。"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"關於演算法"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"最直接的方法就是直接用 $O(mn)$ 動態規劃計算出所有 $d_k(v)$ 的值，其他演算法我們可以改天聊。至於要找出實際的圈，我們可以先從上面的計算找出得到最佳值的 $v, k$，然後找出從 $s$ 到 $v$ 走恰好 $n$ 步的最小路徑，這個路徑上的任何一個 cycle 都是最小均值圈"},{"type":"element","tagName":"sup","properties":{"id":"fnref-4"},"children":[{"type":"element","tagName":"a","properties":{"href":"#fn-4","className":["footnote-ref"]},"children":[{"type":"text","value":"4"}]}]},{"type":"text","value":"。"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"應用到消圈算法"}]},{"type":"element","tagName":"theorem","properties":{"title":"最小均值消圈定理 [Goldberg-Tarjan 1989]"},"children":[{"type":"text","value":"\n如果每次從剩餘網路中增廣最小均值圈，那麼保證消圈的迭代次數不超過 $O(\\min\\{mn\\log(nC), m^2n\\log n\\})$ 次。\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"證明的步驟簡述如下。完整的證明可以在這份 Note "},{"type":"element","tagName":"sup","properties":{"id":"fnref-7"},"children":[{"type":"element","tagName":"a","properties":{"href":"#fn-7","className":["footnote-ref"]},"children":[{"type":"text","value":"7"}]}]},{"type":"text","value":" 找到。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"概念1"}]},{"type":"text","value":": 如果 $G_f$ 上面有負圈，那麼對於 $G_f$ 上面的最小均值圈，其平均也是負的。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"概念2"}]},{"type":"text","value":": 我們定義 $\\mu(f)$ 表示為將 $G_f$ 的最小均值圈變成非負的最小平移常數。（也就是說，最小均值圈的平均值為 $-\\mu(f)$）"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"概念3"}]},{"type":"text","value":": 對於任何勢能函數（或距離函數）$d$，我們定義等效邊權 $cost^d(u, v) = cost(u, v) + d(u) - d(v)$。不難發現，對於任何一個圖上的圈來說，其邊權的和總是等於等效邊權的和。也就是說，這樣的轉換並不會影響最小均值圈的數值。但可以藉此調整一些邊的權重。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"概念4"}]},{"type":"text","value":": 我們定義 $-\\epsilon(f)$ 表示對於任意函數 $d$ 定義出的等效邊權中，最小權重最大者。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"概念5"}]},{"type":"text","value":": 注意到，如果這個圖的最小均值圈是 $-\\mu(f)$ 的話，無論我們怎麼調整函數 $d$，調整後最小的那條邊一定小於平均。因此有 $-\\epsilon(f) \\le -\\mu(f)$。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"概念6"}]},{"type":"text","value":": 相反地，若考慮平移後的圖 $G_f+\\mu(f)$，我們可以在上面定義一個距離函數 $d$，使得對所有 $(u, v)\\in G_f$ 我們都有 $d(u) + cost(u, v) \\ge d(v)$。也就是等效邊權 $cost^d(u, v)\\ge 0$。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"概念7"}]},{"type":"text","value":": 把上面這個做出來的 $d$ 再減去 $\\mu(f)$，得到一個勢能函數（或距離函數），其等效邊權 $cost^{d-\\mu(f)}(u, v) \\ge -\\mu(f)$。於是我們有 $-\\epsilon(f) \\ge -\\mu(f)$。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"概念8"}]},{"type":"text","value":": 綜合概念 5 與 7 我們可以得到 $\\mu(f)=\\epsilon(f)$。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"概念9"}]},{"type":"text","value":": 現在固定一個 $f$，以及一個可以得出最佳等效距離的函數 $d$。假設在 $G_f$ 上面消完一個最小均值圈以後，得到的新的流是 $f'$。我們想要說兩件事情："}]},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"$\\epsilon(f') \\le \\epsilon(f)$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"如果消的圈上存在一條正的等效邊，那麼 $\\epsilon(f') \\le \\left(1-\\frac{1}{n}\\right)\\epsilon(f)$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"假設我們增廣後仍暫時使用同樣的 $d$ 函數。那麼連續 $m$ 次增廣之內，一定會消到一個圈使得某條以 $d$ 為基準的等效邊是非負的，於是 2. 成立。"}]},{"type":"text","value":"\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"概念10"}]},{"type":"text","value":": 因此，一開始 $\\epsilon(f_{始})\\le C$，經過 $mn\\ln {nC}$ 次增廣以後 $\\epsilon(f_{終}) < \\left(1-\\frac{1}{n}\\right)^{n\\ln {nC}} C \\le \\frac{1}{n}$。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"概念11"}]},{"type":"text","value":": 如果所有容量和花費都是整數，那麼當最小均值圈 $> -\\frac{1}{n}$ 的時候，就代表它 $\\ge 0$。此時消圈算法就會停止。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"除了 "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"概念9"}]},{"type":"text","value":" 的 1. 和 2. 需要額外證明以外，上面的論述基本上就是全部的證明了。耶！搞定！"}]},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"結論"}]},{"type":"text","value":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"type":"element","tagName":"table","properties":{},"children":[{"type":"element","tagName":"thead","properties":{},"children":[{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"th","properties":{},"children":[{"type":"text","value":"演算法"}]},{"type":"element","tagName":"th","properties":{},"children":[{"type":"text","value":"消圈的次數"}]},{"type":"element","tagName":"th","properties":{},"children":[{"type":"text","value":"每一次消圈的時間"}]},{"type":"element","tagName":"th","properties":{},"children":[{"type":"text","value":"Weakly-Polynomial Worst-Case Complexity"}]},{"type":"element","tagName":"th","properties":{},"children":[{"type":"text","value":"Strongly-Polynomial Worst-Case Complexity"}]}]}]},{"type":"element","tagName":"tbody","properties":{},"children":[{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"element","tagName":"nobr","properties":{},"children":[{"type":"text","value":"Goldberg and Tarjan [1989]"}]},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"每次消最小均值圈"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(nm \\log (nC))$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(nm)$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(n^2m^2\\log (nC))$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(n^2m^3)$"}]}]},{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"element","tagName":"nobr","properties":{},"children":[{"type":"text","value":"Goldberg and Tarjan [1989]"}]},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"每次找所有簡化邊權重為負的圈"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(nm \\log (nC))$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(\\log n)$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(nm\\log n\\log (nC))$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(nm^2\\log^2n)$"}]}]},{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"element","tagName":"nobr","properties":{},"children":[{"type":"text","value":"Barahona and Tardos [1989]"}]},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"每次找一票點不重複的負圈然後增廣"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(m \\log (nCU))$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(nm+n^2\\log n)$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O((nm^2+mn^2\\log n)\\log(nCU)$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"N/A"}]}]},{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"element","tagName":"nobr","properties":{},"children":[{"type":"text","value":"Rock [1991]"}]},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"每次找剩餘流量足夠大的負圈"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(m \\log U)$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(nm)$ 或 $O(m+n\\log n)$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(nm^2\\log U)$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"N/A"}]}]},{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"element","tagName":"nobr","properties":{},"children":[{"type":"text","value":"Wallacher [1991]"}]},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"每次找最負比重負圈"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(m \\log (nCU))$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(n^3\\log^2 n)$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(n^3m\\log^2 n\\log(nCU))$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"N/A"}]}]},{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"element","tagName":"nobr","properties":{},"children":[{"type":"text","value":"Shigeno, Iwata and McCormick [1996]"}]},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"最負圈鬆弛演算法"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(nm \\log (nC))$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(nm+n^2\\log n)$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(n^2m^2\\log (nC)$ $+$ $n^3m\\log n\\log (nC))$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(n^2m^3\\log n$ $+$ $n^3m^2\\log n)$"}]}]},{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"element","tagName":"nobr","properties":{},"children":[{"type":"text","value":"Shigeno, Iwata and McCormick"},{"type":"element","tagName":"sup","properties":{"id":"fnref-3"},"children":[{"type":"element","tagName":"a","properties":{"href":"#fn-3","className":["footnote-ref"]},"children":[{"type":"text","value":"3"}]}]},{"type":"text","value":" [1996]"}]},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"最負圈縮放代價演算法"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(nm \\log C)$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(\\log n)$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(nm\\log C \\log n)$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"N/A"}]}]},{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"element","tagName":"nobr","properties":{},"children":[{"type":"text","value":"Sokkalingam, Ahuja and Orlin [1997]"}]},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"每次找剩餘流量足夠大的負圈"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(m \\log C)$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(m+n\\log n)$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(m^2\\log C$ $+$ $nm\\log C\\log n)$"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"$O(m^3\\log n$ $+$ $nm^2\\log^2 n)$"}]}]}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"small","properties":{},"children":[{"type":"text","value":"資料來源： Sokkalingam, Ahuja, Orlin, "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"New Polynomial-Time Cycle-Cancelling Algorithms for Minimum Cost Flows"}]},{"type":"text","value":", 1997. "},{"type":"element","tagName":"sup","properties":{"id":"fnref-1"},"children":[{"type":"element","tagName":"a","properties":{"href":"#fn-1","className":["footnote-ref"]},"children":[{"type":"text","value":"1"}]}]}]}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"參考資料"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{"className":["footnotes"]},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{"id":"fn-1"},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://pdfs.semanticscholar.org/f799/350ee4b93f02e672157d54ee06849edb7355.pdf"},"children":[{"type":"text","value":"Sokkalingam, Ahuja, Orlin, "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"New Polynomial-Time Cycle-Cancelling Algorithms for Minimum Cost Flows"}]},{"type":"text","value":", 1997."}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"a","properties":{"href":"#fnref-1","className":["footnote-backref"]},"children":[{"type":"text","value":"↩"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{"id":"fn-2"},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://www2.cs.duke.edu/courses/fall15/cps232/scribe_notes/lec05.pdf"},"children":[{"type":"text","value":"Duke University COMPSCI532 Fall 2015 Scribe Notes"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"a","properties":{"href":"#fnref-2","className":["footnote-backref"]},"children":[{"type":"text","value":"↩"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{"id":"fn-3"},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://www.jstor.org/stable/3690424?seq=1"},"children":[{"type":"text","value":"Shigeno, Iwata and McCormick, "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"Relaxed Most Negative Cycle and Most Positive Cut Canceling Algorithms for Minimum Cost Flow"}]},{"type":"text","value":", Mathematics of Operations Research 2000"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"a","properties":{"href":"#fnref-3","className":["footnote-backref"]},"children":[{"type":"text","value":"↩"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{"id":"fn-4"},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"http://www.cs.colostate.edu/~rmm/minCycleMean.pdf"},"children":[{"type":"text","value":"Colorado State University 最小均值圈講義"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"a","properties":{"href":"#fnref-4","className":["footnote-backref"]},"children":[{"type":"text","value":"↩"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{"id":"fn-5"},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"http://www.columbia.edu/~cs2035/courses/ieor6614.S16/mmc.pdf"},"children":[{"type":"text","value":"Columbia University 最小均值圈投影片"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"a","properties":{"href":"#fnref-5","className":["footnote-backref"]},"children":[{"type":"text","value":"↩"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{"id":"fn-6"},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://people.orie.cornell.edu/dpw/orie633/LectureNotes/lecture12.pdf"},"children":[{"type":"text","value":"Cornell University 的 Goldberg-Tarjan 演算法講義"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"a","properties":{"href":"#fnref-6","className":["footnote-backref"]},"children":[{"type":"text","value":"↩"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{"id":"fn-7"},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-854j-advanced-algorithms-fall-2008/lecture-notes/lec4.pdf"},"children":[{"type":"text","value":"MIT開放課程講義：Goldberg-Tarjan 演算法分析"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"a","properties":{"href":"#fnref-7","className":["footnote-backref"]},"children":[{"type":"text","value":"↩"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]}]}}},{"node":{"frontmatter":{"title":"SnackDown19 Elimination Round","category":"cp","path":"/cp/snckel19","date":"2018-12-08","_PARENT":"61db7e5a-936e-5da1-8d9e-f795244b3de6","description":null,"link":"https://www.codechef.com/SNCKEL19","code":null,"difficulty":null,"oj":null},"htmlAst":{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"唉唉，今天狀況超級不對啊。整個就是撞牆卡在 Suffix Palindrome 完全寫不出來，然後到了快三個半鐘頭才想到 Lighting Rectangle 要怎麼寫，還錯了一次，真是奇慘無比。"}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Lighting Rectangle "},{"type":"element","tagName":"a","properties":{"href":"https://www.codechef.com/SNCKEL19/problems/RECTLIT"},"children":[{"type":"text","value":"RECTLIT"}]}]},{"type":"element","tagName":"theorem","properties":{"c":"is-info"},"children":[{"type":"text","value":"\n在一個二維座標平面上有一個 $(0, 0)$ 到 $(N-1, N-1)$ 的正方形。在這個正方形區域內有 $K$ 盞燈。對於每一盞燈而言，這盞燈為原點可以把整個平面分成四個象限。而你可以為每一盞燈選擇照亮其中一個象限（在邊界上也算是有被照亮）。現在給你這 $K$ 盞燈的位置，是否存在一種方法，讓它們可以照亮整個正方形的範圍呢？\n"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"簡單來說就是分 Case 題："}]},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"在內部如果有四個點，那麼存在一種方式可以照亮所有區域。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"如果角落有一個點，那麼一定可以照亮所有區域。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"把邊分成上下、跟左右兩個部份。如果其中一個部份有兩個點，那可以照亮所有區域。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"如果邊上有一個點、而且內部有至少兩個點，那麼可以照亮所有區域。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"如果邊上有兩個點、而且內部至少有一個點，那麼可以照亮所有區域。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"除了以上情形外，其他情形都無法照亮所有區域。"}]},{"type":"text","value":"\n"}]},{"type":"element","tagName":"style","properties":{},"children":[{"type":"text","value":"\n#outer-rect {\n     stroke-width: 4;\n}\n.blue.quadrant.region {\n    fill: rgba(0,0,255,0.3);\n}\n.blue.quadrant.origin {\n    fill: blue;\n}\n.blue.quadrant.boundary.start,\n.blue.quadrant.boundary.end {\n    stroke-width: 2;\n    stroke: rgba(0,0,255,0.6);\n}\n.red.quadrant.region {\n    fill: rgba(255, 0, 0, 0.3);\n}\n.red.quadrant.origin {\n    fill: darkred;\n}\n.red.quadrant.boundary.start,\n.red.quadrant.boundary.end {\n    stroke-width: 2;\n    stroke: rgba(200,0,0,0.6);\n}\n.yellow.quadrant.region {\n    fill: rgba(255, 255, 0, 0.3);\n}\n.yellow.quadrant.origin {\n    fill: gold;\n}\n.yellow.quadrant.boundary.start,\n.yellow.quadrant.boundary.end {\n    stroke-width: 2;\n    stroke: rgba(233,233,0,0.6);\n}\n"}]},{"type":"element","tagName":"mysvg","properties":{"width":300,"height":200,"viewbox":"-10 -10 330 230"},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"rect","properties":{"x":"0","y":"0","width":300,"height":200,"fill":"none","stroke":"black","id":"outer-rect"},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"display-inner","properties":{"quadrant":"","dotAtOrigin":"","x":"90","y":"70","r":"600","angleStart":"0","angleEnd":"90","boundaryAtStart":"","boundaryAtEnd":"","c":"blue","clipHref":"#outer-rect"},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"display-inner","properties":{"quadrant":"","dotAtOrigin":"","x":"160","y":"120","r":"600","angleStart":"270","angleEnd":"360","boundaryAtStart":"","boundaryAtEnd":"","c":"red","clipHref":"#outer-rect"},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"display-inner","properties":{"quadrant":"","dotAtOrigin":"","x":"185","y":"90","r":"600","angleStart":"180","angleEnd":"270","boundaryAtStart":"","boundaryAtEnd":"","c":"yellow","clipHref":"#outer-rect"},"children":[]},{"type":"text","value":"\n"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"// by tmt514\n#include <cstdio>\nusing namespace std;\n\nvoid solve() {\n  int K, N;\n  scanf(\"%d%d\", &K, &N);\n  int ncorner = 0;\n  int nsidex = 0;\n  int nsidey = 0;\n  int ninside = 0;\n  for(int i=0;i<K;i++) {\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    int sx = (x==0 || x==N-1);\n    int sy = (y==0 || y==N-1);\n    if(sx && sy) { ncorner++; }\n    else if(sx) { nsidex++; }\n    else if(sy) { nsidey++; }\n    else ninside++;\n  }\n  if (ncorner==0 && nsidex==1 && nsidey==1 && ninside==0) puts(\"no\");\n  else\n  puts(4*ncorner + 2*nsidex + 2*nsidey + ninside >= 4? \"yes\": \"no\");\n}\n\nint main(void) {\n  int T;\n  scanf(\"%d\", &T);\n  while(T--) solve();\n  return 0;\n}\n"}]}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Suffix Palindromes "},{"type":"element","tagName":"a","properties":{"href":"https://www.codechef.com/SNCKEL19/problems/SFXPAL"},"children":[{"type":"text","value":"SFXPAL"}]}]},{"type":"element","tagName":"theorem","properties":{"c":"is-info"},"children":[{"type":"text","value":"\n考慮大小恰好為 $S$ 的字母集。請問有多少長度為 $N$ 的字串，其所有後綴字串都不是迴文？輸出答案除以 $M$ 的餘數。($1\\le N\\le 1000, 1\\le S\\le M-1 < 2^{30}-1$)\n"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這是一道很漂亮的 DP 題。假設 $f(n)$ 是答案，那麼每個字串的最後 $n-1$ 個字元都會被算入 $f(n-1)$。所以我們可以嘗試扣除掉加了一個字元以後會變成迴文的可能情形。而利用迴文的特性，我們可以證明在「加了一個字以後變成迴文」的當下，所有可能的迴文只能是來自 $f(\\lceil n/2\\rceil)$。所以，可以從 $f(1)=S$ 開始，依序計算 $f(n) = Sf(n-1) - f(\\lceil n/2\\rceil)$。"}]},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"display","properties":{"array":"","data":"[\"S\", \"---------f(n-1) 之中的答案---------\"]"},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"display","properties":{"array":"","data":"[\"--反過來的 f(n/2)--\", \"------f(n/2)------\"]"},"children":[]},{"type":"text","value":"    "}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"// by tmt514\n#include <iostream>\n#include <vector>\nusing namespace std;\ntypedef long long LL;\n\nint main(void) {\n  LL N, S, M;\n  cin >> N >> S >> M;\n  vector<LL> dp(N+1);\n  dp[0] = 1;\n  dp[1] = S;\n  for (int i = 2; i <= N; i++) {\n    dp[i] = S*dp[i-1] - dp[(i+1)/2];\n    dp[i] = (dp[i]%M+M)%M;\n  }\n  cout << dp[N] << endl;\n  return 0;\n}\n"}]}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Adi and the Tree "},{"type":"element","tagName":"a","properties":{"href":"https://www.codechef.com/SNCKEL19/problems/ADITREE"},"children":[{"type":"text","value":"ADITREE"}]}]},{"type":"element","tagName":"theorem","properties":{"c":"is-info"},"children":[{"type":"text","value":"\n在一個有 $N$ 個節點的樹上，進行 $M$ 項操作。一開始所有的節點都是「關燈」的狀態。每一次操作會給你兩個點 $a, b$。然後你把點 $a$ 與點 $b$ 切換其「開/關燈」狀態。接著，每一個操作結束之後，請你幫所有亮著的燈的節點兩兩配成一對，使得配對的節點距離總和最小。每次操作後，都輸出配對後的最小總和。$(1\\le N, M\\le 250000)$\n"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"另一個乾淨的漂亮問題。這題的主要觀察點在於：最小的距離總和，恰好等於所有「子樹中有奇數個亮燈」節點的數量。所以我們只需要維護一個資料結構，使得每次更新兩個點後，順便更新節點的奇偶性就行了！"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"要怎麼動態更新節點的奇偶性呢？我們可以利用樹鍊剖分，把一棵樹分成許多路徑，使得任何一個節點到樹根的路上至多只跨越 $O(\\log N)$ 條路徑。我們在每一條路徑上面維護一個線段樹，因此總時間複雜度是 $O(N+M\\log^2 N)$。"}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"// by tmt514\n#include <algorithm>\n#include <cstdio>\n#include <vector>\nusing namespace std;\n\nstruct SegNode {\n  int odd, even;\n  bool inverted;\n};\n\nclass SegmentTree {\n  public:\n    vector<SegNode> seg;\n    void init(int x, int l, int r) {\n      if (l == r) seg[x] = (SegNode){0, 1, false};\n      else {\n        int m = (l+r)/2;\n        init(x*2, l, m);\n        init(x*2+1, m+1, r);\n        seg[x] = (SegNode){0, r-l+1, false};\n      }\n    }\n    void init(int n) {\n      seg.resize(4*n);\n      init(1, 1, n);\n    }\n    void push(int x, int l, int r) {\n      if (l == r) { seg[x].inverted = false; }\n      else if (seg[x].inverted) {\n        swap(seg[x*2].odd, seg[x*2].even);\n        swap(seg[x*2+1].odd, seg[x*2+1].even);\n        seg[x*2].inverted ^= 1;\n        seg[x*2+1].inverted ^= 1;\n        seg[x].inverted = false;\n      }\n    }\n    void pull(int x) {\n      seg[x].odd = seg[x*2].odd + seg[x*2+1].odd;\n      seg[x].even = seg[x*2].even + seg[x*2+1].even;\n      if (seg[x].inverted) swap(seg[x].odd, seg[x].even);\n    }\n    void toggle(int x, int l, int r, int target) {\n      if (r <= target) {\n        swap(seg[x].odd, seg[x].even);\n        seg[x].inverted ^= 1;\n      } else {\n        int m = (l+r)/2;\n        push(x, l, r);\n        toggle(x*2, l, m, target);\n        if (target > m) toggle(x*2+1, m+1, r, target);\n        pull(x);\n      }\n    }\n    int ask(int x, int l, int r, int target) {\n      if (r <= target) {\n        return seg[x].odd;\n      } else {\n        int m = (l+r)/2;\n        push(x, l, r);\n        return seg[x*2].odd + ask(x*2+1, m+1, r, target);\n      }\n    }\n};\n\nconst int N = 250000;\nvector<int> a[N];\n\nint total_odd[N];\nint parent[N];\nint depth[N];\nint child[N];\nint segtree_idx[N];\nint segtree_seq[N];\nSegmentTree t[N];\nint segtree_root[N];\n\nvoid find_depth_dfs(int x, int p=-1) {\n  parent[x] = p;\n  depth[x] = 1;\n  for(auto y : a[x]) {\n    if (y != p) {\n      find_depth_dfs(y, x);\n      if(depth[y]+1 > depth[x]) {\n        depth[x] = depth[y]+1;\n        child[x] = y;\n      }\n    }\n  }\n}\n\nint all_segids = 0;\nvoid build_segment_tree(int x, int segid=0, int d=1) {\n  segtree_idx[x] = segid;\n  segtree_seq[x] = d;\n  if (d == 1) {\n    segtree_root[segid] = x;\n    t[segid].init(depth[x]);\n  }\n  for (auto y : a[x]) {\n    if (y == parent[x]) continue;\n    if (y == child[x]) build_segment_tree(y, segid, d+1);\n    else {\n      all_segids++;\n      build_segment_tree(y, all_segids, 1);\n    }\n  }\n}\n\n// 找出修改狀態時會經過的每一條鍊，我們把每一條鍊的進入點蒐集起來。\nvoid toggle(int x) {\n  vector<int> tree_ids;\n  int c = x;\n  while (c != -1) {\n    tree_ids.push_back(c);\n    c = parent[segtree_root[segtree_idx[c]]];\n  }\n  int delta = 0;\n  for (auto c : tree_ids) {\n    auto& tree = t[segtree_idx[c]];\n    delta -= tree.seg[1].odd;\n    tree.toggle(1, 1, depth[segtree_root[segtree_idx[c]]], segtree_seq[c]);\n    delta += tree.seg[1].odd;\n    total_odd[segtree_root[segtree_idx[c]]] += delta;\n  }\n}\n\nint main(void) {\n  int n, m;\n  // 處理第一部份的輸入：紀錄整棵樹的訊息。\n  scanf(\"%d\", &n);\n  for(int i=0;i<n-1;i++) {\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    a[x].push_back(y);\n    a[y].push_back(x);\n  }\n  // 用 DFS 連結每個節點至高度最高的子節點。\n  find_depth_dfs(1);\n  \n  // 對於每一條鍊，初始化一個相應大小的線段樹。\n  build_segment_tree(1);\n\n  // 處理第二部分輸入：對於一次輸入的兩個點 A, B，改變其燈號狀態。\n  scanf(\"%d\", &m);\n  while(m--) {\n    int A, B;\n    scanf(\"%d%d\", &A, &B);\n    toggle(A);\n    toggle(B);\n    printf(\"%d\\n\", total_odd[1]);\n  }\n\n  return 0;\n}\n"}]}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"其他推薦題解"}]},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://blog.csdn.net/qq_39972971/article/details/84922322"},"children":[{"type":"text","value":"cz_xuyixuan 博客"}]}]},{"type":"text","value":"\n"}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Recover Square "},{"type":"element","tagName":"a","properties":{"href":"https://www.codechef.com/SNCKEL19/problems/RECOVER"},"children":[{"type":"text","value":"RECOVER"}]}]},{"type":"element","tagName":"theorem","properties":{"c":"is-info"},"children":[{"type":"text","value":"\n在一個 $N\\times N$ 大小的網格中，每一格恰有一個不同的、介於 $1$ 到 $N\\cdot N$ 的數字。如果我們把"},{"type":"element","tagName":"b","properties":{},"children":[{"type":"text","value":"所有"}]},{"type":"text","value":"曼哈頓距離是 $1$ 或 $2$ 的格子對寫下來（總共有 $M$ 個這樣的配對），請問你是否能回溯出原本的網格？($1\\le N\\le 200$，一個輸入檔中有 $1\\le T\\le 200$ 筆測試資料。)\n"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"感覺就是從角落用拼拼圖的方式一個一個把它拼起來。可能有點麻煩就是了..."}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Adi and the Matrix "},{"type":"element","tagName":"a","properties":{"href":"https://www.codechef.com/SNCKEL19/problems/ADIMAT"},"children":[{"type":"text","value":"ADIMAT"}]}]},{"type":"element","tagName":"theorem","properties":{"c":"is-info"},"children":[{"type":"text","value":"\n對於兩個矩陣而言，若重排一些行、然後再重排一些列之後變成相等的矩陣，那我們就說這兩個矩陣同構。請問有多少種大小為 $2^{N\\times M}$ 的不同構 0/1-矩陣？輸出答案除以 $10^9+7$ 的餘數。($1\\le N\\times M\\le 550$)\n"}]}]}}},{"node":{"frontmatter":{"title":"Smart Thief","category":"prob","path":"/problem/icpc/asia_jakarta_2018/C","date":"2019-01-02","_PARENT":"f1d4ba02-37dc-5266-a1e7-02310dbb958c","description":"Ayu 想要打開一個使用密碼鎖加密的箱子。為了能夠找出正確密碼，Ayu 必須要很遺憾地嘗試所有長度為 $N$ 的密碼組合。\n\n有趣的是，Ayu 發現了這套密碼鎖系統其實相當古板：當你輸入 $N$ 個數字以後，系統會自動判斷你到底輸入正確與否。如果輸入了正確的密碼，那麼箱子的鎖便會打開。反之，如果輸入了錯誤的密碼，那麼系統會很聰明地把你先前輸入的第一個數字（最早的）丟掉，這麼一來，你只要再輸入一個數字就可以讓他變成長度 $N$ 了。\n\n舉例來說，如果 $N=4$，而且 Ayu 依序輸入了 `204320435`，那麼系統實際上會檢測 6 次（共有 5 種不同的 PIN）：\n\n* `2043`\n* `0432`\n* `4320`\n* `3204`\n* `2043`\n* `0435`\n\nAyu 想要在第一天測試 $K$ 種不同的密碼。你能不能找出任何一個長度最短的字串 $S$，使得它可以讓機器檢測到任意 $K$ 個不同的密碼呢？這個古老的系統能夠鍵入的數字種類有限：它們會是 `0` 到 `9` 這些數字中的某 $M$ 個。\n","link":"https://codeforces.com/gym/102001/problem/C","code":"ICPC-JAKARTA-2018-C","difficulty":7,"oj":"codeforces-gym"},"htmlAst":{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"題目敘述"}]},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"輸入包含 3 個整數 $N, M, K$（$1\\le N\\le 100000, 1\\le M\\le 10, 1\\le K\\le \\min(M^N, 100000)$），依序代表密碼的長度、能夠鍵入的數字種類、還有第一天想要測試的密碼量。輸入的第二列包含 $M$ 個整數：$A_i (0\\le A_i\\le 9)$ 表示能夠使用的數字們。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"你可以假設輸入的 $N, M, K$ 會使得答案字串不超過 $100000$ 位數。"}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸出說明"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"輸出任何一個滿足條件的、最短的字串 $S$。"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 1"}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"3 2 5\n4 7\n"}]}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 1"}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"7477447\n"}]}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 2"}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"2 5 9\n1 2 3 4 5\n"}]}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 2"}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"1234554321\n"}]}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 3"}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"6 3 2\n9 3 5\n"}]}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 2"}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"9353593\n"}]}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ 連結"}]},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://codeforces.com/gym/102001/problem/C"},"children":[{"type":"text","value":"Codeforces Gym 102001 - C"}]}]},{"type":"text","value":"\n"}]},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"首先，輸入的 $A_i$ 跟答案一點關係也沒有，因此我們總是可以假設這些數字是 $0, 1, \\ldots, M-1$。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這題的關鍵字只有一個，就是 "},{"type":"element","tagName":"a","properties":{"href":"https://en.wikipedia.org/wiki/De_Bruijn_sequence"},"children":[{"type":"text","value":"De Bruijn Sequence"}]},{"type":"text","value":"。對於給定的參數 $n, m$ 來說，De Bruijn Sequence $B(n, m)\\in [m]^n$ 是一個長度為 $n^m$ 的序列，把他接成一圈以後，任何連續的 $n$ 個字元都不相同。從這個序列的存在性來說，我們就可以斷定本題的答案長度一定是 $|S|=K+N-1$。所以囉，對於輸入的 $N, M, K$，答案之一就可以是 $B(N, M)$ 接成一圈以後的任何長度為 $K+N-1$ 的子字串。"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"第一種解法：一筆畫問題 Eulerian Path"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"常見的建構 De Bruijn Sequence 有兩種。第一種是將這個題目轉化成"},{"type":"element","tagName":"a","properties":{"href":"https://en.wikipedia.org/wiki/Eulerian_path"},"children":[{"type":"text","value":"一筆畫問題"}]},{"type":"text","value":"，如下圖所示（圖片參考自維基百科）："}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://upload.wikimedia.org/wikipedia/commons/thumb/3/38/De_bruijn_graph-for_binary_sequence_of_order_4.svg/800px-De_bruijn_graph-for_binary_sequence_of_order_4.svg.png","style":"max-width: 300px"},"children":[]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"從任何一點出發，然後走過所有的邊恰好可以接出一個 $B(2, 4)$。我們可以"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"利用 DFS 解一筆畫問題"}]},{"type":"text","value":"。由於這個圖很大（上面會有 $2^{N-1}$ 個節點），所以我們不可能把整張圖生出來再跑一筆畫演算法："}]},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"在 DFS 過程中，如果深度到達 $K$，那依循 DFS 的路徑就可以找到想要的 sequence。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"在 DFS 過程中，如果走訪完畢的邊數到達 $K$ 條，那這 $K$ 條邊也可以接成一個理想的 sequence。"}]},{"type":"text","value":"\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"由於 DFS 演算法每一步要嘛走訪一條新的邊、或是沿著一條邊回溯（並把這條邊丟進 stack），我們很確定最多只要走訪 $2K$ 條邊就可以中止我們的演算法。判斷一條邊被走過與否，有兩種方式：把每條邊雜湊以後存起來、或是把每個點雜湊以後，映至當前還有哪些邊沒走過（是一個 $0$ 到 $M-1$ 之間的數字）。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"所以本題可以在 $O(K)$ 次雜湊存取的時間被解決。"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"第二種解法：利用林登字串 Lyndon Words"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://en.wikipedia.org/wiki/Roger_Lyndon"},"children":[{"type":"text","value":"Roger Lyndon"}]},{"type":"text","value":" 是美國密西根大學的數學系教授，他在 1954 年的時候做了一些最小旋轉字典序字串的相關研究（主要是計數方面）。如果一個字串 $S$，滿足以下兩個特徵："}]},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"非循環字串：找不到另一個字串 $P$ 和整數 $k>1$ 使得 $S=\\underbrace{PP\\cdots P}_k$"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"$S$ 是所有 $S$ 的旋轉字串中字典順序最小的。"}]},{"type":"text","value":"\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"那麼該字串 $S$ 就是一個 Lyndon word。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"（題外話——說到旋轉字串與字典序，大家可能想到的就是 Burrows-Wheeler 轉換，這類型資料壓縮的技巧與 Lyndon Word 有著密切關聯。）"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"儘管早在 1934 年，M. H. Martin（我查不到是誰﹍）就用了類似 Lyndon word 的方法做出了 De Bruijn Sequence，但直到 1978 年才由 Harold Fredericksen 和 James Maiorana 兩位發現以下驚人的事實："}]},{"type":"element","tagName":"theorem","properties":{},"children":[{"type":"text","value":"\n把所有長度整除 $n$ 的 Lyndon words，依照字典順序（注意不是長度）排序後，全部接起來，就得到一個 de Bruijn 序列了！\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"下面這個演算法是使用第二種解法製作的："},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"依照字典順序"}]},{"type":"text","value":"產生所有長度整除 $n$ 的 Lyndon words，直到我們需要的長度為止。為了解釋下面的程式碼，我們利用關於 Lyndon word 旋轉字典序最小的性質："}]},{"type":"element","tagName":"theorem","properties":{},"children":[{"type":"text","value":"\n如果字串 $S$ 是一個 Lyndon word，那麼把他隨意拆成兩個子字串，左半邊的字典序保證小於右半邊。\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"有了這件事情以後，我們可以利用 DFS 一個一個字元決定。還記得 KMP 字串匹配演算法嗎？我們利用 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"last[]"}]},{"type":"text","value":" 陣列描述對於所有前綴字串，與之匹配的最長前綴子字串。"}]},{"type":"element","tagName":"algorithm","properties":{},"children":[{"type":"text","value":"\n    "},{"type":"element","tagName":"generator","properties":{},"children":[{"type":"element","tagName":"pre","properties":{},"children":[{"type":"text","value":"\n        function*(input, ui) {\n            var S = input.S;\n            var n = S.length;\n            var last = [];\n            var i, j;\n            last.push(-1);\n            ui.setStyleOnce('arr', `0`, {fill: 'yellow'});\n              ui.setStyleOnce('S', `0`, {fill: 'yellow'});\n            for (i = 1; i < n; i++) {\n              yield {S: S, arr: last};\n              j = last[i-1]+1;\n              while (j > 0 && S[j] !== S[i])\n                j = last[j-1]+1;\n              last[i] = (S[i]===S[j]? j : -1)\n              for (var k = 0; k <= j; k++) {\n                ui.setStyleOnce('arr', `${i-k}`, {fill: 'lightyellow'});\n                ui.setStyleOnce('S', `${i-k}`, {fill: 'lightyellow'});\n              }\n              ui.setStyleOnce('arr', `${i}`, {fill: 'yellow'});\n              ui.setStyleOnce('S', `${i}`, {fill: 'yellow'});\n            }\n            return {S: S, arr: last};\n        }\n        "}]},{"type":"text","value":"\n    "}]},{"type":"text","value":"\n    "},{"type":"element","tagName":"inputdata","properties":{"data":"{\"S\": \"aaabaaabaaabaabbaaabaabbb\"}"},"children":[]},{"type":"text","value":"\n    "},{"type":"element","tagName":"indirectdisplay","properties":{"array":"","fixedwidth":"","minwidth":"30","highlightdiff":"","varname":"S"},"children":[]},{"type":"text","value":"\n    "},{"type":"element","tagName":"indirectdisplay","properties":{"array":"","fixedwidth":"","n":"25","minwidth":"30","highlightdiff":"","varname":"arr"},"children":[]},{"type":"text","value":"\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果輸入的字串是 Lyndon word，那麼我們可以得到兩個觀察："}]},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"last[]"}]},{"type":"text","value":" 陣列，從左到右一旦有數字變小，永遠是從 $-1$ 開始，不會從中間繼續。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Lyndon word 做出來的 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"last[]"}]},{"type":"text","value":" 陣列，最後一個 last 值永遠是 $-1$。"}]},{"type":"text","value":"\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"所以 DFS 就很簡單啦：每次決定到底現在的 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"last[i]"}]},{"type":"text","value":" 要等於 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"last[i-1]+1"}]},{"type":"text","value":" 還是等於 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"-1"}]},{"type":"text","value":"。如果是前者，那麼只有一種選擇，如果是後者，那麼根據「分兩半字典序必須比較大」的原則，下一個值必須是從 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"last[i-1]+1"}]},{"type":"text","value":" 對應到的字元"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"的下一個"}]},{"type":"text","value":"往後開始跳。"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"#include <iostream>\n#include <vector>\nusing namespace std;\n\nstring s;\nint N, M, K;\nint current[100005];\nint a[10];\n\nstring get_string(int len) {\n  string ret = \"\";\n  for (int x = 0; x < len; x++)\n    ret += ('0' + a[current[x]]);\n  return ret;\n}\n\nvoid generate_lyndon_words(int now, int last) {\n  if (now && N%now == 0 && last == -1) {\n    s += get_string(now);\n  }\n\n  if (s.size() >= K+N-1) return;\n  if (now == N) return;\n\n  // 選擇延續 last。\n  if (now > 0) {\n    current[now] = current[last+1];\n    generate_lyndon_words(now+1, last+1);\n  }\n  // 選擇把 last 換成 -1，但是你的字典序要比原本的還要大。\n  for (int x = now? current[last+1]+1 : 0; x < M; x++) {\n    current[now] = x;\n    generate_lyndon_words(now+1, -1);\n  }\n}\n\nint main() {\n  cin >> N >> M >> K;\n  for (int i = 0; i < M; i++) cin >> a[i];\n  generate_lyndon_words(0, -1);\n  while (s.size() < K+N-1) s += s; // 某種邊界條件...\n  s = s.substr(0, K+N-1);\n  cout << s << endl;\n  return 0;\n}\n"}]}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"備註"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"官方題解使用的是第一種解法的不需要 Hash 版，分成兩種情形探討："}]},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"$M^N\\le 2^{40}$。整個 de Bruijn Graph 的邊數 $= 2^{40}$，也就是說所有的邊都可以直接以 $M$-進位轉換成 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"long long"}]},{"type":"text","value":" 數值。此時可以用 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"set<long long>"}]},{"type":"text","value":" 直接存走訪過的邊。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"$M^N > 2^{40}$。此時使用 "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"random walk"}]},{"type":"text","value":" 大法，隨機產生長度為 $K+N-1$ 的序列，有很高的機率會產出一個合法的答案。"}]},{"type":"text","value":"\n"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"關於競程日記"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"🍅 如果您想到更多有趣漂亮簡單乾淨的解法話歡迎留言給競程日記小編群！"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"ℹ️ 這是一篇投稿給"},{"type":"element","tagName":"a","properties":{"href":"https://www.facebook.com/%E7%AB%B6%E7%A8%8B%E6%97%A5%E8%A8%98-1514973425463954/"},"children":[{"type":"text","value":"競程日記"}]},{"type":"text","value":"的文章，歡迎大家投稿、交流與分享程式解題競賽的點點滴滴！"}]}]}}},{"node":{"frontmatter":{"title":"Go Make It Complete","category":"prob","path":"/problem/icpc/asia_jakarta_2018/G","date":"2019-01-04","_PARENT":"d6b743c0-cb89-5b59-8fb2-62c2f23c61ae","description":"給定一個無向簡單圖 $G$，找出最大的整數 $k$，使得存在一個包含所有尚未被加入 $G$ 的邊的序列 $L$，使得依序把這些邊 $(x, y)$ 加入圖 $G$ 的當下，$\\delta_x+\\delta_y \\ge k$。其中 $\\delta_x, \\delta_y$ 是當下點 $x$ 和點 $y$ 在圖 $G$ 上的度數。\n","link":"https://codeforces.com/gym/102001/problem/G","code":"ICPC-JAKARTA-2018-G","difficulty":5,"oj":"codeforces-gym"},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"簡化後題目敘述"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"輸入的第一列包含兩個整數 $N, M$ ($2\\le N\\le 500; 0\\le M < \\frac{N\\times (N-1)}{2}$) 代表點的數量與現存的邊數。接下來的 $M$ 列每一列包含兩個正整數 $a_i, b_i$ ($1\\le a_i < b_i \\le N$) 表示一條現存的邊。輸入保證任何配對 $(a_i, b_i)$ 只會出現至多一次。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸出說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"輸出所求的整數 $k$ 值。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"4 3\n1 2\n2 3\n3 4\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"3\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"5 0\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"0\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 3"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"5 2\n1 2\n3 4\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 3"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"2\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ 連結"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://codeforces.com/gym/102001/problem/G"},"children":[{"type":"text","value":"Codeforces Gym 102001 - G"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這題可以用枚舉法的概念，對於每一個 $k$ 值判斷是否存在一個加入邊的序列滿足條件。演算法如下："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"把所有滿足 $\\delta_x+\\delta_y\\ge k$ 但不在圖上的邊蒐集起來，加入一個佇列 $Q$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"只要佇列非空，抓一條佇列中的邊 $(x, y)$，把它加入圖中；掃過一次所有與點 $x$ 和點 $y$ 相鄰的所有不在圖上的邊，並判斷是否能夠把它們加入佇列。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"如果最終所有的邊都被加入了佇列，就代表這個 $k$ 值是個成功的 $k$ 值。反之則不行：在任意時刻加不進佇列的邊永遠度數和小於 $k$。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"以上的演算法的第一步會花 $O(N^2)$ 時間掃過所有點對。\n第二步可能會考慮 $O(N^2)$ 個點對、而每一條邊加入後會花 $O(N)$ 時間掃過相鄰的不在圖上的邊，因此第二步所花時間是 $O(N^3)$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"不難發現只要 $k$ 是答案，$k-1$ 也會是答案。於是我們可以對 $k$ 進行二分搜尋法，找到滿足條件的最大 $k$ 值。時間複雜度 $O(N^3\\log N)$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"但事實上二分搜尋法是不必要的。對於某個 $k$，若第二步完成後，還有邊沒有被加入圖上，那麼我們把 $k\\gets k-1$ 時，剛才那些已經加入的邊，顯然可以依照同樣順序被加入圖上。因此，我們只需要重新對剩下的邊跑過上述演算法即可。注意到最大可能的 $k$ 為 $(N-2)+(N-2)$，第一步可能要重新跑 $O(N)$ 次，因此總花費時間是 $O(N^3)$，第二步每一條邊仍然只會被加入到佇列至多一次，所以也還是 $O(N^3)$。我們就得到一個 $O(N^3)$ 的乾淨算法啦～"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"#include <algorithm>\n#include <iostream>\n#include <queue>\nusing namespace std;\n\nint a[505][505];\nint deg[505];\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n  for (int i = 0; i < m; i++) {\n    int x, y;\n    cin >> x >> y;\n    a[x][y] = a[y][x] = 1;\n    deg[x]++;\n    deg[y]++;\n  }\n  int k;\n  for (k = 2 * (n - 2); k >= 0; k--) {\n    queue<pair<int, int>> q;\n    // 第一步\n    for (int x = 1; x <= n; x++)\n      for (int y = x + 1; y <= n; y++)\n        if (!a[x][y] && deg[x] + deg[y] >= k) {\n          q.push({x, y});\n        }\n    // 第二步\n    while (!q.empty()) {\n      auto [x, y] = q.front();\n      q.pop();\n      if (a[x][y]) continue;\n      m++;\n      a[x][y] = a[y][x] = 1;\n      deg[x]++;\n      deg[y]++;\n      for (int z = 1; z <= n; z++) {\n        if (x != z && !a[x][z] && deg[x] + deg[z] >= k) q.push({x, z});\n        if (y != z && !a[y][z] && deg[y] + deg[z] >= k) q.push({y, z});\n      }\n    }\n    // 第三步\n    if (m >= n * (n - 1) / 2) break;\n  }\n  cout << k << endl;\n  return 0;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"備註"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果要再快個常數倍的話（大約兩倍），可以把第一步很多不必要的檢查節省起來：事先把所有沒在圖上的邊依照 $\\delta_x+\\delta_y$ 的值放到某個陣列裡面。在第二步更新的當下，可以順便更新 $(x, z)$ 和 $(y, z)$ 的度數和。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"關於競程日記"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"🍅 如果您想到更多有趣漂亮簡單乾淨的解法話歡迎留言給競程日記小編群！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"ℹ️ 這是一篇投稿給"},{"type":"element","tagName":"a","properties":{"href":"https://www.facebook.com/%E7%AB%B6%E7%A8%8B%E6%97%A5%E8%A8%98-1514973425463954/"},"children":[{"type":"text","value":"競程日記"}]},{"type":"text","value":"的文章，歡迎大家投稿、交流與分享程式解題競賽的點點滴滴！"}]}],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"[ECNA2018B] Difference","category":"prob","path":"/problem/icpc/ecna2018/B","date":null,"_PARENT":"58477d25-748d-5907-8f90-20e2821e8a1c","description":"小差距序列(SDS) 是一個由正整數定義而成的序列。它的描述如下：首項 $A_1$ 為一個正整數 $r\\ge 1$。對於 $n>1$，定義 $A_n = A_{n-1}+d$，其中 $d$ 是最小的正整數，使得對於任意 $1\\le i<j<n$，$d\\neq A_j-A_i$。此外 $d$ 也不能等於任意一個當前數列的值。給定 $r$ 以及 $m$ 值($1\\le r \\le 100, 1\\le m\\le 200000000$)，請找出最小的 $n$ 使得要嘛 $m=A_n$，或者 $m$ 是兩個 $\\set{A_1, \\ldots, A_n}$ 的數字差。\n","link":"https://ecna18.kattis.com/problems/difference","code":"ECNA2018B","difficulty":null,"oj":"kattis"},"htmlAst":{"type":"root","children":[],"data":{"quirksMode":false}}}},{"node":{"frontmatter":{"title":"Popping Balloons","category":"prob","path":"/problem/icpc/asia_jakarta_2018/F","date":"2019-01-03","_PARENT":"5d7d5a7e-8cee-5c6e-b03c-db47c102936e","description":"Ayu 和 Budi 正在一場類似 ICPC 的比賽上面決鬥。這樣的比賽題目總共有 $N$ 題，然而，參賽者比須按照指定順序依序解題。\n\nAyu 熟知她自己與 Budi 解每一題的能力，因此，Ayu 能夠事先得知兩個陣列 $A_{1, \\ldots, N}$ 以及 $B_{1, \\ldots, N}$，其中 $A_i$ 與 $B_i$ 分別表示 Ayu 和 Budi 解出第 $i$ 題所需要的時間。\n\n故事是這樣的，Ayu 知道 Budi 對突然的巨大聲響相當敏感，比方說當氣球爆炸的時刻。一旦 Budi 受到驚嚇，他手邊的工作就會立即停擺，而且當下解的題目必須**重頭開始**解。如果在恰好要解出一題的當下被嚇到，Budi 也得從頭開始才行。\n\nAyu 想利用這點勝過 Budi，她唯一能夠利用的，就是自己解出題目的當下所獲得的氣球。你可以假設 Ayu 一旦解出題目就可以立即獲得氣球，也可以立即戳破氣球（如果 Budi 同時即將解完，可憐的 Budi 就得重頭開始）。請問 Ayu 是否有戳氣球的策略使得在時間 $M$ 結束的當下，Ayu 解出的題數**嚴格大於** Budi 的呢？\n","link":"https://codeforces.com/gym/102001/problem/F","code":"ICPC-JAKARTA-2018-F","difficulty":6,"oj":"codeforces-gym"},"htmlAst":{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"題目敘述"}]},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"輸入的第一列包含兩個正整數 $N, M$ （$1\\le N\\le 100000; 1\\le M\\le 10^9$）依序代表題目的數量與比賽的時間長度。第二列包含 $N$ 個整數 $A_i$（$1\\le A_i\\le 10^9$），第三列包含 $N$ 個整數 $B_i$（$1\\le B_i\\le 10^9$）。"}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸出說明"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果不存在任何方法使得 Ayu 最終題數嚴格大於 Budi 的題數，輸出 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"-1"}]},{"type":"text","value":"。否則的話輸出一個整數 $K$，然後在第二列輸出 $K$ 個嚴格遞增的數字：Ayu 只要在這些時間點戳破氣球，就可以贏過 Budi。"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 1"}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"4 30\n9 10 10 10\n4 10 5 10\n"}]}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 1"}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"2\n12 19\n"}]}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 2"}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"5 50\n10 10 10 10 10\n15 12 19 17 20\n"}]}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 2"}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"0\n"}]}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 3"}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"5 10\n15 10 5 5 5\n9 10 10 10 10\n"}]}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 3"}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"-1\n"}]}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ 連結"}]},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://codeforces.com/gym/102001/problem/F"},"children":[{"type":"text","value":"Codeforces Gym 102001 - F"}]}]},{"type":"text","value":"\n"}]},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"俗話說得好："},{"type":"element","tagName":"s","properties":{},"children":[{"type":"text","value":"氣球恆久遠，一顆永流傳。"}]},{"type":"text","value":"如果 Ayu 在 Budi 解題目解到一半的時候戳破氣球嚇嚇他，倒不如多等一下，在 Budi 即將解出來的那剎那"},{"type":"element","tagName":"s","properties":{},"children":[{"type":"text","value":"說時遲那時快"}]},{"type":"text","value":"再把氣球戳破，讓 Budi 重來感覺豈不是更好嗎！"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"假設我們有個答案，那我們可以把 Budi 的解題心路歷程記錄下來，比方說（紅色的字代表被嚇到所以沒有解出該題）："}]},{"type":"text","value":"$$\nB_1, B_2, \\red{B_3}, \\red{B_3}, B_3, \\red{B_4}, B_4, B_5, ...\n$$"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果今天 $B_3 < B_4$，那麼 Ayu 總是可以再多等一下，讓 Budi 重做 $B_4$ 總是比重做 $B_3$ 賺更多！"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"以上的觀察引導我們使用「堆疊」的解法，去模擬 Ayu 的選擇，把得到的氣球花在 Budi 的哪些題目上頭。我們維護一個堆疊，從堆疊底部到頂部，永遠是「任務編號遞增、所花費時間嚴格遞減」並且紀錄有多少顆氣球花在這題上面。"}]},{"type":"element","tagName":"algorithm","properties":{},"children":[{"type":"text","value":"\n    "},{"type":"element","tagName":"generator","properties":{},"children":[{"type":"element","tagName":"pre","properties":{},"children":[{"type":"text","value":"\n        function*(input, ui) {\n            var B = input.B;\n            var C = input.C;\n            var n = B.length;\n            var s = [];\n            var show = function(stack) {\n                return stack.map((x) => `B[${x[0]}] = ${B[x[0]]}\\n重做=${x[1]}`);\n            };\n            var i, j;\n            for (i = 0; i < n; i++) {\n                s.push([i, C[i]]);\n                for (j = 0; j < s.length-1; j++) {\n                        ui.setStyleOnce('arr', `${j}`, {fill: 'lightyellow'});\n                        ui.setStyleOnce('B', `${s[j][0]}`, {fill: 'lightyellow'});\n                    }\n                ui.setStyleOnce('B', `${i}`, {fill: 'cyan'});\n                ui.setStyleOnce('arr', `${s.length-1}`, {fill: 'cyan'});\n                yield ({B: B, arr: show(s)});\n                while (s.length >= 2 &&\n                    B[s[s.length-1][0]] >=\n                    B[s[s.length-2][0]]) {\n                        s[s.length-2][1] += s[s.length-1][1];\n                        s[s.length-2][0] = s[s.length-1][0];\n                        s.pop();\n                    for (j = 0; j < s.length-1; j++) {\n                        ui.setStyleOnce('arr', `${j}`, {fill: 'lightyellow'});\n                        ui.setStyleOnce('B', `${s[j][0]}`, {fill: 'lightyellow'});\n                    }\n                    ui.setStyleOnce('B', `${i}`, {fill: 'cyan'});\n                    ui.setStyleOnce('arr', `${s.length-1}`, {fill: 'cyan'});\n                    yield ({B: B, arr: show(s)});\n                }\n            }\n            for (j = 0; j < s.length; j++) {\n                        ui.setStyleOnce('arr', `${j}`, {fill: 'lightyellow'});\n                        ui.setStyleOnce('B', `${s[j][0]}`, {fill: 'lightyellow'});\n                    }\n            return {B: B, arr: show(s)};\n        }\n        "}]},{"type":"text","value":"\n    "}]},{"type":"text","value":"\n    "},{"type":"element","tagName":"inputdata","properties":{"data":"{\"B\": [8, 10, 5, 3, 1, 9, 6, 7, 4, 2],\n               \"C\": [1, 1, 2, 1, 0, 1, 0, 0, 1, 2]}"},"children":[]},{"type":"text","value":"\n    "},{"type":"element","tagName":"indirectdisplay","properties":{"array":"","fixedwidth":"","minwidth":"30","highlightdiff":"","varname":"B"},"children":[]},{"type":"text","value":"\n    "},{"type":"element","tagName":"indirectdisplay","properties":{"array":"","fixedwidth":"","n":"5","minwidth":"30","highlightdiff":"","varname":"arr"},"children":[]},{"type":"text","value":"\n"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n  int N, M;\n  cin.sync_with_stdio(false);\n  cin >> N >> M;\n  vector<long long> A(N), B(N);\n\n  for (int i = 0; i < N; i++) cin >> A[i];\n  for (int i = 0; i < N; i++) cin >> B[i];\n\n  // 先算出 Ayu 拿到每顆氣球的時間點，並算出 Ayu 可以解幾題。\n  int nsolved = 0;\n  for (int i = 1; i < N; i++) A[i] += A[i - 1];\n  for (int i = 0; i < N; i++) nsolved += (A[i] <= M);\n\n  // 我們目標就是要讓 Budi 解出第 nsolved 的時間嚴格大於 M。\n  long long t = 0;\n  vector<pair<int, int>> stack;\n  for (int i = 0, j = 0; i < nsolved; i++) {\n    int balloons = 0;\n    while (!stack.empty() && B[stack.back().first] <= B[i]) {\n      balloons += stack.back().second;\n      t -= stack.back().second * B[stack.back().first];\n      stack.pop_back();\n    }\n    t += B[i] * (balloons + 1);\n    while (j < nsolved && A[j] <= t) {\n      ++j;\n      ++balloons;\n      t += B[i];\n    }\n    stack.push_back(make_pair(i, balloons));\n  }\n\n  // 如果還是在 M 分鐘內解出來了，就輸出 -1。\n  if (t <= M) {\n    cout << \"-1\" << endl;\n    return 0;\n  }\n\n  // 計算每顆氣球被戳破的時間。\n  t = 0;\n  int j = 0;\n  vector<long long> ans;\n  for (auto [i, b] : stack) {\n    while (j < i) t += B[j++];\n    for (int l = 0; l < b; l++)\n      ans.push_back(t += B[i]);\n  }\n\n  // 輸出答案。\n  while (!ans.empty() && ans.back() > M) ans.pop_back();\n  cout << ans.size() << endl;\n  for (auto x : ans) cout << x << \" \";\n  cout << endl;\n  return 0;\n}\n"}]}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"關於競程日記"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"🍅 如果您想到更多有趣漂亮簡單乾淨的解法話歡迎留言給競程日記小編群！"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"ℹ️ 這是一篇投稿給"},{"type":"element","tagName":"a","properties":{"href":"https://www.facebook.com/%E7%AB%B6%E7%A8%8B%E6%97%A5%E8%A8%98-1514973425463954/"},"children":[{"type":"text","value":"競程日記"}]},{"type":"text","value":"的文章，歡迎大家投稿、交流與分享程式解題競賽的點點滴滴！"}]}]}}}]}}}