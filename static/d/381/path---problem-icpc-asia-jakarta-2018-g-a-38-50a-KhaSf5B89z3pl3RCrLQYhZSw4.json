{"data":{"markdownRemark":{"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"簡化後題目敘述"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸出說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果不存在任何方法使得 Ayu 最終題數嚴格大於 Budi 的題數，輸出 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"-1"}]},{"type":"text","value":"。否則的話輸出一個整數 $K$，然後在第二列輸出 $K$ 個嚴格遞增的數字：Ayu 只要在這些時間點戳破氣球，就可以贏過 Budi。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"4 3\n1 2\n2 3\n3 4\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"3\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"5 0\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"0\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 3"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"5 2\n1 2\n3 4\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 3"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"2\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ 連結"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://codeforces.com/gym/102001/problem/G"},"children":[{"type":"text","value":"Codeforces Gym 102001 - G"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這題可以用枚舉法的概念，對於每一個 $k$ 值判斷是否存在一個加入邊的序列滿足條件。演算法如下："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"把所有滿足 $\\delta_x+\\delta_y\\ge k$ 但不在圖上的邊蒐集起來，加入一個佇列 $Q$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"只要佇列非空，抓一條佇列中的邊 $(x, y)$，把它加入圖中；掃過一次所有與點 $x$ 和點 $y$ 相鄰的所有不在圖上的邊，並判斷是否能夠把它們加入佇列。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"如果最終所有的邊都被加入了佇列，就代表這個 $k$ 值是個成功的 $k$ 值。反之則不行：在任意時刻加不進佇列的邊永遠度數和小於 $k$。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"以上的演算法的第一步會花 $O(N^2)$ 時間掃過所有點對。\n第二步可能會考慮 $O(N^2)$ 個點對、而每一條邊加入後會花 $O(N)$ 時間掃過相鄰的不在圖上的邊，因此第二步所花時間是 $O(N^3)$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"不難發現只要 $k$ 是答案，$k-1$ 也會是答案。於是我們可以對 $k$ 進行二分搜尋法，找到滿足條件的最大 $k$ 值。時間複雜度 $O(N^3\\log N)$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"但事實上二分搜尋法是不必要的。對於某個 $k$，若第二步完成後，還有邊沒有被加入圖上，那麼我們把 $k\\gets k-1$ 時，剛才那些已經加入的邊，顯然可以依照同樣順序被加入圖上。因此，我們只需要重新對剩下的邊跑過上述演算法即可。注意到最大可能的 $k$ 為 $(N-2)+(N-2)$，第一步可能要重新跑 $O(N)$ 次，因此總花費時間是 $O(N^3)$，第二步每一條邊仍然只會被加入到佇列至多一次，所以也還是 $O(N^3)$。我們就得到一個 $O(N^3)$ 的乾淨算法啦～"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"#include <algorithm>\n#include <iostream>\n#include <queue>\nusing namespace std;\n\nint a[505][505];\nint deg[505];\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n  for (int i = 0; i < m; i++) {\n    int x, y;\n    cin >> x >> y;\n    a[x][y] = a[y][x] = 1;\n    deg[x]++;\n    deg[y]++;\n  }\n  int k;\n  for (k = 2 * (n - 2); k >= 0; k--) {\n    queue<pair<int, int>> q;\n    // 第一步\n    for (int x = 1; x <= n; x++)\n      for (int y = x + 1; y <= n; y++)\n        if (!a[x][y] && deg[x] + deg[y] >= k) {\n          q.push({x, y});\n        }\n    // 第二步\n    while (!q.empty()) {\n      auto [x, y] = q.front();\n      q.pop();\n      if (a[x][y]) continue;\n      m++;\n      a[x][y] = a[y][x] = 1;\n      deg[x]++;\n      deg[y]++;\n      for (int z = 1; z <= n; z++) {\n        if (x != z && !a[x][z] && deg[x] + deg[z] >= k) q.push({x, z});\n        if (y != z && !a[y][z] && deg[y] + deg[z] >= k) q.push({y, z});\n      }\n    }\n    // 第三步\n    if (m >= n * (n - 1) / 2) break;\n  }\n  cout << k << endl;\n  return 0;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"關於競程日記"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"🍅 如果您想到更多有趣漂亮簡單乾淨的解法話歡迎留言給競程日記小編群！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"ℹ️ 這是一篇投稿給"},{"type":"element","tagName":"a","properties":{"href":"https://www.facebook.com/%E7%AB%B6%E7%A8%8B%E6%97%A5%E8%A8%98-1514973425463954/"},"children":[{"type":"text","value":"競程日記"}]},{"type":"text","value":"的文章，歡迎大家投稿、交流與分享程式解題競賽的點點滴滴！"}]}],"data":{"quirksMode":false}},"frontmatter":{"date":"January 04, 2019","path":"/problem/icpc/asia_jakarta_2018/G","title":"Go Make It Complete","description":"d\n","roadmap_label_h3":null,"backlink":"/icpcblog-weekly-2019"}}},"pageContext":{}}