{"data":{"markdownRemark":{"htmlAst":{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我們說圖 $G$ 上的一個點的子集合 $S\\subseteq V$ 是獨立集（Independent Set），若且唯若 $G[S]$ 沒有任何邊。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"透過直接的觀察可以得知，$S$ 在 $G$ 上是一個獨立集，等價於 $\\overline{G}[S]$ 是一個完全子圖，其中 $\\overline{G}$ 是 $G$ 的"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"補圖"}]},{"type":"text","value":"（Complement Graph）。從這個觀察也可以知道，如果我們要列舉出所有極大獨立集（Maximal Independent Set, MIS），那麼所有適用於前一節找 Maximal Clique 的演算法也通通都適用於此。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"相對應地，我們令 $\\alpha(G)$ 表示為圖 $G$ 上最大獨立集的大小。"}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"§8.1 關於 $\\alpha(G)$ 的估計"}]},{"type":"element","tagName":"theorem","properties":{"title":"哼哼"},"children":[{"type":"text","value":"\n"}]},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"§8.2 找出最大獨立集"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"顯然枚舉所有點的子集合逐一檢查可以做到 $O(n^2 2^n)$、利用前一節列舉極大完全子圖所需要的時間為 $O(3^{n/3})\\approx O(1.4422^n)$。在此我們提供一個坊間謠傳的簡單暴搜方法："}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果一個圖 $G$ 的最大度數 $\\Delta(G) \\le 2$，那麼顯然這個圖是由很多路徑和圈構成的。此時我們可以在多項式時間內找出最大獨立集。因此我們不妨假設所有遞迴中遇到的子問題，其最大度數都是 $\\ge 3$。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"DFS 的方法如下：我們每次選取當前圖上度數最大的點 $v$，由於前面的假設我們知道 $\\deg(v) \\ge 3$。接下來，透過簡單的觀察可以知道：一個最大的獨立集要嘛包含 $v$ 但是不包含任何 $v$ 的鄰居 $\\Gamma(v)$（一個遞迴呼叫 $G-\\set{v}-\\Gamma(v)$）、要嘛就不包含 $v$（另一個遞迴呼叫 $G-\\set{v}$）。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"因此可以直接將時間複雜度的上界寫下來："}]},{"type":"text","value":"$$\nT(n) \\le T(n-1) + T(n-4) + \\text{poly}(n)\n$$"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"有一點點像 Master Theorem 的感覺，這類型的遞迴關係是有一些簡單的方法可以輕鬆推導出時間複雜度的。我們不妨假設有個實數常數 $c$ 使得 $T(n) = c^n$。只要 $c$ 滿足\n$c^3 + 1 < c^4$\n就可以讓上面的遞迴式成立了。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"透過解方程式，我們可以知道選取 $c\\approx 1.3803$ 能夠滿足條件。因此我們證得上述演算法時間複雜度為 $O(1.3803^n)$。把這個方法延伸，考慮更多的 case （度數 3, 4, 5 的點等等），就會得到 Tarjan [1977] 這篇論文的 $O(1.2599^n)$ 的上界。考慮更多更多更多的 case （度數 1~9 的點等等），再加上一些記憶化搜索的技巧就會得到 Robson [2001] 這篇論文的 $O(1.1888^n)$ 時間複雜度了。下面介紹兩個被用在 Robson 演算法裡面的加速技巧，這些技巧被廣泛應用在其他題目中，以後我們有機會碰到也會再次提及。"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"加速技巧 1：Indirection"}]},{"type":"element","tagName":"note","properties":{},"children":[{"type":"text","value":"\n當子問題大小（遞迴得到的誘導子圖點數）不超過 $\\delta n$ 的時候，可以直接用動態規劃紀錄下答案。\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"一個有 $n$ 個點的圖，其點數不超過 $\\delta n$ 的誘導子圖，數量不超過 ${n\\choose {\\delta n}}$ 個。使用 Strling's Formula 這個值算起來大概是 $\\left(\\frac{1}{\\delta^\\delta (1-\\delta)^{1-\\delta}}\\right)^n$。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"假設最原始的圖有 $N$ 個點，把這個方法代入原本的遞迴式以後，所有的遞迴動作會在 $n < \\delta N$ 的時候中止。因此撇開動態規劃的時間不算，等效的遞迴時間複雜度是 $T(N-\\delta N) = c^{(1-\\delta)N}$。"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"加速技巧 2：Memoization"}]},{"type":"element","tagName":"note","properties":{},"children":[{"type":"text","value":"\n當子問題的所有的點度數夠小的時候，可以用動態規劃紀錄下答案。可以證明此情形下**所有的**誘導子圖總數量不多。\n"}]},{"type":"element","tagName":"theorem","properties":{"title":"Fuss-Catalan Numbers [Robson 1985; Concrete Math]"},"children":[{"type":"text","value":"\n對於一個度數不超過 8 的圖 $G$，其包含 $\\delta n$ 個點的連通誘導子圖的數量不超過 $\\text{poly}(n)(7^76^{-6})^{\\delta n}$ 個。\n"}]},{"type":"element","tagName":"h4","properties":{},"children":[{"type":"text","value":"證明"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"固定一個圖 $G$ 的"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"連通"}]},{"type":"text","value":"誘導子圖，我們可以從任意一個點出發，畫出一棵 BFS 樹。顯然不同的誘導子圖（點集合不同）會造出不同的 BFS 樹。所以誘導子圖 $\\leftrightarrow$ BFS 樹是一個一對多（1-to-many）的關係。只要我們給出所有這樣的 BFS 樹的數量上界，就能夠說明誘導子圖數量的上界。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"根據題目條件，每個點度數不超過 8。因此除了根節點以外，其他的點的子節點數量都不超過 7。根據 Fuss-Catalan 公式，這樣子的樹會有 $\\text{poly}(n){7n\\choose n}$ 左右。（註：可參考 OEIS "},{"type":"element","tagName":"a","properties":{"href":"http://oeis.org/A002296%EF%BC%89"},"children":[{"type":"text","value":"http://oeis.org/A002296）"}]}]},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"上面這個定理要怎麼用來加速呢？如果我們只紀錄「點的總數不超過 $\\delta n$、並且該連通誘導子圖上所有點度數都不超過 8」的圖，那麼這樣的誘導子圖的總數不會超過 $\\text{poly}(n){{7\\delta n} \\choose {\\delta n}}\\approx \\text{poly}(n)(7^76^{-6})^{\\delta n}$。當 "},{"type":"element","tagName":"a","properties":{"href":"https://www.wolframalpha.com/input/?i=((7%5E7%2F(6%5E6))%5Ex)*(x%5Ex)*((1-x)%5E(1-x))+%3D+1"},"children":[{"type":"text","value":"$\\delta \\le  1/7$ 的時候"}]},{"type":"text","value":"，用這個方法會比第一種技巧需要的狀態總數來得少。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"存在度數超過 8 的點的時候怎麼辦？這時候只要用老樣子遞迴就行啦～$T(n) = T(n-1) + T(n-9) + \\text{poly}(n)$ 解出來大概是 $(1.2132)^n$，只要我們選擇的 $\\delta$ 不要太小，就可以讓 $(7^76^{-6})^{\\delta n}$ 這項涵蓋這個遞迴。"}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"習題"}]},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"span","properties":{"className":["tag","is-dark"]},"children":[{"type":"text","value":"證明題"}]},{"type":"text","value":" 利用「度數為 2 的點可以忽略不計」這個觀察，證明上述演算法的另一種分析方式："}]},{"type":"text","value":"\n"}]},{"type":"text","value":"$$\nT(n) \\le \\begin{cases}\nT(n-1)+T(n-5) + \\text{poly}(n)\\\\\n2T(n-4)+ \\text{poly}(n)\n\\end{cases}\n$$"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"而得出 $T(n) = O(1.3247^n)$ 的結論。"}]}]},"frontmatter":{"date":"March 06, 2019","path":"/algo/algorithmic-graph-theory/independent-sets","title":"圖論演算法 8 - 獨立集 Independent Sets","description":null,"roadmap_label_h3":null,"backlink":null}}},"pageContext":{}}