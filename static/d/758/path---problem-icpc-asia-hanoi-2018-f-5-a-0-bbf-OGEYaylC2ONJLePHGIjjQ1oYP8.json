{"data":{"markdownRemark":{"htmlAst":{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"簡化後題目敘述"}]},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"輸入的第一列包含一個正整數 $T$ ($1\\le T\\le 10^5$) 代表測試資料組數。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"接下來有 $T$ 列，每一列為一組測試資料，包含三個正整數 $n, k, p$（$1\\le n, k\\le 10^{18}, 1\\le p\\le 10^6$）。"}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ 連結"}]},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://open.kattis.com/problems/funwithfibonacci"},"children":[{"type":"text","value":"Open Kattis - Fun with Fibonacci"}]}]},{"type":"text","value":"\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"題目出處"}]},{"type":"text","value":"：ICPC 2018 Asia Hanoi Regional"}]},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"今天是數論小教室。看到這題範圍這麼大，其中必定有炸。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這題真的很難。而且是你真的要對費氏數列有所認識的那種難。看到計算費氏數列除以 $p$ 的餘數（注意這裡 $p$ 不是質數唷），就"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"應該"}]},{"type":"text","value":"要想到費氏數列模 $p$ 的循環節長度是 $O(p)$ 的！是不是很 OP！"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"而事實上，我們可以利用以下定理刻劃出費氏數列模 $p$ 的循環節長度："}]},{"type":"element","tagName":"theorem","properties":{"title":"費氏數列的循環節"},"children":[{"type":"text","value":"\n設 $p$ 為質數。則：\n* 當 $p=5$ 的時候 $F_{20} \\equiv 0, F_{21}\\equiv 1 \\pmod 5$。\n    * 這保證了循環節長度整除 $20$。\n* 當 $p\\equiv \\pm 1 \\pmod 5$ 的時候 $F_{p-1} \\equiv 0, F_{p}\\equiv 1 \\pmod 5$。\n    * 這保證了循環節長度整除 $p-1$。\n* 當 $p\\equiv \\pm 2 \\pmod 5$ 的時候 $F_{2p+2}\\equiv 0, F_{2p+3}\\equiv 1 \\pmod 5$。\n    * 這保證了循環節長度整除 $2p+2$。\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"然後經過努力推敲一下，可以推得對任意正整數 $r$，模 $p^r$ 的時候，循環節長度整除： $p^{r-1} \\times (\\text{模$p$的循環節長度})$。再根據中國剩餘定理用力觀察一下，就可以知道把一個正整數拆成許多質因數的次方積，每一個部份的循環節長度之最小公倍數（LCM）就是我們要的答案。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"上面這個定理的證明可以在"},{"type":"element","tagName":"a","properties":{"href":"https://www.math.arizona.edu/~ura-reports/071/Campbell.Charles/Final.pdf"},"children":[{"type":"text","value":"這裡"}]},{"type":"text","value":"找到唷（我不太喜歡他的證明，有些地方定義不是很清楚的感覺。之後找到更好的再換掉。）"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"有了這個以後，就可以真真正正地開始 "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Fun With Fibonacci"}]},{"type":"text","value":" 了。"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"把循環節往下丟"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"對於任意正整數 $p$，我們令函數 $f(p)$ 表示循環節大小。首先我們可以做出以下觀察：\n$G(i, n) \\bmod p = F_{G(i-1, n)} \\bmod p = F_{G(i-1, n)\\bmod f(p)} \\bmod p$。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我們可以把這個寫成遞迴關係，透過解決 $G(i-1, n)$ 回頭解 $G(i, n)$。這個遞迴最終得跑過 $k$ 次，基本上是個 $k=1000000000000000000$ 次的概念。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"經過了今天大量 TLE 的洗禮，我觀察到了以下幾個很酷炫的點："}]},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"$p, f(p), f(f(p)), f(f(f(p))), \\ldots$ 這個序列非常快就進入循環了。而且，只要 3~4 步以後就會跑到"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"不動點"}]},{"type":"text","value":"！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"大部分的不動點 $p$（i.e. $f(p)=p$），都是 $2^4\\times 3\\times 5^8$ 的因數。"}]},{"type":"text","value":"\n"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"處理不動點"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"好的，現在問題變成了處理 $F_{F_{F_{F_n}}} \\bmod p$...，而好消息是我們總可以把 $\\bmod p$ 往註標裡面丟。"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"今天的程式碼真的非常非常傷眼。我以後有空再把它淨化一下（淚）"}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\nconst int N = 2000005;\nvector<bool> sieve(N);\nvector<int> primes;\n\nconst int VS = 18750000;\nint special[18750000];\n\nstruct Matrix {\n  LL a[2][2];\n  Matrix(LL A = 1, LL B = 0, LL C = 0, LL D = 1) {\n    a[0][0] = A;\n    a[0][1] = B;\n    a[1][0] = C;\n    a[1][1] = D;\n  }\n  Matrix operator % (const LL mod) const {\n    LL P = a[0][0]%mod;\n    LL Q = a[0][1]%mod;\n    LL R = Q;\n    LL S = a[1][1]%mod;\n    return Matrix(P, Q, R, S);\n  }\n  Matrix operator *(const Matrix m) const {\n    LL P = a[0][0] * m.a[0][0] + a[0][1] * m.a[1][0];\n    LL Q = a[0][0] * m.a[0][1] + a[0][1] * m.a[1][1];\n    LL R = Q;\n    LL S = a[1][0] * m.a[0][1] + a[1][1] * m.a[1][1];\n    return Matrix(P, Q, R, S);\n  }\n};\n\nMatrix MatrixPowerMod(Matrix A, LL n, LL mod) {\n  if (n == 0) return Matrix() % mod;\n  if (n == 1) return A % mod;\n  Matrix B = Matrix();\n  while (n > 0) {\n    if (n%2) B = B * A % mod;\n    A = A * A % mod;\n    n/=2;\n  }\n  return B;\n}\n\nLL Fib(LL n, LL mod) {\n  if (VS % mod == 0) return special[n] % mod;\n\n  Matrix A(1, 1, 1, 0);\n  A = MatrixPowerMod(A, n, mod);\n  return A.a[0][1];\n}\n\nLL GCD(LL x, LL y) {\n  while ((x%=y) && (y%=x));\n  return x+y;\n}\n\nLL LCM(LL x, LL y) {\n  return x / GCD(x, y) * y;\n}\n\nLL GetPrimePeriod(LL p, int k) {\n  LL result = 0;\n\n  if (p == 5) {\n    LL t = 20;\n    LL w = t; while(--k) w *= p;\n    return (result = w);\n  } else if (p%5 == 1 || p%5 == 4) {\n    LL N = 1; for(int _=0;_<k;_++) N*=p;\n    LL w = p-1; while(--k) w *= p;\n    return (result = w);\n  } else {\n    LL N = 1; for(int _=0;_<k;_++) N*=p;\n    LL w = 2*p+2; while(--k) w *= p;\n    return (result = w);\n  }\n}\n\nLL GetPeriod(LL m) {\n  LL t = 1;\n  LL copy = m;\n  for (int j = 0; primes[j] * primes[j] <= copy; j++) {\n    LL p = primes[j];\n    if (copy % p == 0) {\n      int power = 0;\n      do {\n        copy /= p;\n        ++power;\n      } while (copy % p == 0);\n      \n      t = LCM(t, GetPrimePeriod(p, power));\n    }\n  }\n  if (copy > 1) {\n   t = LCM(t, GetPrimePeriod(copy, 1));\n  }\n  return t;\n}\n\nvoid PreCompute() {\n  for (int i = 2; i <= 20000; i++) {\n    if (!sieve[i]) {\n      for (int j = i*i; j < N; j+=i)\n        sieve[j] = true;\n    }\n  }\n  for (int i = 2; i < N; i++)\n    if (!sieve[i])\n      primes.push_back(i);\n}\n\nLL pp;\nunordered_map<LL, int> pindex;\nunordered_map<LL, pair<int, int>> cycindex[128];\nvector<vector<LL>> bigcycles[128];\nint u[9375000];\nint idx[9375000] = {}, ucnt;\n\nLL getans(LL n, LL k, LL p) {\n  if (k == 1) {\n    return Fib(n, p);\n  }\n  LL next_period = GetPeriod(p);\n  if (p == next_period) {\n\n    if (pindex.find(p) == pindex.end()) {\n      int newidx = pindex.size();\n      pindex[p] = newidx;\n    }\n    int pidx = pindex[p];\n\n    vector<LL> g;\n    \n    ++ucnt;\n\n    n %= p;\n    g.push_back(n);\n    idx[n] = 0;\n    u[n] = ucnt;\n\n    for (LL i = 1; i <= k; i++) {\n      n = Fib(n, p);\n      if (cycindex[pidx].find(n) != cycindex[pidx].end()) {\n        auto [cidx, at] = cycindex[pidx][n];\n        vector<LL> &cycle = bigcycles[pidx][cidx];\n        int length = cycle.size();\n        i += (k-i)/length*length;\n        return cycle[ (k-i+at) % length ];\n      }\n      \n      //if (idx.find(n) != idx.end()) {\n      if (u[n] == ucnt) {\n        // found! from idx[n] to i-1.\n        int length = i - idx[n];\n\n        if (i>=10000 || length >=10000)\n        cerr << \"(pp=\" << pp << \") Found a cycle of length \" << length  << \" at index \" << i << endl;\n        if (length >= 1000) {\n          // Memorize it.\n          int cidx = bigcycles[pidx].size();\n          vector<LL> cycle;\n          for (int j = idx[n]; j < i; j++) {\n            cycle.push_back(g[j]);\n            cycindex[pidx][g[j]] = {cidx, j-idx[n]};\n          }\n          bigcycles[pidx].push_back(cycle);\n        }\n\n        i += (k-i)/length*length;\n        return g[idx[n] + k-i];\n      } else {\n        g.push_back(n);\n        idx[n] = i;\n        u[n] = ucnt;\n      }\n    }\n    return n;\n  }\n  LL t = getans(n, k-1, next_period);\n  return Fib(t, p);\n}\n\nvoid solve() {\n  LL n, k, p;\n  cin >> n >> k >> p;\n  LL t = getans(n, k, p);\n  cout << t << '\\n';\n}\n\nvoid PreTest() {\n  for(LL p = 2; p <= 1000000; p++) {\n    pp = p;\n    getans(576460752303423487LL, 576460752303423487LL, p);\n  }\n}\n\nvoid PreTwo() {\n  LL mod = VS;\n  special[0] = 0;\n  special[1] = 1;\n  for(int i=2;i<mod;i++) {\n    special[i] = (special[i-1]+special[i-2]);\n    if(special[i] >= mod) special[i] -= mod;\n  }\n}\n\nint main() {\n  PreCompute();\n  PreTwo();\n  // PreTest();\n  int T;\n  cin >> T;\n  while(T--) solve();\n  return 0;\n}\n"}]}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"夢月說"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這題應該要 150 行以內寫完才高竿啊。"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"關於競程日記"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"🍅 如果您想到更多有趣漂亮簡單乾淨的解法話歡迎留言給競程日記小編群！"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"ℹ️ 這是一篇投稿給"},{"type":"element","tagName":"a","properties":{"href":"https://www.facebook.com/%E7%AB%B6%E7%A8%8B%E6%97%A5%E8%A8%98-1514973425463954/"},"children":[{"type":"text","value":"競程日記"}]},{"type":"text","value":"的文章，歡迎大家投稿、交流與分享程式解題競賽的點點滴滴！"}]}]},"frontmatter":{"date":"January 13, 2019","path":"/problem/icpc/asia_hanoi_2018/F","title":"Fun with Fibonacci","description":"費氏數列的遞迴定義如下：\n\n$$ F_n = F_{n-1} + F_{n-2} $$\n\n初始條件為 $F_0=0, F_1=1$。這個數列的首幾項為 0, 1, 1, 2, 3, 5, 8, 13, 21, ...\n\n我們現在定義誇張版的費氏數列\n\n* 定義 $G(1, n)$ 為第 $n$ 個費氏數列。\n* 定義 $G(2, n) = G(1, G(1, n))$。\n* 對於任意正整數 $i$，定義 $G(i, n) = G(1, G(i-1, n))$。\n\n給定 $n, k, p$，請你計算 $G(k, n)\\bmod p$ 之值。\n","roadmap_label_h3":null,"backlink":"/icpcblog-weekly-2019"}}},"pageContext":{}}