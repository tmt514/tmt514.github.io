{"data":{"markdownRemark":{"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"簡化後題目敘述"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸出說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"abca\nbc cd da dd ee ff gg hh ii jj kk ll mm\nnn oo pp qq rr ss tt uu vv ww xx yy zz\n1\n2\n1 8\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"b\nc\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"ab\nba ab cc dd ee ff gg hh ii jj kk ll mm\nnn oo pp qq rr ss tt uu vv ww xx yy zz\n2\n2\n1 8\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"a\nb\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ 連結"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://open.kattis.com/problems/prolongedpassword"},"children":[{"type":"text","value":"Open Kattis - Prolonged Password"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"題目出處"}]},{"type":"text","value":"：ICPC 2018 Asia Singapore Regional"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我們可以把函數 $f$ 迭代的過程展開成樹狀圖。而依照順序遍歷葉節點的時候，就相當於把最終的密碼 $P$ 印出來。如果要取得第 $m_i$ 個字元，那麼我們要找的便是由左至右數來第 $m_i$ 個葉子。下圖是第一筆範例以字母 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"a"}]},{"type":"text","value":" 開頭展開三層的樣子。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"display","properties":{"binaryTree":"","complete":"","depth":"4","data":"{\n        value: [\"a\", \"b\", \"c\", \"c\", \"d\", \"d\", \"a\", \"d\", \"a\", \"d\", \"d\", \"d\", \"d\", \"b\", \"c\"]\n    }"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"在程式碼中，我們使用了一些小撇步（不見得是必要的，但總之我是這樣寫了...）。比方說，我們把四個方向定義成左右一組、上下一組，這麼一來要存取"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"反方向"}]},{"type":"text","value":"的時候，只要透過 XOR 1 就可以了(比方說 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"dir^1"}]},{"type":"text","value":")。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXB = 400005;\nint r[MAXB], c[MAXB];\n\nconst vector<string> DSTR = {\">\", \"<\", \"v\", \"^\"};\nstring s[MAXB];\nint face[MAXB];\nint visit[MAXB];\nint link[MAXB][4];\nvector<pair<int, int>> rows[MAXB], cols[MAXB];\n\n// 定義四個方向。\nenum {\n  LEFT = 0,\n  RIGHT = 1,\n  UP = 2,\n  DOWN = 3\n};\n\ninline bool IsNeighbor(int x, int y) {\n  return abs(r[x]-r[y]) + abs(c[x]-c[y]) == 1;\n}\n\nvoid dfs(int x) {\n  visit[x] = 1;\n  for (int dir = 0; dir < 4; dir++) {\n    int y = link[x][dir];\n    if (IsNeighbor(x, y) && !visit[y]) {\n      face[y] = (dir^1);\n      s[y] = DSTR[dir] + \" \" + to_string(dir/2? c[y]: r[y]);\n      dfs(y);\n    }\n  }\n}\n\n// 紀錄優先順序 (得先有 y 才能有 x)。\nvector<int> deps[MAXB];\ninline void AddLink(int x, int y) {\n  if (x == -1 || y == -1) return;\n  deps[x].push_back(y);\n}\n\n// 紀錄解答用的。\nvector<int> solution;\nbool no_solution = false;\nvoid topological_sort(int x) {\n  visit[x] = 1;\n  for (auto y : deps[x]) {\n    if (visit[y] == 0)\n      topological_sort(y);\n    else if (visit[y] == 1)\n      no_solution = 1;\n  }\n  solution.push_back(x);\n  visit[x] = 2;\n}\n\nint main() {\n  int N, M, B;\n  cin >> N >> M >> B;\n  for (int i = 0; i < B; i++) {\n    cin >> r[i] >> c[i];\n    rows[r[i]].push_back({c[i], i});\n    cols[c[i]].push_back({r[i], i});\n  }\n  for (int i = 1; i < MAXB; i++) {\n    sort(rows[i].begin(), rows[i].end());\n    sort(cols[i].begin(), cols[i].end());\n  }\n\n  memset(link, -1, sizeof(link));\n  for (int i = 1; i < MAXB; i++) {\n    for (size_t j = 1; j < rows[i].size(); j++) {\n      int prev = rows[i][j-1].second;\n      int now = rows[i][j].second;\n      link[prev][RIGHT] = now;\n      link[now][LEFT] = prev;\n    }\n    for (size_t j = 1; j < cols[i].size(); j++) {\n      int prev = cols[i][j-1].second;\n      int now = cols[i][j].second;\n      link[prev][DOWN] = now;\n      link[now][UP] = prev;\n    }\n  }\n  dfs(0);\n  for (int x = 1; x < B; x++) {\n    AddLink(x, link[x][face[x]]);\n    AddLink(link[x][face[x]^1], x);\n  }\n  memset(visit, 0, sizeof(visit));\n  for (int x = 0; x < B; x++) {\n    if (!visit[x])\n      topological_sort(x);\n  }\n  if (no_solution) {\n    cout << \"impossible\" << endl;\n  } else {\n    cout << \"possible\" << '\\n';\n    for (auto x : solution)\n      if (x != 0)\n        cout << s[x] << '\\n';\n  }\n  return 0;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"關於競程日記"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"🍅 如果您想到更多有趣漂亮簡單乾淨的解法話歡迎留言給競程日記小編群！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"ℹ️ 這是一篇投稿給"},{"type":"element","tagName":"a","properties":{"href":"https://www.facebook.com/%E7%AB%B6%E7%A8%8B%E6%97%A5%E8%A8%98-1514973425463954/"},"children":[{"type":"text","value":"競程日記"}]},{"type":"text","value":"的文章，歡迎大家投稿、交流與分享程式解題競賽的點點滴滴！"}]}],"data":{"quirksMode":false}},"frontmatter":{"date":"January 19, 2019","path":"/problem/icpc/asia_singapore_2018/I","title":"Prolonged Password","description":"","roadmap_label_h3":null,"backlink":"/icpcblog-weekly-2019"}}},"pageContext":{}}