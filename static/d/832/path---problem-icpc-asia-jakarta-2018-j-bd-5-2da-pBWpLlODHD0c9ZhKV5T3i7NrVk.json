{"data":{"markdownRemark":{"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"簡化後題目敘述"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"第一列包含一個正整數 $N$ ($1\\le N\\le 15$)。第二列開始有 $N$ 列，每一列包含一個僅由大寫字母組成的字串 $S_i$ ($1\\le |S_i|\\le 15$)\n。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸出說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"輸出最大的 $|A_1|+|A_2|+\\cdots + |A_N|$ 之值。若無解的話要輸出 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"-1"}]},{"type":"text","value":"。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"3\nKARIM\nPARBUDI\nCHANDRA\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"16\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"2\nZORO\nANDI\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"-1\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 3"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"7\nHAVE\nFUN\nIN\nICPC\nJAKARTA\nTWENTY\nEIGHTEEN\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 3"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"25\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ 連結"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://codeforces.com/gym/102001/problem/J"},"children":[{"type":"text","value":"Codeforces Gym 102001 - J"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"總之就是很直白的動態規劃囉。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"對於所有 $i$，我們可以先把所有 $S_i$ 的子序列列出來，並且排序好。假設這樣的子序列有 $m_i$ 個（不難得知 $m_i < 2^{|S_i|}$），我們令這樣的序列為 $S_i^{(0)} < S_i^{(1)} < \\cdots < S_i^{(m_i-1)}$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"定義 $\\dp[i][j]$ 為作到第 $i$ 個字串且選取 $A_i \\le S_i^{(j)}$ 的時候，$|A_1|+\\cdots + |A_i|$ 可能的最大值。此時我們可以列出遞迴式："}]},{"type":"text","value":"\n$$\n\\dp[i][j] = \\begin{cases}\n\\max_{k:\\ S_{i-1}^{(k)} < S_i^{(j)}} \\left\\{ \\dp[i-1][k] + |S|\\right\\} \\\\\n\\dp[i][j-1] & \\text{考慮結束在字典順序更小的情形。}\n\\end{cases}\n$$\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"注意到此時 $\\dp[i][0], \\dp[i][1], \\ldots$ 這是一個非遞減的序列。因此要讓 $\\dp[i-1][k] + |S|$ 的值最大，就等價於讓 $k$ 的值盡量大！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"實作上由於 $j$ 變大的時候，對應的 $k$ 也非遞減，我們可以利用 two pointer 的技巧，維護 $j$ 和 $k$ 兩個足標。在 $O(|S_i|\\times 2^{|S_i|})$ 的時間更新一整排的 $\\dp[i][0, \\ldots, m-1]$ 值（在兩個足標追趕的過程中，由於每次都是比較兩個字串，所以需要花 $O(|S_i|)$ 的時間推進一個足標）。因此整體時間複雜度為 $O(\\sum_{1\\le i\\le N} |S_i| 2^{|S_i|}) \\approx O(15^2\\times 2^{15})$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring S[15];\nvector<string> a[15];\nint dp[15][1<<15];\n\n// 產生一個字串的所有子序列。\nvoid GetAllSubstrings(string s, vector<string>& result) {\n  result.push_back(\"\");\n  for (int i = 0; i < (int)s.size(); i++) {\n    int n = result.size();\n    for (int j = 0; j < n; j++) {\n      result.push_back(result[j]+s[i]);\n    }\n  }\n  // 把找到的子序列依照字典順序排序，注意這邊 result[0] 會是空字串。\n  sort(result.begin(), result.end());\n}\n\nint main() {\n  int N;\n  cin >> N;\n  for (int i = 0; i < N; i++) cin >> S[i];\n  for (int i = 0; i < N; i++) GetAllSubstrings(S[i], a[i]);\n\n  const int INF = 1e5;\n  // 初始化動態規劃的首排。\n  dp[0][0] = -INF; // 不允許有空字串，所以給他 -INF。\n  for (int i = 1; i < (1<<S[0].size()); i++)\n    dp[0][i] = max(dp[0][i-1], (int)a[0][i].size());\n\n  // 然後依照遞迴關係計算剩下的部份。\n  for (int i = 1; i < N; i++) {\n    dp[i][0] = -INF; // 一樣不允許有空字串，所以給他 -INF。\n    for (int j = 1, k = 0; j < (1<<S[i].size()); j++) {\n        while (k < (1<<S[i-1]).size() && a[i-1][k] < a[i][j]) ++k;\n        dp[i][j] = max(dp[i][j-1], dp[i-1][k] + (int)a[i][k].size());\n    }\n  }\n  \n  int ans = dp[N-1][(1<<S[N-1].size())];\n  if (ans < 0) cout << \"-1\" << endl;\n  else cout << ans << endl;\n  return 0;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"備註"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果把所有的字串都預處理產生出來以後，用 Bucket Sort (桶子排序法) 把所有的字串全部排序起來。這麼一來就可以省下硬比較兩字串的時間，可以加速到 $O(15\\times 2^{15})$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"關於競程日記"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"🍅 如果您想到更多有趣漂亮簡單乾淨的解法話歡迎留言給競程日記小編群！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"ℹ️ 這是一篇投稿給"},{"type":"element","tagName":"a","properties":{"href":"https://www.facebook.com/%E7%AB%B6%E7%A8%8B%E6%97%A5%E8%A8%98-1514973425463954/"},"children":[{"type":"text","value":"競程日記"}]},{"type":"text","value":"的文章，歡迎大家投稿、交流與分享程式解題競賽的點點滴滴！"}]}],"data":{"quirksMode":false}},"frontmatter":{"date":"January 06, 2019","path":"/problem/icpc/asia_jakarta_2018/J","title":"Future Generation","description":"給你 $N$ ($1\\le N\\le 15$) 個字串 $S_1, \\ldots, S_N$ ($1\\le |S_i| \\le 15$)。現在請你對於每一個字串 $S_i$，找出一個非空的子序列 $A_i$，使得 $A_1, A_2, \\ldots, A_N$ 依照字典順序是嚴格遞增的。\n\n輸出最大的 $|A_1|+|A_2|+\\cdots + |A_N|$ 之值。若無解的話要輸出 `-1`。\n","roadmap_label_h3":null,"backlink":"/icpcblog-weekly-2019"}}},"pageContext":{}}