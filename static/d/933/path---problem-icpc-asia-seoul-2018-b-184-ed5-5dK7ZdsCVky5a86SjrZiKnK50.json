{"data":{"markdownRemark":{"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"簡化後題目敘述"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"第一列包含兩個正整數 $m, n$ ($1\\le m, n\\le 500$)。第二列開始有 $n$ 列，每一列恰好有 $m$ 個介於 $0$ 到 $10^6$ 之間的整數，代表一個人依序對編號 $1$ 到 $m$ 的化妝品的偏好順序。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸出說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"請由小到大輸出所有可能的優勝化妝品編號。可以證明至少存在一個這樣的化妝品。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"3 4\n1 1 1\n0 0 0\n2 2 2\n3 3 3\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"1 2 3\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"4 5\n1 0 1 1\n1 1 5 2\n2 1 3 6\n0 1 0 1\n1 2 2 2\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"1 2\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 3"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"5 4\n0 1 0 2 1\n1 7 2 1 0\n4 5 2 3 3\n1 2 9 0 2\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"5\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ 連結"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://codeforces.com/gym/101987"},"children":[{"type":"text","value":"Codeforces Gym"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"題目出處"}]},{"type":"text","value":"：ICPC 2018 Asia Seoul Regional"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"直接按照定義找出每一個配對 $(X, Y)$ 之間的距離就可以了。"},{"type":"element","tagName":"a","properties":{"href":"https://en.wikipedia.org/wiki/Widest_path_problem"},"children":[{"type":"text","value":"最大瓶頸距離"}]},{"type":"text","value":"可以使用 Floyd-Warshall 演算法迅速解決。這樣的話時間複雜度是 $O(m^3+m^2n)$。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"#include <bits/stdc++.h>\nusing namespace std;\n\nint g[505][505];\n\nint main() {\n  const int INF = 1e9;\n  int m, n;\n  cin >> m >> n;\n  for (int i = 1; i <= n; i++) {\n    vector<int> preference(m + 1);\n    for (int j = 1; j <= m; j++) {\n      cin >> preference[j];\n      if (preference[j] == 0)\n        preference[j] = INF;\n    }\n    for (int j = 1; j <= m; j++)\n      for (int k = j + 1; k <= m; k++)\n        if (preference[j] < preference[k]) {\n          g[j][k]++;\n        } else if (preference[j] > preference[k]) {\n          g[k][j]++;\n        }\n  }\n\n  for (int i = 1; i <= m; i++)\n    for (int j = i + 1; j <= m; j++)\n      if (g[i][j] == g[j][i])\n        g[i][j] = g[j][i] = 0;\n      else if (g[i][j] < g[j][i])\n        g[i][j] = 0;\n      else\n        g[j][i] = 0;\n\n  for (int k = 1; k <= m; k++)\n    for (int i = 1; i <= m; i++)\n      for (int j = 1; j <= m; j++)\n        if (i != j)\n          g[i][j] = max(g[i][j], min(g[i][k], g[k][j]));\n\n  vector<int> sol;\n  for (int i = 1; i <= m; i++) {\n    bool ok = true;\n    for (int j = 1; j <= m; j++)\n      if (g[i][j] < g[j][i])\n        ok = false;\n    if (ok)\n      sol.push_back(i);\n  }\n  for (auto x : sol)\n    cout << x << ' ';\n  cout << endl;\n  return 0;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"備註"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這道題目的模型其實是來自於 "},{"type":"element","tagName":"a","properties":{"href":"https://en.wikipedia.org/wiki/Schulze_method"},"children":[{"type":"text","value":"Schulze method"}]},{"type":"text","value":"，是一種透過提交偏好順序選出最佳若干選擇（可以不只選出一個）的選舉模型。從維基百科上面看起來，這個方法被廣泛地運用在"},{"type":"element","tagName":"a","properties":{"href":"https://en.wikipedia.org/wiki/Schulze_method#Users"},"children":[{"type":"text","value":"各種組織"}]},{"type":"text","value":"裡面。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"而最大瓶頸路徑問題可以在 $O(n^{(3+\\omega)/2})\\approx O(n^{2.688})$ 時間內被"},{"type":"element","tagName":"a","properties":{"href":"https://dl.acm.org/citation.cfm?id=1496813"},"children":[{"type":"text","value":"求出"}]},{"type":"text","value":"。其中 $\\omega$ 是所有矩陣相乘演算法能夠做到的最小指數。（目前的紀錄是 2.373）。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"關於競程日記"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"🍅 如果您想到更多有趣漂亮簡單乾淨的解法話歡迎留言給競程日記小編群！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"ℹ️ 這是一篇投稿給"},{"type":"element","tagName":"a","properties":{"href":"https://www.facebook.com/%E7%AB%B6%E7%A8%8B%E6%97%A5%E8%A8%98-1514973425463954/"},"children":[{"type":"text","value":"競程日記"}]},{"type":"text","value":"的文章，歡迎大家投稿、交流與分享程式解題競賽的點點滴滴！"}]}],"data":{"quirksMode":false}},"frontmatter":{"date":"January 27, 2019","path":"/problem/icpc/asia_seoul_2018/B","title":"Cosmetic Survey","description":"現在有 $m$ 種化妝品，讓 $n$ 個人來評分。每一個人都會給你一張列表，描述他們有多偏好這個化妝品。寫 1 表示最喜歡、寫 2 表示次喜歡，以此類推。如果是 0 表示都不喜歡（是在列表的最末端）。偏好順序允許重複。\n\n對於任兩種化妝品，我們可以定義 $d(X, Y)$ 為有多少人喜歡 $X$ 嚴格勝過 $Y$。如果 $d(X, Y) > d(Y, X)$，那麼我們可以在圖上定義一條邊、權重為 $d(X, Y)$。而任何從 $X$ 到 $Y$ 的路徑上，其最小的邊權重，的最大可能值，就被我們定義為 $S(X, Y)$。如果 $X$ 到 $Y$ 之間不存在任何路徑，就定義 $S(X, Y) = 0$。\n\n請找出所有可能的優勝化妝品 $X$：滿足對所有 $Y$ 都有 $S(X, Y) \\ge S(Y, X)$。\n","roadmap_label_h3":null,"backlink":"/icpcblog-weekly-2019"}}},"pageContext":{}}