{"data":{"markdownRemark":{"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"簡化後題目敘述"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"第一列包含一個正整數 $N$ ($1\\le N\\le 15$)。第二列開始有 $N$ 列，每一列包含一個僅由大寫字母組成的字串 $S_i$ ($1\\le |S_i|\\le 15$)\n。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸出說明"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"輸出最大的 $|A_1|+|A_2|+\\cdots + |A_N|$ 之值。若無解的話要輸出 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"-1"}]},{"type":"text","value":"。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"3\nKARIM\nPARBUDI\nCHANDRA\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"16\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"2\nZORO\nANDI\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"-1\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 3"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"7\nHAVE\nFUN\nIN\nICPC\nJAKARTA\nTWENTY\nEIGHTEEN\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 3"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"25\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ 連結"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://codeforces.com/gym/102001/problem/J"},"children":[{"type":"text","value":"Codeforces Gym 102001 - J"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"總之就是很直白的動態規劃囉。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"令 $\\dp[i][S]$ 為作到第 $i$ 個字串且選取 $A_i=S$ 的時候，$|A_1|+\\cdots + |A_i|$ 可能的最大值。此時我們可以列出遞迴式："}]},{"type":"text","value":"\n$$\n\\dp[i][S] = \\begin{cases}\n\\max_{T < S} \\left\\{ dp[i-1][T] + |S|\\right\\} \\\\\n-\\infty & \\text{如果不存在任何 $T < S$}\n\\end{cases}\n$$\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring S[15];\nvector<string> a[15];\nint dp[15][1<<15];\n\nvoid GetAllSubstrings(string s, vector<string>& result) {\n  result.push_back(\"\");\n  for (int i = 0; i < (int)s.size(); i++) {\n    int n = result.size();\n    for (int j = 0; j < n; j++) {\n      result.push_back(result[j]+s[i]);\n    }\n  }\n  sort(result.begin(), result.end());\n}\n\nint main() {\n  int N;\n  cin >> N;\n  for (int i = 0; i < N; i++) cin >> S[i];\n  for (int i = 0; i < N; i++) GetAllSubstrings(S[i], a[i]);\n\n  const int INF = 1e5;\n  dp[0][0] = -INF;\n  for (int i = 1; i < (1<<S[0].size()); i++)\n    dp[0][i] = max(dp[0][i-1], (int)a[0][i].size());\n  for (int i = 1; i < N; i++) {\n    dp[i][0] = -INF;\n    for (int j = 1, k = 1; k < (1<<S[i].size()); k++) {\n      dp[i][k] = max(dp[i][k-1], dp[i-1][j-1] + (int)a[i][k].size());\n      while (j < (1<<S[i-1].size()) && a[i-1][j] < a[i][k]) {\n        dp[i][k] = max(dp[i][k], dp[i-1][j] + (int)a[i][k].size());\n        ++j;\n      }\n    }\n  }\n  \n  int ans = *max_element(dp[N-1], dp[N-1] + (1<<S[N-1].size()));\n  if (ans < 0) cout << \"-1\" << endl;\n  else cout << ans << endl;\n  return 0;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"關於競程日記"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"🍅 如果您想到更多有趣漂亮簡單乾淨的解法話歡迎留言給競程日記小編群！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"ℹ️ 這是一篇投稿給"},{"type":"element","tagName":"a","properties":{"href":"https://www.facebook.com/%E7%AB%B6%E7%A8%8B%E6%97%A5%E8%A8%98-1514973425463954/"},"children":[{"type":"text","value":"競程日記"}]},{"type":"text","value":"的文章，歡迎大家投稿、交流與分享程式解題競賽的點點滴滴！"}]}],"data":{"quirksMode":false}},"frontmatter":{"date":"January 06, 2019","path":"/problem/icpc/asia_jakarta_2018/J","title":"Future Generation","description":"給你 $N$ ($1\\le N\\le 15$) 個字串 $S_1, \\ldots, S_N$ ($1\\le |S_i| \\le 15$)。現在請你對於每一個字串 $S_i$，找出一個非空的子序列 $A_i$，使得 $A_1, A_2, \\ldots, A_N$ 依照字典順序是嚴格遞增的。\n\n輸出最大的 $|A_1|+|A_2|+\\cdots + |A_N|$ 之值。若無解的話要輸出 `-1`。\n","roadmap_label_h3":null,"backlink":"/icpcblog-weekly-2019"}}},"pageContext":{}}