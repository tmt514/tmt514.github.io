{"data":{"markdownRemark":{"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"ç°¡åŒ–å¾Œé¡Œç›®æ•˜è¿°"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"è¼¸å…¥èªªæ˜"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"è¼¸å‡ºèªªæ˜"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"ç¯„ä¾‹è¼¸å…¥ 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"5\n0 13 4 4\n2 14 11 9\n7 17 12 12\n3 5 16 0\n5 2 13 1\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"ç¯„ä¾‹è¼¸å‡º 1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"5\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"ç¯„ä¾‹è¼¸å…¥ 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"5\n0 4 4 0\n1 3 3 1\n5 8 9 4\n0 12 4 8\n1 11 3 9\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"ç¯„ä¾‹è¼¸å‡º 2"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"4\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ é€£çµ"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://codeforces.com/gym/101987"},"children":[{"type":"text","value":"Codeforces Gym"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"é¡Œç›®å‡ºè™•"}]},{"type":"text","value":"ï¼šICPC 2018 Asia Seoul Regional"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"è§£æ³•"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"é€™é¡Œæ˜¯ç·šæ®µæ¨¹/å€é–“æ¨¹å¾ˆç›´æ¥çš„æ‡‰ç”¨ã€‚ç”±æ–¼åˆ‡å‰²çš„éƒ½æ˜¯æ°´å¹³ç·šï¼Œå°æ–¼æ¯ä¸€å€‹è¼¸å…¥çš„çŸ©å½¢åªè¦è€ƒæ…®å®ƒçš„ Y-åº§æ¨™å€é–“å°±å¯ä»¥äº†ã€‚"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"åˆ©ç”¨æƒæç·šçš„æ¦‚å¿µï¼Œè€ƒæ…®å…¶ä¸­ Y-åº§æ¨™è¼ƒä½çš„é‚£æ¢ç·šçš„ä½ç½®ï¼ˆæ¯”æ–¹èªªå¾ä¸‹åˆ°ä¸Šæ…¢æ…¢æ¨é€²ï¼‰ã€‚å›ºå®šäº†é€™å€‹ä½ç½® $y=y_0$ ä»¥å¾Œ"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"åƒè€ƒç¨‹å¼ç¢¼"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"#include <bits/stdc++.h>\nusing namespace std;\n\n// é›¢æ•£åŒ–ï¼šæŠŠæ‰€æœ‰éœ€è¦çš„åº§æ¨™è¨˜éŒ„ä¸‹ä¾†ï¼Œæ’åºä»¥å¾Œæ›æˆé›¢æ•£åŒ–å¾Œçš„åº§æ¨™ã€‚\nint discretize(vector<pair<int, int>> &a) {\n  vector<int> lisan;\n  for (auto &it : a) {\n    lisan.push_back(it.first);\n    lisan.push_back(it.second);\n  }\n  sort(lisan.begin(), lisan.end());\n  lisan.resize(unique(lisan.begin(), lisan.end()) - lisan.begin());\n  for (size_t i = 0; i < a.size(); i++) {\n    a[i].first =\n        lower_bound(lisan.begin(), lisan.end(), a[i].first) - lisan.begin() + 1;\n    a[i].second = lower_bound(lisan.begin(), lisan.end(), a[i].second) -\n                  lisan.begin() + 1;\n  }\n  return lisan.size();\n}\n\n// å€é–“æ¨¹çš„ç¯€é»è¦å­˜çš„æ±è¥¿ã€‚\nstruct Node {\n  int max, sum;\n  Node(int _max = 0, int _sum = 0) : max(_max), sum(_sum) {}\n};\n\nint main() {\n  // è¼¸å…¥å¾ˆå¤§æ‰€ä»¥è¦åŠ å¿«è®€å–è¼¸å…¥çš„é€Ÿåº¦ã€‚\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n\n  vector<pair<int, int>> a;\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    int ux, uy, vx, vy;\n    cin >> ux >> uy >> vx >> vy;\n    a.emplace_back(vy, uy);\n  }\n  // Ranges become [1, m].\n  int m = discretize(a);\n  sort(a.begin(), a.end());\n\n  // Find best offset for an interval tree.\n  int offset = m + 1;\n  while ((offset & -offset) != offset)\n    offset += (offset & -offset);\n\n  vector<int> localmax(n + 1, 0);\n  vector<Node> segtree(2 * offset);\n  const auto pull = [&](int x) {\n    if (x >= offset) {\n      segtree[x].max = segtree[x].sum;\n    } else {\n      segtree[x].max =\n          max(segtree[x * 2].max, segtree[x * 2 + 1].max) + segtree[x].sum;\n    }\n  };\n  auto add_segment = [&](int x, int v) {\n    while (x) {\n      if (x % 2 == 0) {\n        segtree[x].sum += v;\n        pull(x);\n        --x;\n      } else {\n        x /= 2;\n        pull(x + 1);\n      }\n    }\n  };\n\n  for (int i = n - 1; i >= 0; i--) {\n    add_segment(offset + a[i].second, 1);\n    add_segment(offset + a[i].first - 1, -1);\n    localmax[i] = segtree[1].max;\n  }\n\n  vector<int> change(m + 2);\n  for (int i = 0; i < n; i++) {\n    change[a[i].first]++;\n    change[a[i].second + 1]--;\n  }\n  int ans = 0;\n  for (int i = 0, j = 0, now = 0; i <= m; i++) {\n    while (j < n && a[j].first <= i)\n      ++j;\n    now += change[i];\n    ans = max(ans, now + localmax[j]);\n  }\n\n  cout << ans << endl;\n  return 0;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"é—œæ–¼ç«¶ç¨‹æ—¥è¨˜"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"ğŸ… å¦‚æœæ‚¨æƒ³åˆ°æ›´å¤šæœ‰è¶£æ¼‚äº®ç°¡å–®ä¹¾æ·¨çš„è§£æ³•è©±æ­¡è¿ç•™è¨€çµ¦ç«¶ç¨‹æ—¥è¨˜å°ç·¨ç¾¤ï¼"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"â„¹ï¸ é€™æ˜¯ä¸€ç¯‡æŠ•ç¨¿çµ¦"},{"type":"element","tagName":"a","properties":{"href":"https://www.facebook.com/%E7%AB%B6%E7%A8%8B%E6%97%A5%E8%A8%98-1514973425463954/"},"children":[{"type":"text","value":"ç«¶ç¨‹æ—¥è¨˜"}]},{"type":"text","value":"çš„æ–‡ç« ï¼Œæ­¡è¿å¤§å®¶æŠ•ç¨¿ã€äº¤æµèˆ‡åˆ†äº«ç¨‹å¼è§£é¡Œç«¶è³½çš„é»é»æ»´æ»´ï¼"}]}],"data":{"quirksMode":false}},"frontmatter":{"date":"January 24, 2019","path":"/problem/icpc/asia_seoul_2018/A","title":"Circuits","description":"","roadmap_label_h3":null,"backlink":"/icpcblog-weekly-2019"}}},"pageContext":{}}