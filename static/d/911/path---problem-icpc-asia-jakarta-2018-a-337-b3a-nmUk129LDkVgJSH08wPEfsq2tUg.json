{"data":{"markdownRemark":{"htmlAst":{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"題目敘述"}]},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"showvariable","properties":{"varname":"description"},"children":[]}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸入說明"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"輸入僅有一行包含二元字串 $S$（$1\\le |S|\\le 2000$）。"}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"輸出說明"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"輸出一個與 $S$ 長度相等的二元字串 $T$，滿足 $edit(S, T) > |S|/2$。"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 1"}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"0011\n"}]}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 1"}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"1100\n"}]}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸入 2"}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"1100101\n"}]}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"範例輸出 2"}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"0011010\n"}]}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"OJ 連結"}]},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://codeforces.com/gym/102001/problem/A"},"children":[{"type":"text","value":"Codeforces Gym 102001 - A"}]}]},{"type":"text","value":"\n"}]},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"解法"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果單純把所有數字都反過來，可能不太行。比方說以下的反例："},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"01010101"}]},{"type":"text","value":"，反過來就變成 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"10101010"}]},{"type":"text","value":"，顯然我們只要刪掉第一個字元並且補到後面去就行了。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"換一個想法想，如果字串長度 $n$ 是奇數，那麼根據 $edit({\\tt{000\\cdots 0}}, S) + edit(S, {\\tt{111\\cdots 1}}) \\ge edit({\\tt{000\\cdots 0}}, {\\tt{111\\cdots 1}}) = n$，我們知道其中一個一定會超過 $n/2$，因為 $n$ 是奇數，所以一定有一個會嚴格大於 $n/2$。換句話說，$n$ 是奇數的時候很好解決！"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"那 $n$ 是偶數的時候怎麼辦？考慮 $S$ 的前 $n-1$ 個 bit（此時 $n-1$ 是奇數）我們稱這個前綴為 $S_0$。根據前一段的論述，我們可以找出一個 $T_0$ 滿足 $edit(S_0, T_0)\\ge \\lceil \\frac{n-1}{2}\\rceil = n/2$。此時顯然有 $edit(S, T_0), edit(S_0, T_0+{\\tt{0}}), edit(S_0, T_0+{\\tt{1}}) \\ge n/2$。還記得計算 edit distance 的動態規劃嗎？無論我們在 $T_0$ 後面補哪個字元 $x$，總能夠有"}]},{"type":"text","value":"$$\n    edit(S, T_0+x) = \\min \\begin{cases}\n    edit(S_0, T_0) + (S[n-1] {\\tt{==}} x) & \\text{修改字元}\\\\\n    edit(S_0, T_0+x) + 1 & \\text{刪除字元}\\\\\n    edit(S, T_0) + 1 & \\text{插入字元}\n    \\end{cases}\n$$"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"這時候注意到：如果我們選定 $x\\neq S[n-1]$，無論是哪種 case 都至少保證此時 $edit(S, T_0+x) > n/2$，達到目標！"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"參考程式碼"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"為了實作方便，我們考慮的是 $S$ 的末 $n-1$ 個字元，然後找到 $T$ 以後再根據 $S[0]$ 把相對應的字元放到前面。"}]},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"#include <iostream>\n#include <string>\nusing namespace std;\n\nint main() {\n  string s, t;\n  cin >> s;\n  \n  // 計算字串中 0 和 1 出現的個數。\n  int b[2] = {};\n  for (int i = 1; i < s.size(); i++) b[s[i]=='1']++;\n  \n  // 構造出距離比較遠的全 0 或全 1 字串。\n  t = string(s.size(), '0' + (b[0] > b[1]));\n  \n  // 然後把第一個字元改成與 s[0] 不同的字元，並且輸出。\n  t[0] = '0' + '1' - s[0];\n  cout << t << endl;\n  return 0;\n}\n"}]}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"備註 1"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Edit Distance 好像又被稱為 "},{"type":"element","tagName":"a","properties":{"href":"https://en.wikipedia.org/wiki/Levenshtein_distance"},"children":[{"type":"text","value":"Levenshtein Distance"}]},{"type":"text","value":"，是一種衡量兩個字串是否有多接近的指標（metric，不是 pointer XD）。"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"備註 2"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Edit Distance 滿足三角不等式：$edit(A, B)+edit(B, C) \\ge edit(A, C)$，白話文解釋就是從 $A$ 換到 $C$ 的方法，至少有先從 $A$ 變成 $B$ 再從 $B$ 變成 $C$ 來得好。"}]},{"type":"element","tagName":"theorem","properties":{"title":"冷知識","c":"is-warning"},"children":[{"type":"text","value":"\n"}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"關於競程日記"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"🍅 如果您想到更多有趣漂亮簡單乾淨的解法話歡迎留言給競程日記小編群！"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"ℹ️ 這是一篇投稿給"},{"type":"element","tagName":"a","properties":{"href":"https://www.facebook.com/%E7%AB%B6%E7%A8%8B%E6%97%A5%E8%A8%98-1514973425463954/"},"children":[{"type":"text","value":"競程日記"}]},{"type":"text","value":"的文章，歡迎大家投稿、交流與分享程式解題競賽的點點滴滴！"}]}]},"frontmatter":{"date":"January 01, 2019","path":"/problem/icpc/asia_jakarta_2018/A","title":"Edit Distance","description":"對於兩個給定的字串 $S$ 和 $T$，我們定義 $edit(S, T)$ 為從 $S$ 經過若干插入字元、修改字元、刪除字元等操作後得到 $T$ 所需要的最少步數。\n\nAyu 有一個二元字串 $S$（$1\\le |S|\\le 2000$），她想要找到另一個字串 $T_{max}$ 使得 $edit(S, T_{max})$ 最大。即對於所有與 $S$ 等長的 $T$，$edit(S, T_{max})\\ge edit(S, T)$。不過呢，為了讓事情變得簡單些，她希望你能夠幫她的忙，找到任何一個與 $S$ 長度相同的字串 $T$，只要 $edit(S, T) > |S|/2$ 即可。\n\n當然，你也可以選擇輸出 $T_{max}$，事實上我們可以證明 $edit(S, T_{max}) > |S|/2$。這也保證了對於任意輸入一定有解。\n","roadmap_label_h3":null,"backlink":null}}},"pageContext":{}}